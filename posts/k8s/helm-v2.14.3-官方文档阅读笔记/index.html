<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>Helm v2.14.3 官方文档阅读笔记 - MyBlog</title><meta name="Description" content="我的博客"><meta property="og:title" content="Helm v2.14.3 官方文档阅读笔记" />
<meta property="og:description" content="helm 官方文档地址：https://helm.sh/docs/ The package manager for Kubernetes helm 是 kubernetes 的包管理器。 NOTE: Kubernetes versions prior to 1.6 have limited or no support for role-based access controls (RBAC). Helm will figure out where to install Tiller by reading your" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://msdemt.github.io/posts/k8s/helm-v2.14.3-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" />
<meta property="og:image" content="https://msdemt.github.io/logo.png"/>
<meta property="article:published_time" content="2019-10-13T21:05:21+08:00" />
<meta property="article:modified_time" content="2019-10-13T21:05:21+08:00" />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://msdemt.github.io/logo.png"/>

<meta name="twitter:title" content="Helm v2.14.3 官方文档阅读笔记"/>
<meta name="twitter:description" content="helm 官方文档地址：https://helm.sh/docs/ The package manager for Kubernetes helm 是 kubernetes 的包管理器。 NOTE: Kubernetes versions prior to 1.6 have limited or no support for role-based access controls (RBAC). Helm will figure out where to install Tiller by reading your"/>
<meta name="application-name" content="LoveIt">
<meta name="apple-mobile-web-app-title" content="LoveIt"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://msdemt.github.io/posts/k8s/helm-v2.14.3-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" /><link rel="prev" href="https://msdemt.github.io/posts/linux/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BF%A1%E6%81%AF%E6%9F%A5%E8%AF%A2/" /><link rel="next" href="https://msdemt.github.io/posts/k8s/k8s-v1.15.0-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%B9%E5%BC%8F%E9%83%A8%E7%BD%B2/" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "Helm v2.14.3 官方文档阅读笔记",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/msdemt.github.io\/posts\/k8s\/helm-v2.14.3-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0\/"
        },"image": ["https:\/\/msdemt.github.io\/images\/Apple-Devices-Preview.png"],"genre": "posts","keywords": "k8s, tag2, tag3","wordcount":  30208 ,
        "url": "https:\/\/msdemt.github.io\/posts\/k8s\/helm-v2.14.3-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0\/","datePublished": "2019-10-13T21:05:21+08:00","dateModified": "2019-10-13T21:05:21+08:00","license": "This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher": {
            "@type": "Organization",
            "name": "xxxx","logo": "https:\/\/msdemt.github.io\/images\/avatar.png"},"author": {
                "@type": "Person",
                "name": "xxxx"
            },"description": ""
    }
    </script></head>
    <body header-desktop="fixed" header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="MyBlog"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw'></i></span>MyBlog</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 所有文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><a class="menu-item" href="/categories/documentation/"> 文档 </a><a class="menu-item" href="/about/"> 关于 </a><a class="menu-item" href="https://github.com/dillonzq/LoveIt" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i>  </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="MyBlog"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw'></i></span>MyBlog</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/posts/" title="">所有文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a class="menu-item" href="/categories/documentation/" title="">文档</a><a class="menu-item" href="/about/" title="">关于</a><a class="menu-item" href="https://github.com/dillonzq/LoveIt" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i></a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animated flipInX">Helm v2.14.3 官方文档阅读笔记</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="/" title="Author" rel=" author" class="author"><i class="fas fa-user-circle fa-fw"></i>xxxx</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2019-10-13">2019-10-13</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 30208 字&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 61 分钟&nbsp;</div>
        </div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#understand-your-security-context">Understand your Security Context</a>
      <ul>
        <li><a href="#role-based-access-control">Role-based Access Control</a>
          <ul>
            <li><a href="#tiller-and-role-based-access-control">TILLER AND ROLE-BASED ACCESS CONTROL</a>
              <ul>
                <li><a href="#example-service-account-with-cluster-admin-role">Example: Service account with cluster-admin role</a></li>
                <li><a href="#example-deploy-tiller-in-a-namespace-restricted-to-deploying-resources-only-in-that-namespace">Example: Deploy Tiller in a namespace, restricted to deploying resources only in that namespace</a></li>
                <li><a href="#example-deploy-tiller-in-a-namespace-restricted-to-deploying-resources-in-another-namespace">Example: Deploy Tiller in a namespace, restricted to deploying resources in another namespace</a></li>
              </ul>
            </li>
            <li><a href="#helm-and-role-based-access-control">HELM AND ROLE-BASED ACCESS CONTROL</a>
              <ul>
                <li><a href="#example-deploy-helm-in-a-namespace-talking-to-tiller-in-another-namespace">Example: Deploy Helm in a namespace, talking to Tiller in another namespace</a></li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#install-helm">INSTALL HELM</a>
      <ul>
        <li><a href="#installing-the-helm-client">INSTALLING THE HELM CLIENT</a></li>
        <li><a href="#installing-tiller">INSTALLING TILLER</a>
          <ul>
            <li><a href="#easy-in-cluster-installation">Easy In-Cluster Installation</a></li>
            <li><a href="#installing-tiller-canary-builds">Installing Tiller Canary Builds</a></li>
            <li><a href="#running-tiller-locally">Running Tiller Locally</a></li>
          </ul>
        </li>
        <li><a href="#upgrading-tiller">UPGRADING TILLER</a></li>
        <li><a href="#deleting-or-reinstalling-tiller">DELETING OR REINSTALLING TILLER</a></li>
        <li><a href="#initialize-helm-and-install-tiller">INITIALIZE HELM AND INSTALL TILLER</a>
          <ul>
            <li><a href="#install-an-example-chart">INSTALL AN EXAMPLE CHART</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#using-helm">Using Helm</a>
      <ul>
        <li><a href="#three-big-concepts">THREE BIG CONCEPTS</a></li>
        <li><a href="#helm-search-finding-charts">‘HELM SEARCH’: FINDING CHARTS</a></li>
        <li><a href="#helm-install-installing-a-package">‘HELM INSTALL’: INSTALLING A PACKAGE</a>
          <ul>
            <li><a href="#customizing-the-chart-before-installing">Customizing the Chart Before Installing</a></li>
            <li><a href="#more-installation-methods">More Installation Methods</a></li>
          </ul>
        </li>
        <li><a href="#helm-upgrade-and-helm-rollback-upgrading-a-release-and-recovering-on-failure">‘HELM UPGRADE’ AND ‘HELM ROLLBACK’: UPGRADING A RELEASE, AND RECOVERING ON FAILURE</a></li>
        <li><a href="#helpful-options-for-installupgraderollback">HELPFUL OPTIONS FOR INSTALL/UPGRADE/ROLLBACK</a></li>
        <li><a href="#helm-delete-deleting-a-release">‘HELM DELETE’: DELETING A RELEASE</a></li>
        <li><a href="#helm-repo-working-with-repositories">‘HELM REPO’: WORKING WITH REPOSITORIES</a></li>
        <li><a href="#creating-your-own-charts">CREATING YOUR OWN CHARTS</a></li>
        <li><a href="#tiller-namespaces-and-rbac">TILLER, NAMESPACES AND RBAC</a></li>
        <li><a href="#conclusion">CONCLUSION</a></li>
      </ul>
    </li>
    <li><a href="#charts">Charts</a>
      <ul>
        <li><a href="#the-chart-file-structure">THE CHART FILE STRUCTURE</a>
          <ul>
            <li><a href="#the-chartyaml-file">THE CHART.YAML FILE</a>
              <ul>
                <li><a href="#charts-and-versioning">Charts and Versioning</a></li>
                <li><a href="#the-appversion-field">The appVersion field</a></li>
                <li><a href="#deprecating-charts">Deprecating Charts</a></li>
              </ul>
            </li>
            <li><a href="#chart-license-readme-and-notes">CHART LICENSE, README AND NOTES</a></li>
            <li><a href="#chart-dependencies">CHART DEPENDENCIES</a>
              <ul>
                <li><a href="#managing-dependencies-with-requirementsyaml">Managing Dependencies with <code>requirements.yaml</code></a></li>
                <li><a href="#alias-field-in-requirementsyaml">Alias field in requirements.yaml</a></li>
                <li><a href="#tags-and-condition-fields-in-requirementsyaml">Tags and Condition fields in requirements.yaml</a></li>
                <li><a href="#importing-child-values-via-requirementsyaml">Importing Child Values via requirements.yaml</a>
                  <ul>
                    <li><a href="#using-the-exports-format">Using the exports format</a></li>
                    <li><a href="#using-the-child-parent-format">Using the child-parent format</a></li>
                  </ul>
                </li>
                <li><a href="#managing-dependencies-manually-via-the-charts-directory">Managing Dependencies manually via the <code>charts/</code> directory</a></li>
                <li><a href="#operational-aspects-of-using-dependencies">Operational aspects of using dependencies</a></li>
              </ul>
            </li>
            <li><a href="#templates-and-values">TEMPLATES AND VALUES</a>
              <ul>
                <li><a href="#template-files">Template Files</a>
                  <ul>
                    <li><a href="#predefined-values">Predefined Values</a></li>
                  </ul>
                </li>
                <li><a href="#values-files">Values files</a>
                  <ul>
                    <li><a href="#scope-dependencies-and-values">Scope, Dependencies, and Values</a></li>
                    <li><a href="#references">References</a></li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#using-helm-to-manage-charts">USING HELM TO MANAGE CHARTS</a></li>
        <li><a href="#chart-repositories">CHART REPOSITORIES</a></li>
        <li><a href="#chart-starter-packs">CHART STARTER PACKS</a></li>
      </ul>
    </li>
    <li><a href="#hooks">Hooks</a>
      <ul>
        <li><a href="#the-available-hooks">THE AVAILABLE HOOKS</a></li>
        <li><a href="#hooks-and-the-release-lifecycle">HOOKS AND THE RELEASE LIFECYCLE</a>
          <ul>
            <li><a href="#hook-resources-are-not-managed-with-corresponding-releases">Hook resources are not managed with corresponding releases</a></li>
          </ul>
        </li>
        <li><a href="#writing-a-hook">WRITING A HOOK</a>
          <ul>
            <li><a href="#defining-a-crd-with-the-crd-install-hook">Defining a CRD with the <code>crd-install</code> Hook</a></li>
            <li><a href="#automatically-delete-hook-from-previous-release">Automatically delete hook from previous release</a></li>
          </ul>
        </li>
        <li><a href="#chart-development-tips-and-tricks">Chart Development Tips and Tricks</a>
          <ul>
            <li><a href="#know-your-template-functions">KNOW YOUR TEMPLATE FUNCTIONS</a></li>
            <li><a href="#quote-strings-dont-quote-integers">QUOTE STRINGS, DON’T QUOTE INTEGERS</a></li>
            <li><a href="#using-the-include-function">USING THE ‘INCLUDE’ FUNCTION</a></li>
            <li><a href="#using-the-required-function">USING THE ‘REQUIRED’ FUNCTION</a></li>
            <li><a href="#using-the-tpl-function">USING THE ‘TPL’ FUNCTION</a></li>
            <li><a href="#creating-image-pull-secrets">CREATING IMAGE PULL SECRETS</a></li>
            <li><a href="#automatically-roll-deployments-when-configmaps-or-secrets-change">AUTOMATICALLY ROLL DEPLOYMENTS WHEN CONFIGMAPS OR SECRETS CHANGE</a></li>
            <li><a href="#tell-tiller-not-to-delete-a-resource">TELL TILLER NOT TO DELETE A RESOURCE</a></li>
            <li><a href="#using-partials-and-template-includes">USING “PARTIALS” AND TEMPLATE INCLUDES</a></li>
            <li><a href="#complex-charts-with-many-dependencies">COMPLEX CHARTS WITH MANY DEPENDENCIES</a></li>
            <li><a href="#yaml-is-a-superset-of-json">YAML IS A SUPERSET OF JSON</a></li>
            <li><a href="#be-careful-with-generating-random-values">BE CAREFUL WITH GENERATING RANDOM VALUES</a></li>
            <li><a href="#upgrade-a-release-idempotently">UPGRADE A RELEASE IDEMPOTENTLY</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#the-chart-repository-guide">The Chart Repository Guide</a>
      <ul>
        <li><a href="#prerequisites">PREREQUISITES</a></li>
        <li><a href="#create-a-chart-repository">CREATE A CHART REPOSITORY</a>
          <ul>
            <li><a href="#the-chart-repository-structure">The chart repository structure</a></li>
            <li><a href="#the-index-file">The index file</a></li>
          </ul>
        </li>
        <li><a href="#hosting-chart-repositories">HOSTING CHART REPOSITORIES</a>
          <ul>
            <li><a href="#chartmuseum">ChartMuseum</a></li>
            <li><a href="#github-pages-example">Github Pages example</a></li>
            <li><a href="#ordinary普通的-web-servers">Ordinary(普通的) web servers</a></li>
          </ul>
        </li>
        <li><a href="#managing-chart-repositories">MANAGING CHART REPOSITORIES</a>
          <ul>
            <li><a href="#store-charts-in-your-chart-repository">Store charts in your chart repository</a></li>
            <li><a href="#add-new-charts-to-an-existing-repository">Add new charts to an existing repository</a></li>
            <li><a href="#share-your-charts-with-others">Share your charts with others</a></li>
          </ul>
        </li>
        <li><a href="#chart-tests">Chart Tests</a>
          <ul>
            <li><a href="#a-breakdown-of-the-helm-test-hooks">A BREAKDOWN OF THE HELM TEST HOOKS</a></li>
            <li><a href="#example-test">EXAMPLE TEST</a></li>
            <li><a href="#steps-to-run-a-test-suite-on-a-release">STEPS TO RUN A TEST SUITE ON A RELEASE</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#the-chart-template-developers-guide">The Chart Template Developer’s Guide</a>
      <ul>
        <li><a href="#getting-started-with-a-chart-template">Getting Started with a Chart Template</a>
          <ul>
            <li><a href="#charts-1">CHARTS</a></li>
            <li><a href="#a-starter-chart">A STARTER CHART</a>
              <ul>
                <li><a href="#a-quick-glimpse-of-mycharttemplates">A Quick Glimpse of <code>mychart/templates/</code></a></li>
              </ul>
            </li>
            <li><a href="#a-first-template">A FIRST TEMPLATE</a>
              <ul>
                <li><a href="#adding-a-simple-template-call">Adding a Simple Template Call</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#built-in-objects">Built-in Objects</a></li>
        <li><a href="#values-files-1">Values Files</a>
          <ul>
            <li><a href="#deleting-a-default-key">DELETING A DEFAULT KEY</a></li>
          </ul>
        </li>
        <li><a href="#template-functions-and-pipelines">Template Functions and Pipelines</a>
          <ul>
            <li><a href="#pipelines">PIPELINES</a></li>
            <li><a href="#using-the-default-function">USING THE <code>DEFAULT</code> FUNCTION</a></li>
            <li><a href="#operators-are-functions">OPERATORS ARE FUNCTIONS</a></li>
          </ul>
        </li>
        <li><a href="#flow-control">Flow Control</a>
          <ul>
            <li><a href="#ifelse">IF/ELSE</a></li>
            <li><a href="#controlling-whitespace">CONTROLLING WHITESPACE</a></li>
            <li><a href="#modifying-scope-using-with">MODIFYING SCOPE USING <code>WITH</code></a></li>
            <li><a href="#looping-with-the-range-action">LOOPING WITH THE <code>RANGE</code> ACTION</a></li>
          </ul>
        </li>
        <li><a href="#variables">Variables</a></li>
        <li><a href="#named-templates">Named Templates</a>
          <ul>
            <li><a href="#partials-and-_-files">PARTIALS AND <code>_</code> FILES</a></li>
            <li><a href="#declaring-and-using-templates-with-define-and-template">DECLARING AND USING TEMPLATES WITH <code>DEFINE</code> AND <code>TEMPLATE</code></a></li>
            <li><a href="#setting-the-scope-of-a-template">SETTING THE SCOPE OF A TEMPLATE</a></li>
            <li><a href="#the-include-function">THE <code>INCLUDE</code> FUNCTION</a></li>
          </ul>
        </li>
        <li><a href="#accessing-files-inside-templates">Accessing Files Inside Templates</a>
          <ul>
            <li><a href="#basic-example">BASIC EXAMPLE</a></li>
            <li><a href="#path-helpers">PATH HELPERS</a></li>
            <li><a href="#glob-patterns">GLOB PATTERNS</a></li>
            <li><a href="#configmap-and-secrets-utility-functions">CONFIGMAP AND SECRETS UTILITY FUNCTIONS</a></li>
            <li><a href="#encoding">ENCODING</a></li>
            <li><a href="#lines">LINES</a></li>
          </ul>
        </li>
        <li><a href="#creating-a-notestxt-file">Creating a NOTES.txt File</a></li>
        <li><a href="#subcharts-and-global-values">Subcharts and Global Values</a>
          <ul>
            <li><a href="#creating-a-subchart">CREATING A SUBCHART</a></li>
            <li><a href="#adding-values-and-a-template-to-the-subchart">ADDING VALUES AND A TEMPLATE TO THE SUBCHART</a></li>
            <li><a href="#overriding-values-of-a-child-chart">OVERRIDING VALUES OF A CHILD CHART</a></li>
            <li><a href="#global-chart-values">GLOBAL CHART VALUES</a></li>
            <li><a href="#sharing-templates-with-subcharts">SHARING TEMPLATES WITH SUBCHARTS</a></li>
            <li><a href="#avoid-using-blocks">AVOID USING BLOCKS</a></li>
          </ul>
        </li>
        <li><a href="#debugging-templates">Debugging Templates</a></li>
        <li><a href="#wrapping-up">Wrapping Up</a></li>
      </ul>
    </li>
    <li><a href="#yaml-techniques">YAML Techniques</a>
      <ul>
        <li><a href="#scalars-and-collections">SCALARS AND COLLECTIONS</a></li>
        <li><a href="#scalar-types-in-yaml">Scalar Types in YAML</a></li>
        <li><a href="#strings-in-yaml">STRINGS IN YAML</a></li>
        <li><a href="#controlling-spaces-in-multi-line-strings">Controlling Spaces in Multi-line Strings</a></li>
        <li><a href="#indenting-and-templates">Indenting and Templates</a></li>
        <li><a href="#folded-multi-line-strings">Folded Multi-line Strings</a></li>
        <li><a href="#embedding-multiple-documents-in-one-file">EMBEDDING MULTIPLE DOCUMENTS IN ONE FILE</a></li>
        <li><a href="#yaml-is-a-superset-of-json-1">YAML IS A SUPERSET OF JSON</a></li>
        <li><a href="#yaml-anchors锚">YAML ANCHORS(锚))</a></li>
      </ul>
    </li>
    <li><a href="#appendix-go-data-types-and-templates">Appendix: Go Data Types and Templates</a></li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><p><em><strong>helm 官方文档地址：<a href="https://helm.sh/docs/">https://helm.sh/docs/</a></strong></em></p>
<p>The package manager for Kubernetes<br>
helm 是 kubernetes 的包管理器。</p>
<p><strong>NOTE</strong>: Kubernetes versions prior to 1.6 have limited or no support for role-based access controls (RBAC).</p>
<p>Helm will figure out where to install Tiller by reading your Kubernetes configuration file (usually <code>$HOME/.kube/config</code>). This is the same file that <code>kubectl</code> uses.</p>
<p>To find out which cluster Tiller would install to, you can run <code>kubectl config current-context</code> or <code>kubectl cluster-info</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">[</span>root@k8s-m1 ~<span class="o">]</span><span class="c1"># kubectl config current-context</span>
kubernetes-admin@kubernetes
</code></pre></td></tr></table>
</div>
</div><h2 id="understand-your-security-context">Understand your Security Context</h2>
<p>As with all powerful tools, ensure you are installing it correctly for your scenario.<br>
与所有强大的工具一样，请确保针对您的情况正确安装了它。</p>
<p>If you’re using Helm on a cluster that you completely control, like minikube or a cluster on a private network in which sharing is not a concern, the default installation – which applies no security configuration – is fine, and it’s definitely the easiest. To install Helm without additional security steps, <a href="https://helm.sh/docs/using_helm/#installing-helm" target="_blank" rel="noopener noreffer">install Helm</a> and then <a href="https://helm.sh/docs/using_helm/#initialize-helm-and-install-tiller" target="_blank" rel="noopener noreffer">initialize Helm</a>.</p>
<p>However, if your cluster is exposed to a larger network or if you share your cluster with others – production clusters fall into this category(生产环境集群属于这一类) – you must take extra steps to secure your installation to prevent careless or malicious(恶意的) actors from damaging the cluster or its data. To apply configurations that secure Helm for use in production environments and other multi-tenant scenarios(多租户场景), see <a href="https://helm.sh/docs/using_helm/#securing-your-helm-installation" target="_blank" rel="noopener noreffer">Securing a Helm installation</a></p>
<p>If your cluster has Role-Based Access Control (RBAC) enabled, you may want to <a href="https://helm.sh/docs/using_helm/#role-based-access-control" target="_blank" rel="noopener noreffer">configure a service account</a> and rules before proceeding.</p>
<h3 id="role-based-access-control">Role-based Access Control</h3>
<p>In Kubernetes, granting a role to an application-specific service account is a best practice to ensure that your application is operating in the scope that you have specified. Read more about service account permissions <a href="https://kubernetes.io/docs/admin/authorization/rbac/#service-account-permissions" target="_blank" rel="noopener noreffer">in the official Kubernetes docs</a>.</p>
<p>Bitnami also has a fantastic guide for <a href="https://docs.bitnami.com/kubernetes/how-to/configure-rbac-in-your-kubernetes-cluster/" target="_blank" rel="noopener noreffer">configuring RBAC in your cluster</a> that takes you through RBAC basics.</p>
<p>This guide is for users who want to restrict(限制) Tiller’s capabilities(能力) to install resources to certain namespaces, or to grant a Helm client running access to a Tiller instance.</p>
<h4 id="tiller-and-role-based-access-control">TILLER AND ROLE-BASED ACCESS CONTROL</h4>
<p>You can add a service account to Tiller using the <code>--service-account &lt;NAME&gt;</code> flag while you’re configuring Helm. As a prerequisite, you’ll have to create a role binding which specifies a <a href="https://kubernetes.io/docs/admin/authorization/rbac/#role-and-clusterrole" target="_blank" rel="noopener noreffer">role</a> and a <a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/" target="_blank" rel="noopener noreffer">service account</a> name that have been set up in advance.</p>
<p>Once you have satisfied the pre-requisite and have a service account with the correct permissions, you’ll run a command like this: <code>helm init --service-account &lt;NAME&gt;</code></p>
<h5 id="example-service-account-with-cluster-admin-role">Example: Service account with cluster-admin role</h5>
<p>In <code>rbac-config.yaml</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">apiVersion: v1
kind: ServiceAccount
metadata:
  name: tiller
  namespace: kube-system
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: tiller
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cluster-admin
subjects:
  - kind: ServiceAccount
    name: tiller
    namespace: kube-system
</code></pre></td></tr></table>
</div>
</div><p>Note: The cluster-admin role is created by default in a Kubernetes cluster, so you don’t have to define it explicitly.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ kubectl create -f rbac-config.yaml
serviceaccount <span class="s2">&#34;tiller&#34;</span> created
clusterrolebinding <span class="s2">&#34;tiller&#34;</span> created
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">helm init --service-account tiller --history-max <span class="m">200</span>
</code></pre></td></tr></table>
</div>
</div><h5 id="example-deploy-tiller-in-a-namespace-restricted-to-deploying-resources-only-in-that-namespace">Example: Deploy Tiller in a namespace, restricted to deploying resources only in that namespace</h5>
<p>In the example above, we gave Tiller admin access to the entire cluster. You are not at all required to give Tiller cluster-admin access for it to work. Instead of specifying a ClusterRole or a ClusterRoleBinding, you can specify a Role and RoleBinding to limit Tiller’s scope to a particular namespace.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ kubectl create namespace tiller-world
namespace <span class="s2">&#34;tiller-world&#34;</span> created
$ kubectl create serviceaccount tiller --namespace tiller-world
serviceaccount <span class="s2">&#34;tiller&#34;</span> created
</code></pre></td></tr></table>
</div>
</div><p>Define a Role that allows Tiller to manage all resources in <code>tiller-world</code> like in <code>role-tiller.yaml</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: tiller-manager
  namespace: tiller-world
rules:
- apiGroups: <span class="o">[</span><span class="s2">&#34;&#34;</span>, <span class="s2">&#34;batch&#34;</span>, <span class="s2">&#34;extensions&#34;</span>, <span class="s2">&#34;apps&#34;</span><span class="o">]</span>
  resources: <span class="o">[</span><span class="s2">&#34;*&#34;</span><span class="o">]</span>
  verbs: <span class="o">[</span><span class="s2">&#34;*&#34;</span><span class="o">]</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ kubectl create -f role-tiller.yaml
role <span class="s2">&#34;tiller-manager&#34;</span> created
</code></pre></td></tr></table>
</div>
</div><p>In <code>rolebinding-tiller.yaml</code>,</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: tiller-binding
  namespace: tiller-world
subjects:
- kind: ServiceAccount
  name: tiller
  namespace: tiller-world
roleRef:
  kind: Role
  name: tiller-manager
  apiGroup: rbac.authorization.k8s.io
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ kubectl create -f rolebinding-tiller.yaml
rolebinding <span class="s2">&#34;tiller-binding&#34;</span> created
</code></pre></td></tr></table>
</div>
</div><p>Afterwards you can run <code>helm init</code> to install Tiller in the <code>tiller-world</code> namespace.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ helm init --service-account tiller --tiller-namespace tiller-world
<span class="nv">$HELM_HOME</span> has been configured at /Users/awesome-user/.helm.

Tiller <span class="o">(</span>the Helm server side component<span class="o">)</span> has been installed into your Kubernetes Cluster.

$ helm install stable/lamp --tiller-namespace tiller-world --namespace tiller-world
NAME:   wayfaring-yak
LAST DEPLOYED: Mon Aug  <span class="m">7</span> 16:00:16 <span class="m">2017</span>
NAMESPACE: tiller-world
STATUS: DEPLOYED

RESOURCES:
<span class="o">==</span>&gt; v1/Pod
NAME                  READY  STATUS             RESTARTS  AGE
wayfaring-yak-alpine  0/1    ContainerCreating  <span class="m">0</span>         0s
</code></pre></td></tr></table>
</div>
</div><h5 id="example-deploy-tiller-in-a-namespace-restricted-to-deploying-resources-in-another-namespace">Example: Deploy Tiller in a namespace, restricted to deploying resources in another namespace</h5>
<p>In the example above, we gave Tiller admin access to the namespace it was deployed inside. Now, let’s limit Tiller’s scope to deploy resources in a different namespace!</p>
<p>For example, let’s install Tiller in the namespace <code>myorg-system</code> and allow Tiller to deploy resources in the namespace <code>myorg-users</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ kubectl create namespace myorg-system
namespace <span class="s2">&#34;myorg-system&#34;</span> created
$ kubectl create serviceaccount tiller --namespace myorg-system
serviceaccount <span class="s2">&#34;tiller&#34;</span> created
</code></pre></td></tr></table>
</div>
</div><p>Define a Role that allows Tiller to manage all resources in <code>myorg-users</code> like in <code>role-tiller.yaml</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: tiller-manager
  namespace: myorg-users
rules:
- apiGroups: <span class="o">[</span><span class="s2">&#34;&#34;</span>, <span class="s2">&#34;batch&#34;</span>, <span class="s2">&#34;extensions&#34;</span>, <span class="s2">&#34;apps&#34;</span><span class="o">]</span>
  resources: <span class="o">[</span><span class="s2">&#34;*&#34;</span><span class="o">]</span>
  verbs: <span class="o">[</span><span class="s2">&#34;*&#34;</span><span class="o">]</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ kubectl create -f role-tiller.yaml
role <span class="s2">&#34;tiller-manager&#34;</span> created
</code></pre></td></tr></table>
</div>
</div><p>Bind the service account to that role. In <code>rolebinding-tiller.yaml</code>,</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: tiller-binding
  namespace: myorg-users
subjects:
- kind: ServiceAccount
  name: tiller
  namespace: myorg-system
roleRef:
  kind: Role
  name: tiller-manager
  apiGroup: rbac.authorization.k8s.io
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ kubectl create -f rolebinding-tiller.yaml
rolebinding <span class="s2">&#34;tiller-binding&#34;</span> created
</code></pre></td></tr></table>
</div>
</div><p>We’ll also need to grant Tiller access to read configmaps in myorg-system so it can store release information. In <code>role-tiller-myorg-system.yaml</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  namespace: myorg-system
  name: tiller-manager
rules:
- apiGroups: <span class="o">[</span><span class="s2">&#34;&#34;</span>, <span class="s2">&#34;extensions&#34;</span>, <span class="s2">&#34;apps&#34;</span><span class="o">]</span>
  resources: <span class="o">[</span><span class="s2">&#34;configmaps&#34;</span><span class="o">]</span>
  verbs: <span class="o">[</span><span class="s2">&#34;*&#34;</span><span class="o">]</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ kubectl create -f role-tiller-myorg-system.yaml
role <span class="s2">&#34;tiller-manager&#34;</span> created
</code></pre></td></tr></table>
</div>
</div><p>And the respective role binding. In <code>rolebinding-tiller-myorg-system.yaml</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: tiller-binding
  namespace: myorg-system
subjects:
- kind: ServiceAccount
  name: tiller
  namespace: myorg-system
roleRef:
  kind: Role
  name: tiller-manager
  apiGroup: rbac.authorization.k8s.io
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ kubectl create -f rolebinding-tiller-myorg-system.yaml
rolebinding <span class="s2">&#34;tiller-binding&#34;</span> created
</code></pre></td></tr></table>
</div>
</div><h4 id="helm-and-role-based-access-control">HELM AND ROLE-BASED ACCESS CONTROL</h4>
<p>When running a Helm client in a pod, in order for the Helm client to talk to a Tiller instance, it will need certain privileges to be granted. Specifically, the Helm client will need to be able to create pods, forward ports and be able to list pods in the namespace where Tiller is running (so it can find Tiller).</p>
<h5 id="example-deploy-helm-in-a-namespace-talking-to-tiller-in-another-namespace">Example: Deploy Helm in a namespace, talking to Tiller in another namespace</h5>
<p>In this example, we will assume Tiller is running in a namespace called <code>tiller-world</code> and that the Helm client is running in a namespace called <code>helm-world</code>. By default, Tiller is running in the <code>kube-system</code> namespace.</p>
<p>In <code>helm-user.yaml</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">apiVersion: v1
kind: ServiceAccount
metadata:
  name: helm
  namespace: helm-world
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: tiller-user
  namespace: tiller-world
rules:
- apiGroups:
  - <span class="s2">&#34;&#34;</span>
  resources:
  - pods/portforward
  verbs:
  - create
- apiGroups:
  - <span class="s2">&#34;&#34;</span>
  resources:
  - pods
  verbs:
  - list
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: tiller-user-binding
  namespace: tiller-world
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: tiller-user
subjects:
- kind: ServiceAccount
  name: helm
  namespace: helm-world
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ kubectl create -f helm-user.yaml
serviceaccount <span class="s2">&#34;helm&#34;</span> created
role <span class="s2">&#34;tiller-user&#34;</span> created
rolebinding <span class="s2">&#34;tiller-user-binding&#34;</span> created
</code></pre></td></tr></table>
</div>
</div><h2 id="install-helm">INSTALL HELM</h2>
<p>Download a binary release of the Helm client. You can use tools like <code>homebrew</code>, or look at <a href="https://github.com/helm/helm/releases" target="_blank" rel="noopener noreffer">the official releases page</a>.</p>
<p>For more details, or for other options, see <a href="https://helm.sh/docs/using_helm/#installing-helm" target="_blank" rel="noopener noreffer">the installation guide</a>.</p>
<p>There are two parts to Helm: The Helm client (<code>helm</code>) and the Helm server (<code>Tiller</code>). This guide shows how to install the client, and then proceeds to show two ways to install the server.</p>
<p>IMPORTANT: If you are responsible for ensuring your cluster is a controlled environment, especially when resources are shared, it is strongly recommended installing Tiller using a secured configuration. For guidance, see <a href="https://helm.sh/docs/using_helm/#securing-your-helm-installation" target="_blank" rel="noopener noreffer">Securing your Helm Installation</a>.</p>
<h3 id="installing-the-helm-client">INSTALLING THE HELM CLIENT</h3>
<p>Every <a href="https://github.com/helm/helm/releases" target="_blank" rel="noopener noreffer">release</a> of Helm provides binary releases for a variety of OSes. These binary versions can be manually downloaded and installed.</p>
<ol>
<li>Download your <a href="https://github.com/helm/helm/releases" target="_blank" rel="noopener noreffer">desired version</a></li>
<li>Unpack it (<code>tar -zxvf helm-v2.0.0-linux-amd64.tgz</code>)</li>
<li>Find the <code>helm</code> binary in the unpacked directory, and move it to its desired destination (<code>mv linux-amd64/helm /usr/local/bin/helm</code>)</li>
</ol>
<p>From there, you should be able to run the client: <code>helm help</code>.</p>
<h3 id="installing-tiller">INSTALLING TILLER</h3>
<p>Tiller, the server portion of Helm, typically runs inside of your Kubernetes cluster. But for development, it can also be run locally, and configured to talk to a remote Kubernetes cluster</p>
<p><strong>Special Note for RBAC Users:</strong></p>
<p>Most cloud providers enable a feature called Role-Based Access Control - RBAC for short. If your cloud provider enables this feature, you will need to create a service account for Tiller with the right roles and permissions to access resources.</p>
<p>Check the <a href="https://helm.sh/docs/using_helm/##kubernetes-distribution-guide" target="_blank" rel="noopener noreffer">Kubernetes Distribution Guide</a> to see if there’s any further points of interest on using Helm with your cloud provider. Also check out the guide on <a href="https://helm.sh/docs/using_helm/#role-based-access-control" target="_blank" rel="noopener noreffer">Tiller and Role-Based Access Control</a> for more information on how to run Tiller in an RBAC-enabled Kubernetes cluster.</p>
<h4 id="easy-in-cluster-installation">Easy In-Cluster Installation</h4>
<p>The easiest way to install <code>tiller</code> into the cluster is simply to run <code>helm init</code>. This will validate that <code>helm</code>’s local environment is set up correctly (and set it up if necessary). Then it will connect to whatever cluster <code>kubectl</code> connects to by default (<code>kubectl config view</code>). Once it connects, it will install <code>tiller</code> into the <code>kube-system</code> namespace.</p>
<p>After <code>helm init</code>, you should be able to run <code>kubectl get pods --namespace kube-system</code> and see Tiller running.</p>
<p>You can explicitly tell <code>helm init</code> to…</p>
<ul>
<li>Install the canary(金丝雀) build with the <code>--canary-image</code> flag</li>
<li>Install a particular image (version) with <code>--tiller-image</code></li>
<li>Install to a particular cluster with <code>--kube-context</code></li>
<li>Install into a particular namespace with <code>--tiller-namespace</code></li>
<li>Install Tiller with a Service Account with <code>--service-account</code> (for <a href="https://helm.sh/docs/using_helm/#rbac" target="_blank" rel="noopener noreffer">RBAC enabled clusters</a>)</li>
<li>Install Tiller without mounting a service account with <code>--automount-service-account false</code></li>
</ul>
<p>Once Tiller is installed, running <code>helm version</code> should show you both the client and server version. (If it shows only the client version, <code>helm</code> cannot yet connect to the server. Use <code>kubectl</code> to see if any <code>tiller</code> pods are running.)</p>
<p>Helm will look for Tiller in the <code>kube-system</code> namespace unless <code>--tiller-namespace</code> or <code>TILLER_NAMESPACE</code> is set.</p>
<h4 id="installing-tiller-canary-builds">Installing Tiller Canary Builds</h4>
<p>Canary images are built from the <code>master</code> branch. They may not be stable, but they offer you the chance to test out the latest features.</p>
<p>The easiest way to install a canary image is to use <code>helm init</code> with the <code>--canary-image</code> flag:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">helm init --canary-image
</code></pre></td></tr></table>
</div>
</div><p>This will use the most recently built container image. You can always uninstall Tiller by deleting the Tiller deployment from the <code>kube-system</code> namespace using <code>kubectl</code>.</p>
<h4 id="running-tiller-locally">Running Tiller Locally</h4>
<p>For development, it is sometimes easier to work on Tiller locally, and configure it to connect to a remote Kubernetes cluster.</p>
<p>The process of building Tiller is explained above.</p>
<p>Once <code>tiller</code> has been built, simply start it:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ bin/tiller
Tiller running on :44134
</code></pre></td></tr></table>
</div>
</div><p>When Tiller is running locally, it will attempt to connect to the Kubernetes cluster that is configured by <code>kubectl</code>. (Run <code>kubectl config view</code> to see which cluster that is.)</p>
<p>You must tell <code>helm</code> to connect to this new local Tiller host instead of connecting to the one in-cluster. There are two ways to do this. The first is to specify the <code>--host</code> option on the command line. The second is to set the <code>$HELM_HOST</code> environment variable.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="nb">export</span> <span class="nv">HELM_HOST</span><span class="o">=</span>localhost:44134
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ helm version <span class="c1"># Should connect to localhost.</span>
Client: <span class="p">&amp;</span>version.Version<span class="o">{</span>SemVer:<span class="s2">&#34;v2.0.0-alpha.4&#34;</span>, GitCommit:<span class="s2">&#34;db...&#34;</span>, GitTreeState:<span class="s2">&#34;dirty&#34;</span><span class="o">}</span>
Server: <span class="p">&amp;</span>version.Version<span class="o">{</span>SemVer:<span class="s2">&#34;v2.0.0-alpha.4&#34;</span>, GitCommit:<span class="s2">&#34;a5...&#34;</span>, GitTreeState:<span class="s2">&#34;dirty&#34;</span><span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Importantly, even when running locally, Tiller will store release configuration in ConfigMaps inside of Kubernetes.</p>
<h3 id="upgrading-tiller">UPGRADING TILLER</h3>
<p>As of Helm 2.2.0, Tiller can be upgraded using <code>helm init --upgrade</code>.</p>
<p>For older versions of Helm, or for manual upgrades, you can use <code>kubectl</code> to modify the Tiller image:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="nb">export</span> <span class="nv">TILLER_TAG</span><span class="o">=</span>v2.0.0-beta.1        <span class="c1"># Or whatever version you want</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ kubectl --namespace<span class="o">=</span>kube-system <span class="nb">set</span> image deployments/tiller-deploy <span class="nv">tiller</span><span class="o">=</span>gcr.io/kubernetes-helm/tiller:<span class="nv">$TILLER_TAG</span>
deployment <span class="s2">&#34;tiller-deploy&#34;</span> image updated
</code></pre></td></tr></table>
</div>
</div><p>Setting TILLER_TAG=canary will get the latest snapshot of master.</p>
<h3 id="deleting-or-reinstalling-tiller">DELETING OR REINSTALLING TILLER</h3>
<p>Because Tiller stores its data in Kubernetes ConfigMaps, you can safely delete and re-install Tiller without worrying about losing any data. The recommended way of deleting Tiller is with <code>kubectl delete deployment tiller-deploy --namespace kube-system</code>, or more concisely <code>helm reset</code>.</p>
<p>Tiller can then be re-installed from the client with:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">helm init
</code></pre></td></tr></table>
</div>
</div><h3 id="initialize-helm-and-install-tiller">INITIALIZE HELM AND INSTALL TILLER</h3>
<p>Once you have Helm ready, you can initialize the local CLI and also install Tiller into your Kubernetes cluster in one step:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">helm init --history-max <span class="m">200</span>
</code></pre></td></tr></table>
</div>
</div><p>TIP: Setting <code>--history-max</code> on helm init is recommended as configmaps and other objects in helm history can grow large in number if not purged by max limit. Without a max history set the history is kept indefinitely, leaving a large number of records for helm and tiller to maintain.</p>
<p>This will install Tiller into the Kubernetes cluster you saw with <code>kubectl config current-context</code>.</p>
<p>TIP: Want to install into a different cluster? Use the <code>--kube-context</code> flag.</p>
<p>TIP: When you want to upgrade Tiller, just run <code>helm init --upgrade</code>.</p>
<p>By default, when Tiller is installed, it does not have authentication enabled. To learn more about configuring strong TLS authentication for Tiller, consult <a href="https://helm.sh/docs/using_helm/#using-ssl-between-helm-and-tiller" target="_blank" rel="noopener noreffer">the Tiller TLS guide</a>.</p>
<h4 id="install-an-example-chart">INSTALL AN EXAMPLE CHART</h4>
<p>To install a chart, you can run the <code>helm install</code> command. Helm has several ways to find and install a chart, but the easiest is to use one of the official <code>stable</code> charts.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">helm repo update              <span class="c1"># Make sure we get the latest list of charts</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ helm install stable/mysql
NAME:   wintering-rodent
LAST DEPLOYED: Thu Oct <span class="m">18</span> 14:21:18 <span class="m">2018</span>
NAMESPACE: default
STATUS: DEPLOYED

RESOURCES:
<span class="o">==</span>&gt; v1/Secret
NAME                    AGE
wintering-rodent-mysql  <span class="nv">0s</span>

<span class="o">==</span>&gt; v1/ConfigMap
wintering-rodent-mysql-test  <span class="nv">0s</span>

<span class="o">==</span>&gt; v1/PersistentVolumeClaim
wintering-rodent-mysql  <span class="nv">0s</span>

<span class="o">==</span>&gt; v1/Service
wintering-rodent-mysql  <span class="nv">0s</span>

<span class="o">==</span>&gt; v1beta1/Deployment
wintering-rodent-mysql  <span class="nv">0s</span>

<span class="o">==</span>&gt; v1/Pod<span class="o">(</span>related<span class="o">)</span>

NAME                                    READY  STATUS   RESTARTS  AGE
wintering-rodent-mysql-6986fd6fb-988x7  0/1    Pending  <span class="m">0</span>         0s


NOTES:
MySQL can be accessed via port <span class="m">3306</span> on the following DNS name from within your cluster:
wintering-rodent-mysql.default.svc.cluster.local

To get your root password run:

    <span class="nv">MYSQL_ROOT_PASSWORD</span><span class="o">=</span><span class="k">$(</span>kubectl get secret --namespace default wintering-rodent-mysql -o <span class="nv">jsonpath</span><span class="o">=</span><span class="s2">&#34;{.data.mysql-root-password}&#34;</span> <span class="p">|</span> base64 --decode<span class="p">;</span> <span class="nb">echo</span><span class="k">)</span>

To connect to your database:

1. Run an Ubuntu pod that you can use as a client:

    kubectl run -i --tty ubuntu --image<span class="o">=</span>ubuntu:16.04 --restart<span class="o">=</span>Never -- bash -il

2. Install the mysql client:

    apt-get update <span class="o">&amp;&amp;</span> apt-get install mysql-client -y

3. Connect using the mysql cli, <span class="k">then</span> provide your password:

    mysql -h wintering-rodent-mysql -p

To connect to your database directly from outside the K8s cluster:
    <span class="nv">MYSQL_HOST</span><span class="o">=</span>127.0.0.1
    <span class="nv">MYSQL_PORT</span><span class="o">=</span><span class="m">3306</span>

    <span class="c1"># Execute the following command to route the connection:</span>
    kubectl port-forward svc/wintering-rodent-mysql <span class="m">3306</span>

    mysql -h <span class="si">${</span><span class="nv">MYSQL_HOST</span><span class="si">}</span> -P<span class="si">${</span><span class="nv">MYSQL_PORT</span><span class="si">}</span> -u root -p<span class="si">${</span><span class="nv">MYSQL_ROOT_PASSWORD</span><span class="si">}</span>
</code></pre></td></tr></table>
</div>
</div><p>In the example above, the <code>stable/mysql</code> chart was released, and the name of our new release is <code>wintering-rodent</code>. You get a simple idea of the features of this MySQL chart by running <code>helm inspect stable/mysql</code>.</p>
<p>Whenever you install a chart, a new release is created. So one chart can be installed multiple times into the same cluster. And each can be independently managed and upgraded.</p>
<p>The <code>helm install</code> command is a very powerful command with many capabilities. To learn more about it, check out the <a href="https://helm.sh/docs/using_helm/#using-helm" target="_blank" rel="noopener noreffer">Using Helm Guide</a></p>
<h2 id="using-helm">Using Helm</h2>
<p>This guide explains the basics of using Helm (and Tiller) to manage packages on your Kubernetes cluster. It assumes that you have already <a href="https://helm.sh/docs/using_helm/#installing-helm" target="_blank" rel="noopener noreffer">installed</a> the Helm client and the Tiller server (typically by <code>helm init</code>).</p>
<h3 id="three-big-concepts">THREE BIG CONCEPTS</h3>
<p>A <em><strong>Chart</strong></em> is a Helm package. It contains all of the resource definitions necessary to run an application, tool, or service inside of a Kubernetes cluster. Think of it like the Kubernetes equivalent of a Homebrew formula, an Apt dpkg, or a Yum RPM file.</p>
<p>A <em><strong>Repository</strong></em> is the place where charts can be collected and shared. It’s like <a href="https://www.cpan.org/" target="_blank" rel="noopener noreffer">Perl’s CPAN</a> archive or the <a href="https://apps.fedoraproject.org/packages/s/pkgdb" target="_blank" rel="noopener noreffer">Fedora Package Database</a>, but for Kubernetes packages.</p>
<p>A <em><strong>Release</strong></em> is an instance of a chart running in a Kubernetes cluster. One chart can often be installed many times into the same cluster. And each time it is installed, a new <em><strong>release</strong></em> is created. Consider a MySQL chart. If you want two databases running in your cluster, you can install that chart twice. Each one will have its own <em><strong>release</strong></em>, which will in turn have its own <em><strong>release name</strong></em>.</p>
<p>With these concepts in mind, we can now explain Helm like this:</p>
<p>Helm installs <em><strong>charts</strong></em> into Kubernetes, creating a new <em><strong>release</strong></em> for each installation. And to find new charts, you can search Helm chart <em><strong>repositories</strong></em>.</p>
<h3 id="helm-search-finding-charts">‘HELM SEARCH’: FINDING CHARTS</h3>
<p>When you first install Helm, it is preconfigured to talk to the official Kubernetes charts repository. This repository contains a number of carefully curated and maintained charts. This chart repository is named <code>stable</code> by default.</p>
<p>You can see which charts are available by running <code>helm search</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ helm search
NAME                VERSION     DESCRIPTION
stable/drupal       0.3.2       One of the most versatile open <span class="nb">source</span> content m...
stable/jenkins      0.1.0       A Jenkins Helm chart <span class="k">for</span> Kubernetes.
stable/mariadb      0.5.1       Chart <span class="k">for</span> MariaDB
stable/mysql        0.1.0       Chart <span class="k">for</span> MySQL
...
</code></pre></td></tr></table>
</div>
</div><p>With no filter, <code>helm search</code> shows you all of the available charts. You can narrow down your results by searching with a filter:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ helm search mysql
NAME            VERSION DESCRIPTION
stable/mysql    0.1.0   Chart <span class="k">for</span> MySQL
stable/mariadb  0.5.1   Chart <span class="k">for</span> MariaDB
</code></pre></td></tr></table>
</div>
</div><p>Now you will only see the results that match your filter.</p>
<p>Why is <code>mariadb</code> in the list? Because its package description relates it to MySQL. We can use <code>helm inspect chart</code> to see this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ helm inspect stable/mariadb
Fetched stable/mariadb to mariadb-0.5.1.tgz
description: Chart <span class="k">for</span> MariaDB
engine: gotpl
home: https://mariadb.org
keywords:
  - mariadb
  - mysql
  - database
  - sql
...
</code></pre></td></tr></table>
</div>
</div><p>Search is a good way to find available packages. Once you have found a package you want to install, you can use <code>helm install</code> to install it.</p>
<h3 id="helm-install-installing-a-package">‘HELM INSTALL’: INSTALLING A PACKAGE</h3>
<p>To install a new package, use the <code>helm install</code> command. At its simplest, it takes only one argument: The name of the chart.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ helm install stable/mariadb
Fetched stable/mariadb-0.3.0 to /Users/mattbutcher/Code/Go/src/k8s.io/helm/mariadb-0.3.0.tgz
NAME: happy-panda
LAST DEPLOYED: Wed Sep <span class="m">28</span> 12:32:28 <span class="m">2016</span>
NAMESPACE: default
STATUS: DEPLOYED

Resources:
<span class="o">==</span>&gt; extensions/Deployment
NAME                     DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
happy-panda-mariadb   <span class="m">1</span>         <span class="m">0</span>         <span class="m">0</span>            <span class="m">0</span>           <span class="nv">1s</span>

<span class="o">==</span>&gt; v1/Secret
NAME                     TYPE      DATA      AGE
happy-panda-mariadb   Opaque    <span class="m">2</span>         <span class="nv">1s</span>

<span class="o">==</span>&gt; v1/Service
NAME                     CLUSTER-IP   EXTERNAL-IP   PORT<span class="o">(</span>S<span class="o">)</span>    AGE
happy-panda-mariadb   10.0.0.70    &lt;none&gt;        3306/TCP   1s


Notes:
MariaDB can be accessed via port <span class="m">3306</span> on the following DNS name from within your cluster:
happy-panda-mariadb.default.svc.cluster.local

To connect to your database run the following command:

   kubectl run happy-panda-mariadb-client --rm --tty -i --image bitnami/mariadb --command -- mysql -h happy-panda-mariadb
</code></pre></td></tr></table>
</div>
</div><p>Now the <code>mariadb</code> chart is installed. Note that installing a chart creates a new <em><strong>release</strong></em> object. The release above is named <code>happy-panda</code>. (If you want to use your own release name, simply use the <code>--name</code> flag on <code>helm install</code>.)</p>
<p>During installation, the <code>helm</code> client will print useful information about which resources were created, what the state of the release is, and also whether there are additional configuration steps you can or should take.</p>
<p>Helm does not wait until all of the resources are running before it exits. Many charts require Docker images that are over 600M in size, and may take a long time to install into the cluster.</p>
<p>To keep track of a release’s state, or to re-read configuration information, you can use <code>helm status</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ helm status happy-panda
Last Deployed: Wed Sep <span class="m">28</span> 12:32:28 <span class="m">2016</span>
Namespace: default
Status: DEPLOYED

Resources:
<span class="o">==</span>&gt; v1/Service
NAME                     CLUSTER-IP   EXTERNAL-IP   PORT<span class="o">(</span>S<span class="o">)</span>    AGE
happy-panda-mariadb   10.0.0.70    &lt;none&gt;        3306/TCP   <span class="nv">4m</span>

<span class="o">==</span>&gt; extensions/Deployment
NAME                     DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
happy-panda-mariadb   <span class="m">1</span>         <span class="m">1</span>         <span class="m">1</span>            <span class="m">1</span>           <span class="nv">4m</span>

<span class="o">==</span>&gt; v1/Secret
NAME                     TYPE      DATA      AGE
happy-panda-mariadb   Opaque    <span class="m">2</span>         4m


Notes:
MariaDB can be accessed via port <span class="m">3306</span> on the following DNS name from within your cluster:
happy-panda-mariadb.default.svc.cluster.local

To connect to your database run the following command:

   kubectl run happy-panda-mariadb-client --rm --tty -i --image bitnami/mariadb --command -- mysql -h happy-panda-mariadb
</code></pre></td></tr></table>
</div>
</div><p>The above shows the current state of your release.</p>
<h4 id="customizing-the-chart-before-installing">Customizing the Chart Before Installing</h4>
<p>Installing the way we have here will only use the default configuration options for this chart. Many times, you will want to customize the chart to use your preferred configuration.</p>
<p>To see what options are configurable on a chart, use <code>helm inspect values</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">helm inspect values stable/mariadb
Fetched stable/mariadb-0.3.0.tgz to /Users/mattbutcher/Code/Go/src/k8s.io/helm/mariadb-0.3.0.tgz
<span class="c1">## Bitnami MariaDB image version</span>
<span class="c1">## ref: https://hub.docker.com/r/bitnami/mariadb/tags/</span>
<span class="c1">##</span>
<span class="c1">## Default: none</span>
imageTag: 10.1.14-r3

<span class="c1">## Specify a imagePullPolicy</span>
<span class="c1">## Default to &#39;Always&#39; if imageTag is &#39;latest&#39;, else set to &#39;IfNotPresent&#39;</span>
<span class="c1">## ref: https://kubernetes.io/docs/user-guide/images/#pre-pulling-images</span>
<span class="c1">##</span>
<span class="c1"># imagePullPolicy:</span>

<span class="c1">## Specify password for root user</span>
<span class="c1">## ref: https://github.com/bitnami/bitnami-docker-mariadb/blob/master/README.md#setting-the-root-password-on-first-run</span>
<span class="c1">##</span>
<span class="c1"># mariadbRootPassword:</span>

<span class="c1">## Create a database user</span>
<span class="c1">## ref: https://github.com/bitnami/bitnami-docker-mariadb/blob/master/README.md#creating-a-database-user-on-first-run</span>
<span class="c1">##</span>
<span class="c1"># mariadbUser:</span>
<span class="c1"># mariadbPassword:</span>

<span class="c1">## Create a database</span>
<span class="c1">## ref: https://github.com/bitnami/bitnami-docker-mariadb/blob/master/README.md#creating-a-database-on-first-run</span>
<span class="c1">##</span>
<span class="c1"># mariadbDatabase:</span>
</code></pre></td></tr></table>
</div>
</div><p>You can then override any of these settings in a YAML formatted file, and then pass that file during installation.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ cat <span class="s">&lt;&lt; EOF &gt; config.yaml
</span><span class="s">mariadbUser: user0
</span><span class="s">mariadbDatabase: user0db
</span><span class="s">EOF</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">helm install -f config.yaml stable/mariadb
</code></pre></td></tr></table>
</div>
</div><p>The above will create a default MariaDB user with the name <code>user0</code>, and grant this user access to a newly created <code>user0db</code> database, but will accept all the rest of the defaults for that chart.</p>
<p>There are two ways to pass configuration data during install:</p>
<ul>
<li><code>--values</code> (or <code>-f</code>): Specify a YAML file with overrides. This can be specified multiple times and the rightmost file will take precedence</li>
<li><code>--set</code> (and its variants <code>--set-string</code> and <code>--set-file</code>): Specify overrides on the command line.</li>
</ul>
<p>If both are used, <code>--set</code> values are merged into <code>--values</code> with higher precedence. Overrides specified with <code>--set</code> are persisted in a configmap. Values that have been <code>--set</code> can be viewed for a given release with <code>helm get values &lt;release-name&gt;</code>. Values that have been <code>--set</code> can be cleared by running <code>helm upgrade</code> with <code>--reset-values</code> specified.</p>
<p><strong>The Format and Limitations of <code>--set</code></strong></p>
<p>The <code>--set</code> option takes zero or more name/value pairs. At its simplest, it is used like this: &ndash;set name=value. The YAML equivalent of that is:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">value</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>Multiple values are separated by <code>,</code> characters. So <code>--set a=b,c=d</code> becomes:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">a</span><span class="p">:</span><span class="w"> </span><span class="l">b</span><span class="w">
</span><span class="w"></span><span class="nt">c</span><span class="p">:</span><span class="w"> </span><span class="l">d</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>More complex expressions are supported. For example, <code>--set outer.inner=value</code> is translated into this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">outer:
  inner: value
</code></pre></td></tr></table>
</div>
</div><p>Lists can be expressed by enclosing values in { and }. For example, <code>--set name={a, b, c}</code> translates to:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">name:
  - a
  - b
  - c
</code></pre></td></tr></table>
</div>
</div><p>As of Helm 2.5.0, it is possible to access list items using an array index syntax. For example, &ndash;set servers[0].port=80 becomes:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">servers:
  - port: <span class="m">80</span>
    host: example
</code></pre></td></tr></table>
</div>
</div><p>Sometimes you need to use special characters in your <code>--set</code> lines. You can use a backslash to escape the characters; <code>--set name=&quot;value1\,value2&quot;</code> will become:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">name: <span class="s2">&#34;value1,value2&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>Similarly, you can escape dot sequences as well(类似地，你同样可以使用点来转义序列), which may come in handy when charts use the toYaml function to parse annotations, labels and node selectors. The syntax for <code>--set nodeSelector.&quot;kubernetes\.io/role&quot;=master</code> becomes:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">nodeSelector:
  kubernetes.io/role: master
</code></pre></td></tr></table>
</div>
</div><p>Deeply nested data structures(多层嵌套的数据结构) can be difficult to express using <code>--set</code>. Chart designers are encouraged to consider the <code>--set</code> usage when designing the format of a <code>values.yaml</code> file.</p>
<p>Helm will cast certain values specified with <code>--set</code> to integers. For example, <code>--set foo=true</code> results Helm to cast <code>true</code> into an int64 value. In case you want a string, use a <code>--set</code>’s variant named <code>--set-string</code>. <code>--set-string foo=true</code> results in a string value of <code>&quot;true&quot;</code>.</p>
<p><code>--set-file key=filepath</code> is another variant of <code>--set</code>. It reads the file and use its content as a value. An example use case of it is to inject a multi-line text into values without dealing with indentation(缩进) in YAML. Say you want to create a <a href="https://github.com/Azure/brigade" target="_blank" rel="noopener noreffer">brigade</a> project with certain value containing 5 lines JavaScript code, you might write a <code>values.yaml</code> like:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="nx">defaultScript</span><span class="o">:</span> <span class="o">|</span>
  <span class="kr">const</span> <span class="p">{</span> <span class="nx">events</span><span class="p">,</span> <span class="nx">Job</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">&#34;brigadier&#34;</span><span class="p">)</span>
  <span class="kd">function</span> <span class="nx">run</span><span class="p">(</span><span class="nx">e</span><span class="p">,</span> <span class="nx">project</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;hello default script&#34;</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">events</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s2">&#34;run&#34;</span><span class="p">,</span> <span class="nx">run</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Being embedded in a YAML, this makes it harder for you to use IDE features and testing framework and so on that supports writing code. Instead, you can use &ndash;set-file defaultScript=brigade.js with brigade.js containing:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="kr">const</span> <span class="p">{</span> <span class="nx">events</span><span class="p">,</span> <span class="nx">Job</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">&#34;brigadier&#34;</span><span class="p">)</span>
<span class="kd">function</span> <span class="nx">run</span><span class="p">(</span><span class="nx">e</span><span class="p">,</span> <span class="nx">project</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;hello default script&#34;</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">events</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s2">&#34;run&#34;</span><span class="p">,</span> <span class="nx">run</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="more-installation-methods">More Installation Methods</h4>
<p>The <code>helm install</code> command can install from several sources:</p>
<ul>
<li>A chart repository (as we’ve seen above)</li>
<li>A local chart archive (<code>helm install foo-0.1.1.tgz</code>)</li>
<li>An unpacked chart directory (<code>helm install path/to/foo</code>)</li>
<li>A full URL (<code>helm install https://example.com/charts/foo-1.2.3.tgz</code>)</li>
</ul>
<h3 id="helm-upgrade-and-helm-rollback-upgrading-a-release-and-recovering-on-failure">‘HELM UPGRADE’ AND ‘HELM ROLLBACK’: UPGRADING A RELEASE, AND RECOVERING ON FAILURE</h3>
<p>When a new version of a chart is released, or when you want to change the configuration of your release, you can use the <code>helm upgrade</code> command.</p>
<p>An upgrade takes an existing release and upgrades it according to the information you provide. Because Kubernetes charts can be large and complex, Helm tries to perform the least invasive upgrade. It will only update things that have changed since the last release.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ helm upgrade -f panda.yaml happy-panda stable/mariadb
Fetched stable/mariadb-0.3.0.tgz to /Users/mattbutcher/Code/Go/src/k8s.io/helm/mariadb-0.3.0.tgz
happy-panda has been upgraded.
Last Deployed: Wed Sep <span class="m">28</span> 12:47:54 <span class="m">2016</span>
Namespace: default
Status: DEPLOYED
...
</code></pre></td></tr></table>
</div>
</div><p>In the above case, the <code>happy-panda</code> release is upgraded with the same chart, but with a new YAML file:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">mariadbUser: user1
</code></pre></td></tr></table>
</div>
</div><p>We can use <code>helm get values</code> to see whether that new setting took effect.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ helm get values happy-panda
mariadbUser: user1
</code></pre></td></tr></table>
</div>
</div><p>The <code>helm get</code> command is a useful tool for looking at a release in the cluster. And as we can see above, it shows that our new values from <code>panda.yaml</code> were deployed to the cluster.</p>
<p>Now, if something does not go as planned during a release, it is easy to roll back to a previous release using <code>helm rollback [RELEASE] [REVISION]</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">helm rollback happy-panda <span class="m">1</span>
</code></pre></td></tr></table>
</div>
</div><p>The above rolls back our happy-panda to its very first release version. A release version is an incremental revision. Every time an install, upgrade, or rollback happens, the revision number is incremented by 1. The first revision number is always 1. And we can use <code>helm history [RELEASE]</code> to see revision numbers for a certain release.</p>
<h3 id="helpful-options-for-installupgraderollback">HELPFUL OPTIONS FOR INSTALL/UPGRADE/ROLLBACK</h3>
<p>There are several other helpful options you can specify for customizing the behavior of Helm during an install/upgrade/rollback. Please note that this is not a full list of cli flags. To see a description of all flags, just run <code>helm &lt;command&gt; --help</code>.</p>
<ul>
<li><code>--timeout</code>: A value in seconds to wait for Kubernetes commands to complete This defaults to 300 (5 minutes)</li>
<li><code>--wait</code>: Waits until all Pods are in a ready state, PVCs are bound, Deployments have minimum (<code>Desired</code> minus <code>maxUnavailable</code>) Pods in ready state and Services have an IP address (and Ingress if a <code>LoadBalancer</code>) before marking the release as successful. It will wait for as long as the <code>--timeout</code> value. If timeout is reached, the release will be marked as <code>FAILED</code>. Note: In scenario where Deployment has <code>replicas</code> set to 1 and <code>maxUnavailable</code> is not set to 0 as part of rolling update strategy, <code>--wait</code> will return as ready as it has satisfied the minimum Pod in ready condition.</li>
<li><code>--no-hooks</code>: This skips running hooks for the command</li>
<li><code>--recreate-pods</code> (only available for <code>upgrade</code> and <code>rollback</code>): This flag will cause all pods to be recreated (with the exception of pods belonging to deployments)</li>
</ul>
<h3 id="helm-delete-deleting-a-release">‘HELM DELETE’: DELETING A RELEASE</h3>
<p>When it is time to uninstall or delete a release from the cluster, use the <code>helm delete</code> command:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">helm delete happy-panda
</code></pre></td></tr></table>
</div>
</div><p>使用时加上 <code>--purge</code> 参数，会彻底删除这个 release</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">--purge   remove the release from the store and make its name free <span class="k">for</span> later use
</code></pre></td></tr></table>
</div>
</div><p>This will remove the release from the cluster. You can see all of your currently deployed releases with the helm list command:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ helm list
NAME            VERSION   UPDATED                         STATUS          CHART
inky-cat        <span class="m">1</span>         Wed Sep <span class="m">28</span> 12:59:46 <span class="m">2016</span>        DEPLOYED        alpine-0.1.0
</code></pre></td></tr></table>
</div>
</div><p>From the output above, we can see that the happy-panda release was deleted.</p>
<p>However, Helm always keeps records of what releases happened. Need to see the deleted releases? <code>helm list --deleted</code> shows those, and <code>helm list --all</code> shows all of the releases (deleted and currently deployed, as well as releases that failed):</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$  helm list --all
NAME            VERSION   UPDATED                         STATUS          CHART
happy-panda     <span class="m">2</span>         Wed Sep <span class="m">28</span> 12:47:54 <span class="m">2016</span>        DELETED         mariadb-0.3.0
inky-cat        <span class="m">1</span>         Wed Sep <span class="m">28</span> 12:59:46 <span class="m">2016</span>        DEPLOYED        alpine-0.1.0
kindred-angelf  <span class="m">2</span>         Tue Sep <span class="m">27</span> 16:16:10 <span class="m">2016</span>        DELETED         alpine-0.1.0
</code></pre></td></tr></table>
</div>
</div><p>Because Helm keeps records of deleted releases, a release name cannot be re-used. (If you <em>really</em> need to re-use a release name, you can use the <code>--replace</code> flag, but it will simply re-use the existing release and replace its resources.)</p>
<p>Note that because releases are preserved in this way, you can rollback a deleted resource, and have it re-activate.</p>
<h3 id="helm-repo-working-with-repositories">‘HELM REPO’: WORKING WITH REPOSITORIES</h3>
<p>So far, we’ve been installing charts only from the <code>stable</code> repository. But you can configure <code>helm</code> to use other repositories. Helm provides several repository tools under the <code>helm repo</code> command.</p>
<p>You can see which repositories are configured using <code>helm repo list</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ helm repo list
NAME            URL
stable          https://kubernetes-charts.storage.googleapis.com
<span class="nb">local</span>           http://localhost:8879/charts
mumoshu         https://mumoshu.github.io/charts
</code></pre></td></tr></table>
</div>
</div><p>And new repositories can be added with <code>helm repo add</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">helm repo add dev https://example.com/dev-charts
</code></pre></td></tr></table>
</div>
</div><p>Because chart repositories change frequently, at any point you can make sure your Helm client is up to date by running <code>helm repo update</code>.</p>
<h3 id="creating-your-own-charts">CREATING YOUR OWN CHARTS</h3>
<p>The <a href="https://helm.sh/docs/developing_charts/" target="_blank" rel="noopener noreffer">Chart Development Guide</a> explains how to develop your own charts. But you can get started quickly by using the <code>helm create</code> command:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ helm create deis-workflow
Creating deis-workflow
</code></pre></td></tr></table>
</div>
</div><p>Now there is a chart in <code>./deis-workflow</code>. You can edit it and create your own templates.</p>
<p>As you edit your chart, you can validate that it is well-formatted by running <code>helm lint</code>.</p>
<p>When it’s time to package the chart up for distribution, you can run the <code>helm package</code> command:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ helm package deis-workflow
deis-workflow-0.1.0.tgz
</code></pre></td></tr></table>
</div>
</div><p>And that chart can now easily be installed by <code>helm install</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ helm install ./deis-workflow-0.1.0.tgz
...
</code></pre></td></tr></table>
</div>
</div><p>Charts that are archived can be loaded into chart repositories. See the documentation for your chart repository server to learn how to upload.</p>
<p>Note: The <code>stable</code> repository is managed on the <a href="https://github.com/helm/charts" target="_blank" rel="noopener noreffer">Helm Charts GitHub repository</a>. That project accepts chart source code, and (after audit) packages those for you.</p>
<h3 id="tiller-namespaces-and-rbac">TILLER, NAMESPACES AND RBAC</h3>
<p>In some cases you may wish to scope Tiller or deploy multiple Tillers to a single cluster. Here are some best practices when operating in those circumstances.</p>
<ol>
<li>Tiller can be <a href="https://helm.sh/docs/using_helm/#installing-helm" target="_blank" rel="noopener noreffer">installed</a> into any namespace. By default, it is installed into kube-system. You can run multiple Tillers provided they each run in their own namespace.</li>
<li>Limiting Tiller to only be able to install into specific namespaces and/or resource types is controlled by Kubernetes <a href="https://kubernetes.io/docs/admin/authorization/rbac/" target="_blank" rel="noopener noreffer">RBAC</a> roles and rolebindings. You can add a service account to Tiller when configuring Helm via <code>helm init --service-account &lt;NAME&gt;</code>. You can find more information about that <a href="https://helm.sh/docs/using_helm/#role-based-access-control" target="_blank" rel="noopener noreffer">here</a>.</li>
<li>Release names are unique PER TILLER INSTANCE.</li>
<li>Charts should only contain resources that exist in a single namespace.</li>
<li>It is not recommended to have multiple Tillers configured to manage resources in the same namespace.</li>
</ol>
<h3 id="conclusion">CONCLUSION</h3>
<p>This chapter has covered the <code>basic</code> usage patterns of the helm client, including searching, installation, upgrading, and deleting. It has also covered useful utility commands like <code>helm status</code>, <code>helm get</code>, and <code>helm repo</code>.</p>
<p>For more information on these commands, take a look at Helm’s built-in help: <code>helm help</code>.</p>
<p>In the next chapter, we look at the process of developing charts.</p>
<h2 id="charts">Charts</h2>
<p>Helm uses a packaging format called <em><strong>charts</strong></em>. A chart is a collection of files that describe a related set of Kubernetes resources. A single chart might be used to deploy something simple, like a memcached pod, or something complex, like a full web app stack with HTTP servers, databases, caches, and so on.</p>
<p>Charts are created as files laid out in a particular directory tree, then they can be packaged into versioned archives to be deployed.</p>
<p>This document explains the chart format, and provides basic guidance for building charts with Helm.</p>
<h3 id="the-chart-file-structure">THE CHART FILE STRUCTURE</h3>
<p>A chart is organized as a collection of files inside of a directory. The directory name is the name of the chart (without versioning information). Thus, a chart describing WordPress would be stored in the <code>wordpress/</code> directory.</p>
<p>Inside of this directory, Helm will expect a structure that matches this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">wordpress/
  Chart.yaml          <span class="c1"># A YAML file containing information about the chart</span>
  LICENSE             <span class="c1"># OPTIONAL: A plain text file containing the license for the chart</span>
  README.md           <span class="c1"># OPTIONAL: A human-readable README file</span>
  requirements.yaml   <span class="c1"># OPTIONAL: A YAML file listing dependencies for the chart</span>
  values.yaml         <span class="c1"># The default configuration values for this chart</span>
  charts/             <span class="c1"># A directory containing any charts upon which this chart depends.</span>
  templates/          <span class="c1"># A directory of templates that, when combined with values,</span>
                      <span class="c1"># will generate valid Kubernetes manifest files.</span>
  templates/NOTES.txt <span class="c1"># OPTIONAL: A plain text file containing short usage notes</span>
</code></pre></td></tr></table>
</div>
</div><p>Helm reserves use of the <code>charts/</code> and <code>templates/</code> directories, and of the listed file names. Other files will be left as they are.</p>
<h4 id="the-chartyaml-file">THE CHART.YAML FILE</h4>
<p>The <code>Chart.yaml</code> file is required for a chart. It contains the following fields:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">The chart API version, always &#34;v1&#34; (required)</span><span class="w">
</span><span class="w"></span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">The name of the chart (required)</span><span class="w">
</span><span class="w"></span><span class="nt">version</span><span class="p">:</span><span class="w"> </span><span class="l">A SemVer 2 version (required)</span><span class="w">
</span><span class="w"></span><span class="nt">kubeVersion</span><span class="p">:</span><span class="w"> </span><span class="l">A SemVer range of compatible Kubernetes versions (optional)</span><span class="w">
</span><span class="w"></span><span class="nt">description</span><span class="p">:</span><span class="w"> </span><span class="l">A single-sentence description of this project (optional)</span><span class="w">
</span><span class="w"></span><span class="nt">keywords</span><span class="p">:</span><span class="w">
</span><span class="w">  </span>- <span class="l">A list of keywords about this project (optional)</span><span class="w">
</span><span class="w"></span><span class="nt">home</span><span class="p">:</span><span class="w"> </span><span class="l">The URL of this project&#39;s home page (optional)</span><span class="w">
</span><span class="w"></span><span class="nt">sources</span><span class="p">:</span><span class="w">
</span><span class="w">  </span>- <span class="l">A list of URLs to source code for this project (optional)</span><span class="w">
</span><span class="w"></span><span class="nt">maintainers</span><span class="p">:</span><span class="w"> </span><span class="c"># (optional)</span><span class="w">
</span><span class="w">  </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">The maintainer&#39;s name (required for each maintainer)</span><span class="w">
</span><span class="w">    </span><span class="nt">email</span><span class="p">:</span><span class="w"> </span><span class="l">The maintainer&#39;s email (optional for each maintainer)</span><span class="w">
</span><span class="w">    </span><span class="nt">url</span><span class="p">:</span><span class="w"> </span><span class="l">A URL for the maintainer (optional for each maintainer)</span><span class="w">
</span><span class="w"></span><span class="nt">engine</span><span class="p">:</span><span class="w"> </span><span class="l">gotpl</span><span class="w"> </span><span class="c"># The name of the template engine (optional, defaults to gotpl)</span><span class="w">
</span><span class="w"></span><span class="nt">icon</span><span class="p">:</span><span class="w"> </span><span class="l">A URL to an SVG or PNG image to be used as an icon (optional).</span><span class="w">
</span><span class="w"></span><span class="nt">appVersion</span><span class="p">:</span><span class="w"> </span><span class="l">The version of the app that this contains (optional). This needn&#39;t be SemVer.</span><span class="w">
</span><span class="w"></span><span class="nt">deprecated</span><span class="p">:</span><span class="w"> </span><span class="l">Whether this chart is deprecated (optional, boolean)</span><span class="w">
</span><span class="w"></span><span class="nt">tillerVersion: The version of Tiller that this chart requires. This should be expressed as a SemVer range</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;&gt;2.0.0&#34;</span><span class="w"> </span><span class="l">(optional)</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>If you are familiar with the <code>Chart.yaml</code> file format for Helm Classic, you will notice that fields specifying dependencies have been removed. That is because the new Chart format expresses dependencies using the <code>charts/</code> directory.</p>
<p>Other fields will be silently ignored.</p>
<h5 id="charts-and-versioning">Charts and Versioning</h5>
<p>Every chart must have a version number. A version must follow the <a href="https://semver.org/" target="_blank" rel="noopener noreffer">SemVer 2</a> standard. Unlike Helm Classic, Kubernetes Helm uses version numbers as release markers. Packages in repositories are identified by name plus version.</p>
<p>For example, an <code>nginx</code> chart whose version field is set to <code>version: 1.2.3</code> will be named:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">nginx-1.2.3.tgz
</code></pre></td></tr></table>
</div>
</div><p>More complex SemVer 2 names are also supported, such as <code>version: 1.2.3-alpha.1+ef365</code>. But non-SemVer names are explicitly disallowed by the system.</p>
<p><strong>NOTE</strong>: Whereas Helm Classic and Deployment Manager were both very GitHub oriented when it came to charts, Kubernetes Helm does not rely upon or require GitHub or even Git. Consequently, it does not use Git SHAs for versioning at all.</p>
<p>The <code>version</code> field inside of the <code>Chart.yaml</code> is used by many of the Helm tools, including the CLI and the Tiller server. When generating a package, the <code>helm package</code> command will use the version that it finds in the <code>Chart.yaml</code> as a token in the package name. The system assumes that the version number in the chart package name matches the version number in the <code>Chart.yaml</code>. Failure to meet this assumption will cause an error.</p>
<h5 id="the-appversion-field">The appVersion field</h5>
<p>Note that the <code>appVersion</code> field is not related to the <code>version</code> field. It is a way of specifying the version of the application. For example, the <code>drupal</code> chart may have an <code>appVersion: 8.2.1</code>, indicating that the version of Drupal included in the chart (by default) is <code>8.2.1</code>. This field is informational, and has no impact on chart version calculations.</p>
<h5 id="deprecating-charts">Deprecating Charts</h5>
<p>When managing charts in a Chart Repository, it is sometimes necessary to deprecate a chart. The optional #deprecated# field in #Chart.yaml# can be used to mark a chart as deprecated. If the ##latest## version of a chart in the repository is marked as deprecated, then the chart as a whole is considered to be deprecated. The chart name can later be reused by publishing a newer version that is not marked as deprecated. The workflow for deprecating charts, as followed by the <a href="https://github.com/helm/charts" target="_blank" rel="noopener noreffer">helm/charts</a> project is:</p>
<ul>
<li>Update chart’s Chart.yaml to mark the chart as deprecated, bumping the version</li>
<li>Release the new chart version in the Chart Repository</li>
<li>Remove the chart from the source repository (e.g. git)</li>
</ul>
<h4 id="chart-license-readme-and-notes">CHART LICENSE, README AND NOTES</h4>
<p>Charts can also contain files that describe the installation, configuration, usage and license of a chart.</p>
<p>A <strong>LICENSE</strong> is a plain text file containing the <a href="https://en.wikipedia.org/wiki/Software_license" target="_blank" rel="noopener noreffer">license</a> for the chart. The chart can contain a license as it may have programming logic in the templates and would therefore not be configuration only. There can also be separate license(s) for the application installed by the chart, if required.</p>
<p>A <strong>README</strong> for a chart should be formatted in Markdown (README.md), and should generally contain:</p>
<ul>
<li>A description of the application or service the chart provides</li>
<li>Any prerequisites or requirements to run the chart</li>
<li>Descriptions of options in <code>values.yaml</code> and default values</li>
<li>Any other information that may be relevant to the installation or configuration of the chart</li>
</ul>
<p>The chart can also contain a short plain text <code>templates/NOTES.txt</code> file that will be printed out after installation, and when viewing the status of a release. This file is evaluated as a <a href="https://helm.sh/docs/developing_charts/#templates-and-values" target="_blank" rel="noopener noreffer">template</a>, and can be used to display usage notes, next steps, or any other information relevant to a release of the chart. For example, instructions could be provided for connecting to a database, or accessing a web UI. Since this file is printed to STDOUT when running <code>helm install</code> or <code>helm status</code>, it is recommended to keep the content brief and point to the <strong>README</strong> for greater detail.</p>
<h4 id="chart-dependencies">CHART DEPENDENCIES</h4>
<p>In Helm, one chart may depend on any number of other charts. These dependencies can be dynamically linked through the <code>requirements.yaml</code> file or brought in to the <code>charts/</code> directory and managed manually.</p>
<p>Although manually managing your dependencies has a few advantages some teams need, the preferred method of declaring dependencies is by using a <code>requirements.yaml</code> file inside of your chart.</p>
<p><strong>Note</strong>: The <code>dependencies:</code> section of the <code>Chart.yaml</code> from Helm Classic has been completely removed.</p>
<h5 id="managing-dependencies-with-requirementsyaml">Managing Dependencies with <code>requirements.yaml</code></h5>
<p>A <code>requirements.yaml</code> file is a simple file for listing your dependencies.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">dependencies:
  - name: apache
    version: 1.2.3
    repository: http://example.com/charts
  - name: mysql
    version: 3.2.1
    repository: http://another.example.com/charts
</code></pre></td></tr></table>
</div>
</div><ul>
<li>The <code>name</code> field is the name of the chart you want.</li>
<li>The <code>version</code> field is the version of the chart you want.</li>
<li>The <code>repository</code> field is the full URL to the chart repository. Note that you must also use <code>helm repo add</code> to add that repo locally.</li>
</ul>
<p>Once you have a dependencies file, you can run <code>helm dependency update</code> and it will use your dependency file to download all the specified charts into your <code>charts/</code> directory for you.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ helm dep up foochart
Hang tight <span class="k">while</span> we grab the latest from your chart repositories...
...Successfully got an update from the <span class="s2">&#34;local&#34;</span> chart repository
...Successfully got an update from the <span class="s2">&#34;stable&#34;</span> chart repository
...Successfully got an update from the <span class="s2">&#34;example&#34;</span> chart repository
...Successfully got an update from the <span class="s2">&#34;another&#34;</span> chart repository
Update Complete.
Saving <span class="m">2</span> charts
Downloading apache from repo http://example.com/charts
Downloading mysql from repo http://another.example.com/charts
</code></pre></td></tr></table>
</div>
</div><p>When <code>helm dependency update</code> retrieves charts, it will store them as chart archives in the <code>charts/</code> directory. So for the example above, one would expect to see the following files in the charts directory:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">charts/
  apache-1.2.3.tgz
  mysql-3.2.1.tgz
</code></pre></td></tr></table>
</div>
</div><p>Managing charts with <code>requirements.yaml</code> is a good way to easily keep charts updated, and also share requirements information throughout a team.</p>
<h5 id="alias-field-in-requirementsyaml">Alias field in requirements.yaml</h5>
<p>In addition to the other fields above, each requirements entry may contain the optional field <code>alias</code>.</p>
<p>Adding an alias for a dependency chart would put a chart in dependencies using alias as name of new dependency.</p>
<p>One can use <code>alias</code> in cases where they need to access a chart with other name(s).
如果他们需要访问具有其他名字的 chart ，可以使用 alias 。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># parentchart/requirements.yaml</span>

dependencies:
  - name: subchart
    repository: http://localhost:10191
    version: 0.1.0
    alias: new-subchart-1
  - name: subchart
    repository: http://localhost:10191
    version: 0.1.0
    alias: new-subchart-2
  - name: subchart
    repository: http://localhost:10191
    version: 0.1.0
</code></pre></td></tr></table>
</div>
</div><p>In the above example we will get 3 dependencies in all for <code>parentchart</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">subchart
new-subchart-1
new-subchart-2
</code></pre></td></tr></table>
</div>
</div><p>The manual way of achieving this is by copy/pasting the same chart in the <code>charts/</code> directory multiple times with different names.</p>
<h5 id="tags-and-condition-fields-in-requirementsyaml">Tags and Condition fields in requirements.yaml</h5>
<p>In addition to the other fields above, each requirements entry may contain the optional fields <code>tags</code> and <code>condition</code>.</p>
<p>All charts are loaded by default. If <code>tags</code> or <code>condition</code> fields are present, they will be evaluated(被评估) and used to control loading for the chart(s) they are applied to.</p>
<p><strong>Condition</strong> - The condition field holds one or more YAML paths (delimited by commas (以逗号分隔)). If this path exists in the parent’s values and resolves to a boolean value, the chart will be enabled or disabled based on that boolean value. Only the first valid path found in the list is evaluated and if no paths exist then the condition has no effect. For multiple level dependencies the condition is prependend by the path to the parent chart.</p>
<p><strong>Tags</strong> - The tags field is a YAML list of labels to associate with this chart. In the top parent’s values, all charts with tags can be enabled or disabled by specifying the tag and a boolean value.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># parentchart/requirements.yaml</span>

dependencies:
  - name: subchart1
    repository: http://localhost:10191
    version: 0.1.0
    condition: subchart1.enabled
    tags:
      - front-end
      - subchart1

  - name: subchart2
    repository: http://localhost:10191
    version: 0.1.0
    condition: subchart2.enabled
    tags:
      - back-end
      - subchart2
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># subchart2/requirements.yaml</span>

dependencies:
  - name: subsubchart
    repository: http://localhost:10191
    version: 0.1.0
    condition: subsubchart.enabled
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># parentchart/values.yaml</span>

subchart1:
  enabled: <span class="nb">true</span>
subchart2:
  subsubchart:
    enabled: <span class="nb">false</span>
tags:
  front-end: <span class="nb">false</span>
  back-end: <span class="nb">true</span>
</code></pre></td></tr></table>
</div>
</div><p>In the above example all charts with the tag <code>front-end</code> would be disabled but since the <code>subchart1.enabled</code> path evaluates to ‘true’ in the parent’s values, the condition will override the <code>front-end</code> tag and <code>subchart1</code> will be enabled.</p>
<p>Since <code>subchart2</code> is tagged with <code>back-end</code> and that tag evaluates to <code>true</code>, <code>subchart2</code> will be enabled. Also note that although <code>subchart2</code> has a condition specified in <code>requirements.yaml</code>, there is no corresponding path and value in the parent’s values so that condition has no effect.</p>
<p><code>subsubchart</code> is disabled by default but can be enabled by setting <code>subchart2.subsubchart.enabled=true</code>. Hint: disabling <code>subchart2</code> via tag will also disable all sub-charts (even if overriding the value <code>subchart2.subsubchart.enabled=true</code>).</p>
<p><strong>Using the CLI with Tags and Conditions:</strong></p>
<p>The <code>--set</code> parameter can be used as usual to alter tag and condition values.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">helm install --set tags.front-end<span class="o">=</span><span class="nb">true</span> --set subchart2.enabled<span class="o">=</span><span class="nb">false</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>Tags and Condition Resolution:</strong></p>
<ul>
<li>Conditions (when set in values) always override tags.</li>
<li>The first condition path that exists wins and subsequent ones for that chart are ignored.</li>
<li>Tags are evaluated as ‘if any of the chart’s tags are true then enable the chart’.</li>
<li>Tags and conditions values must be set in the top parent’s values.</li>
<li>The <code>tags:</code> key in values must be a top level key. Globals and nested <code>tags:</code> tables are not currently supported.</li>
</ul>
<h5 id="importing-child-values-via-requirementsyaml">Importing Child Values via requirements.yaml</h5>
<p>In some cases it is desirable to allow a child chart’s values to propagate(传播) to the parent chart and be shared as common defaults. An additional benefit of using the <code>exports</code> format is that it will enable future tooling to introspect user-settable values.</p>
<p>The keys containing the values to be imported can be specified in the parent chart’s <code>requirements.yaml</code> file using a YAML list. Each item in the list is a key which is imported from the child chart’s <code>exports</code> field.</p>
<p>To import values not contained in the <code>exports</code> key, use the <a href="https://helm.sh/docs/developing_charts/#using-the-child-parent-format" target="_blank" rel="noopener noreffer">child-parent</a> format. Examples of both formats are described below.</p>
<h6 id="using-the-exports-format">Using the exports format</h6>
<p>If a child chart’s <code>values.yaml</code> file contains an <code>exports</code> field at the root, its contents may be imported directly into the parent’s values by specifying the keys to import as in the example below:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># parent&#39;s requirements.yaml file</span>

    ...
    import-values:
      - data
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># child&#39;s values.yaml file</span>

...
exports:
  data:
    myint: <span class="m">99</span>
</code></pre></td></tr></table>
</div>
</div><p>Since we are specifying the key <code>data</code> in our import list, Helm looks in the <code>exports</code> field of the child chart for <code>data</code> key and imports its contents.</p>
<p>The final parent values would contain our exported field:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># parent&#39;s values file</span>

...
myint: <span class="m">99</span>
</code></pre></td></tr></table>
</div>
</div><p>Please note the parent key <code>data</code> is not contained in the parent’s final values. If you need to specify the parent key, use the <code>‘child-parent’ format</code>.</p>
<h6 id="using-the-child-parent-format">Using the child-parent format</h6>
<p>To access values that are not contained in the <code>exports</code> key of the child chart’s values, you will need to specify the source key of the values to be imported (<code>child</code>) and the destination path in the parent chart’s values (<code>parent</code>).</p>
<p>The <code>import-values</code> in the example below instructs Helm to take any values found at <code>child:</code> path and copy them to the parent’s values at the path specified in <code>parent</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># parent&#39;s requirements.yaml file</span>

dependencies:
  - name: subchart1
    repository: http://localhost:10191
    version: 0.1.0
    ...
    import-values:
      - child: default.data
        parent: myimports
</code></pre></td></tr></table>
</div>
</div><p>In the above example, values found at <code>default.data</code> in the subchart1’s values will be imported to the <code>myimports</code> key in the parent chart’s values as detailed below:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># parent&#39;s values.yaml file</span>

myimports:
  myint: <span class="m">0</span>
  mybool: <span class="nb">false</span>
  mystring: <span class="s2">&#34;helm rocks!&#34;</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># subchart1&#39;s values.yaml file</span>

default:
  data:
    myint: <span class="m">999</span>
    mybool: <span class="nb">true</span>
</code></pre></td></tr></table>
</div>
</div><p>The parent chart’s resulting values would be:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># parent&#39;s final values</span>

myimports:
  myint: <span class="m">999</span>
  mybool: <span class="nb">true</span>
  mystring: <span class="s2">&#34;helm rocks!&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>The parent’s final values now contains the <code>myint</code> and <code>mybool</code> fields imported from subchart1.</p>
<h5 id="managing-dependencies-manually-via-the-charts-directory">Managing Dependencies manually via the <code>charts/</code> directory</h5>
<p>If more control over dependencies is desired, these dependencies can be expressed explicitly by copying the dependency charts into the <code>charts/</code> directory.</p>
<p>A dependency can be either a chart archive (<code>foo-1.2.3.tgz</code>) or an unpacked chart directory. But its name cannot start with <code>_</code> or <code>.</code>. Such files are ignored by the chart loader.</p>
<p>For example, if the WordPress chart depends on the Apache chart, the Apache chart (of the correct version) is supplied in the WordPress chart’s <code>charts/</code> directory:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">wordpress:
  Chart.yaml
  requirements.yaml
  <span class="c1"># ...</span>
  charts/
    apache/
      Chart.yaml
      <span class="c1"># ...</span>
    mysql/
      Chart.yaml
      <span class="c1"># ...</span>
</code></pre></td></tr></table>
</div>
</div><p>The example above shows how the WordPress chart expresses its dependency on Apache and MySQL by including those charts inside of its <code>charts/</code> directory.</p>
<p><strong>TIP</strong>: To drop a dependency into your <code>charts/</code> directory, use the <code>helm fetch</code> command</p>
<h5 id="operational-aspects-of-using-dependencies">Operational aspects of using dependencies</h5>
<p>The above sections explain how to specify chart dependencies, but how does this affect chart installation using <code>helm install</code> and <code>helm upgrade</code>?</p>
<p>Suppose that a chart named “A” creates the following Kubernetes objects</p>
<ul>
<li>namespace “A-Namespace”</li>
<li>statefulset “A-StatefulSet”</li>
<li>service “A-Service”</li>
</ul>
<p>Furthermore, A is dependent on chart B that creates objects</p>
<ul>
<li>namespace “B-Namespace”</li>
<li>replicaset “B-ReplicaSet”</li>
<li>service “B-Service”</li>
</ul>
<p>After installation/upgrade of chart A, a single Helm release is created/modified. The release will create/update all of the above Kubernetes objects in the following order:</p>
<ul>
<li>A-Namespace</li>
<li>B-Namespace</li>
<li>A-StatefulSet</li>
<li>B-ReplicaSet</li>
<li>A-Service</li>
<li>B-Service</li>
</ul>
<p>This is because when Helm installs/upgrades charts, the Kubernetes objects from the charts and all its dependencies are</p>
<ul>
<li>aggregated into a single set; then</li>
<li>sorted by type followed by name; and then</li>
<li>created/updated in that order.</li>
</ul>
<p>Hence(因此) a single release is created with all the objects for the chart and its dependencies.</p>
<p>The install order of Kubernetes types is given by the enumeration(列举) InstallOrder in kind_sorter.go (see <a href="https://github.com/helm/helm/blob/master/pkg/tiller/kind_sorter.go#L26" target="_blank" rel="noopener noreffer">the Helm source file</a>).</p>
<h4 id="templates-and-values">TEMPLATES AND VALUES</h4>
<p>Helm Chart templates are written in the <a href="https://golang.org/pkg/text/template/" target="_blank" rel="noopener noreffer">Go template language</a>, with the addition of 50 or so add-on template functions <a href="https://github.com/Masterminds/sprig" target="_blank" rel="noopener noreffer">from the Sprig library</a> and a few other <a href="https://helm.sh/docs/developing_charts/#chart-development-tips-and-tricks" target="_blank" rel="noopener noreffer">specialized functions</a>.</p>
<p>All template files are stored in a chart’s <code>templates/</code> folder. When Helm renders(渲染) the charts, it will pass every file in that directory through the template engine.</p>
<p>Values for the templates are supplied two ways:</p>
<ul>
<li>Chart developers may supply a file called <code>values.yaml</code> inside of a chart. This file can contain default values.</li>
<li>Chart users may supply a YAML file that contains values. This can be provided on the command line with <code>helm install</code>.</li>
</ul>
<p>When a user supplies custom values, these values will override the values in the chart’s <code>values.yaml</code> file.</p>
<h5 id="template-files">Template Files</h5>
<p>Template files follow the standard conventions for writing Go templates (see the <a href="https://golang.org/pkg/text/template/" target="_blank" rel="noopener noreffer">text/template Go package documentation</a> for details). An example template file might look something like this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">apiVersion: v1
kind: ReplicationController
metadata:
  name: deis-database
  namespace: deis
  labels:
    app.kubernetes.io/managed-by: deis
spec:
  replicas: <span class="m">1</span>
  selector:
    app.kubernetes.io/name: deis-database
  template:
    metadata:
      labels:
        app.kubernetes.io/name: deis-database
    spec:
      serviceAccount: deis-database
      containers:
        - name: deis-database
          image: <span class="o">{{</span>.Values.imageRegistry<span class="o">}}</span>/postgres:<span class="o">{{</span>.Values.dockerTag<span class="o">}}</span>
          imagePullPolicy: <span class="o">{{</span>.Values.pullPolicy<span class="o">}}</span>
          ports:
            - containerPort: <span class="m">5432</span>
          env:
            - name: DATABASE_STORAGE
              value: <span class="o">{{</span>default <span class="s2">&#34;minio&#34;</span> .Values.storage<span class="o">}}</span>
</code></pre></td></tr></table>
</div>
</div><p>The above example, based loosely on <a href="https://github.com/deis/charts">https://github.com/deis/charts</a>, is a template for a Kubernetes replication controller. It can use the following four template values (usually defined in a <code>values.yaml</code> file):</p>
<ul>
<li><code>imageRegistry</code>: The source registry for the Docker image.</li>
<li><code>dockerTag</code>: The tag for the docker image.</li>
<li><code>pullPolicy</code>: The Kubernetes pull policy.</li>
<li><code>storage</code>: The storage backend, whose default is set to <code>&quot;minio&quot;</code></li>
</ul>
<p>All of these values are defined by the template author. Helm does not require or dictate parameters.</p>
<p>To see many working charts, check out the <a href="https://github.com/helm/charts" target="_blank" rel="noopener noreffer">Helm Charts project</a></p>
<h6 id="predefined-values">Predefined Values</h6>
<p>Values that are supplied via a <code>values.yaml</code> file (or via the <code>--set</code> flag) are accessible from the <code>.Values</code> object in a template. But there are other pre-defined pieces of data you can access in your templates.</p>
<p>The following values are pre-defined, are available to every template, and cannot be overridden. As with all values, the names are <em><strong>case sensitive</strong></em>.</p>
<ul>
<li><code>Release.Name</code>: The name of the release (not the chart)</li>
<li><code>Release.Time</code>: The time the chart release was last updated. This will match the <code>Last Released</code> time on a Release object.</li>
<li><code>Release.Namespace</code>: The namespace the chart was released to.</li>
<li><code>Release.Service</code>: The service that conducted the release. Usually this is <code>Tiller</code>.</li>
<li><code>Release.IsUpgrade</code>: This is set to true if the current operation is an upgrade or rollback.</li>
<li><code>Release.IsInstall</code>: This is set to true if the current operation is an install.</li>
<li><code>Release.Revision</code>: The revision number. It begins at 1, and increments with each <code>helm upgrade</code>.</li>
<li><code>Chart</code>: The contents of the <code>Chart.yaml</code>. Thus, the chart version is obtainable as <code>Chart.Version</code> and the maintainers are in <code>Chart.Maintainers</code>.</li>
<li><code>Files</code>: A map-like object containing all non-special files in the chart. This will not give you access to templates, but will give you access to additional files that are present (unless they are excluded using <code>.helmignore</code>). Files can be accessed using <code>{{index .Files &quot;file.name&quot;}}</code> or using the <code>{{.Files.Get name}}</code> or <code>{{.Files.GetString name}}</code> functions. You can also access the contents of the file as <code>[]byte</code> using <code>{{.Files.GetBytes}}</code></li>
<li><code>Capabilities</code>: A map-like object that contains information about the versions of Kubernetes (<code>{{.Capabilities.KubeVersion}}</code>, Tiller (<code>{{.Capabilities.TillerVersion}}</code>, and the supported Kubernetes API versions (<code>{{.Capabilities.APIVersions.Has &quot;batch/v1&quot;</code>)</li>
</ul>
<p><strong>NOTE</strong>: Any unknown Chart.yaml fields will be dropped. They will not be accessible inside of the Chart object. Thus, Chart.yaml cannot be used to pass arbitrarily structured data(自定义结构的数据) into the template. The values file can be used for that, though.</p>
<h5 id="values-files">Values files</h5>
<p>Considering the template in the previous section, a <code>values.yaml</code> file that supplies the necessary values would look like this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">imageRegistry: <span class="s2">&#34;quay.io/deis&#34;</span>
dockerTag: <span class="s2">&#34;latest&#34;</span>
pullPolicy: <span class="s2">&#34;Always&#34;</span>
storage: <span class="s2">&#34;s3&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>A values file is formatted in YAML. A chart may include a default <code>values.yaml</code> file. The Helm install command allows a user to override values by supplying additional YAML values:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">helm install --values<span class="o">=</span>myvals.yaml wordpress
</code></pre></td></tr></table>
</div>
</div><p>When values are passed in this way, they will be merged into the default values file. For example, consider a <code>myvals.yaml</code> file that looks like this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">storage: <span class="s2">&#34;gcs&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>When this is merged with the <code>values.yaml</code> in the chart, the resulting generated content will be:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">imageRegistry: <span class="s2">&#34;quay.io/deis&#34;</span>
dockerTag: <span class="s2">&#34;latest&#34;</span>
pullPolicy: <span class="s2">&#34;Always&#34;</span>
storage: <span class="s2">&#34;gcs&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>Note that only the last field was overridden.</p>
<p><strong>NOTE</strong>: The default values file included inside of a chart must be named <code>values.yaml</code>. But files specified on the command line can be named anything.</p>
<p><strong>NOTE</strong>: If the <code>--set</code> flag is used on <code>helm install</code> or <code>helm upgrade</code>, those values are simply converted to YAML on the client side.</p>
<p><strong>NOTE</strong>: If any required entries in the values file exist, they can be declared as required in the chart template by using the <a href="https://helm.sh/docs/developing_charts/#chart-development-tips-and-tricks" target="_blank" rel="noopener noreffer">‘required’ function</a></p>
<p>Any of these values are then accessible inside of templates using the <code>.Values</code> object:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">apiVersion: v1
kind: ReplicationController
metadata:
  name: deis-database
  namespace: deis
  labels:
    app.kubernetes.io/managed-by: deis
spec:
  replicas: <span class="m">1</span>
  selector:
    app.kubernetes.io/name: deis-database
  template:
    metadata:
      labels:
        app.kubernetes.io/name: deis-database
    spec:
      serviceAccount: deis-database
      containers:
        - name: deis-database
          image: <span class="o">{{</span>.Values.imageRegistry<span class="o">}}</span>/postgres:<span class="o">{{</span>.Values.dockerTag<span class="o">}}</span>
          imagePullPolicy: <span class="o">{{</span>.Values.pullPolicy<span class="o">}}</span>
          ports:
            - containerPort: <span class="m">5432</span>
          env:
            - name: DATABASE_STORAGE
              value: <span class="o">{{</span>default <span class="s2">&#34;minio&#34;</span> .Values.storage<span class="o">}}</span>
</code></pre></td></tr></table>
</div>
</div><h6 id="scope-dependencies-and-values">Scope, Dependencies, and Values</h6>
<p>Values files can declare values for the top-level chart, as well as for any of the charts that are included in that chart’s <code>charts/</code> directory. Or, to phrase it differently, a values file can supply values to the chart as well as to any of its dependencies. For example, the demonstration WordPress chart above has both <code>mysql</code> and <code>apache</code> as dependencies. The values file could supply values to all of these components:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">title: <span class="s2">&#34;My WordPress Site&#34;</span> <span class="c1"># Sent to the WordPress template</span>

mysql:
  max_connections: <span class="m">100</span> <span class="c1"># Sent to MySQL</span>
  password: <span class="s2">&#34;secret&#34;</span>

apache:
  port: <span class="m">8080</span> <span class="c1"># Passed to Apache</span>
</code></pre></td></tr></table>
</div>
</div><p>Charts at a higher level have access to all of the variables defined beneath(下面). So the WordPress chart can access the MySQL password as <code>.Values.mysql.password</code>. But lower level charts cannot access things in parent charts, so MySQL will not be able to access the <code>title</code> property. Nor, for that matter, can it access <code>apache.port</code> (同样，它也不能访问<code>apache.port</code>。).</p>
<p>Values are namespaced, but namespaces are pruned(修剪的). So for the WordPress chart, it can access the MySQL password field as <code>.Values.mysql.password</code>. But for the MySQL chart, the scope of the values has been reduced and the namespace prefix removed, so it will see the password field simply as <code>.Values.password</code>.</p>
<p><strong>Global Values:</strong></p>
<p>As of 2.0.0-Alpha.2, Helm supports special “global” value. Consider this modified version of the previous example:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">title: <span class="s2">&#34;My WordPress Site&#34;</span> <span class="c1"># Sent to the WordPress template</span>

global:
  app: MyWordPress

mysql:
  max_connections: <span class="m">100</span> <span class="c1"># Sent to MySQL</span>
  password: <span class="s2">&#34;secret&#34;</span>

apache:
  port: <span class="m">8080</span> <span class="c1"># Passed to Apache</span>
</code></pre></td></tr></table>
</div>
</div><p>The above adds a <code>global</code> section with the value <code>app: MyWordPress</code>. This value is available to all charts as <code>.Values.global.app</code>.</p>
<p>For example, the <code>mysql</code> templates may access app as <code>{{.Values.global.app}}</code>, and so can the <code>apache</code> chart. Effectively, the values file above is regenerated like this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">title: <span class="s2">&#34;My WordPress Site&#34;</span> <span class="c1"># Sent to the WordPress template</span>

global:
  app: MyWordPress

mysql:
  global:
    app: MyWordPress
  max_connections: <span class="m">100</span> <span class="c1"># Sent to MySQL</span>
  password: <span class="s2">&#34;secret&#34;</span>

apache:
  global:
    app: MyWordPress
  port: <span class="m">8080</span> <span class="c1"># Passed to Apache</span>
</code></pre></td></tr></table>
</div>
</div><p>This provides a way of sharing one top-level variable with all subcharts, which is useful for things like setting <code>metadata</code> properties like labels.</p>
<p>If a subchart declares a global variable, that global will be passed <em><strong>downward</strong></em> (to the subchart’s subcharts), but not <em><strong>upward</strong></em> to the parent chart. There is no way for a subchart to influence the values of the parent chart.</p>
<p>Also, global variables of parent charts take precedence over(优先于) the global variables from subcharts.</p>
<h6 id="references">References</h6>
<p>When it comes to writing templates and values files, there are several standard references that will help you out.</p>
<ul>
<li><a href="https://godoc.org/text/template" target="_blank" rel="noopener noreffer">Go templates</a></li>
<li><a href="https://godoc.org/github.com/Masterminds/sprig" target="_blank" rel="noopener noreffer">Extra template functions</a></li>
<li><a href="https://yaml.org/spec/" target="_blank" rel="noopener noreffer">The YAML format</a></li>
</ul>
<h3 id="using-helm-to-manage-charts">USING HELM TO MANAGE CHARTS</h3>
<p>The <code>helm</code> tool has several commands for working with charts.</p>
<p>It can create a new chart for you:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ helm create mychart
Created mychart/
</code></pre></td></tr></table>
</div>
</div><p>Once you have edited a chart, <code>helm</code> can package it into a chart archive for you:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ helm package mychart
Archived mychart-0.1.-.tgz
</code></pre></td></tr></table>
</div>
</div><p>You can also use helm to help you find issues with your chart’s formatting or information:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ helm lint mychart
No issues found
</code></pre></td></tr></table>
</div>
</div><h3 id="chart-repositories">CHART REPOSITORIES</h3>
<p>A <em><strong>chart repository</strong></em> is an HTTP server that houses one or more packaged charts. While <code>helm</code> can be used to manage local chart directories, when it comes to sharing charts, the preferred mechanism is a chart repository.</p>
<p>Any HTTP server that can serve YAML files and tar files and can answer GET requests can be used as a repository server.</p>
<p>Helm comes with built-in package server for developer testing (<code>helm serve</code>). The Helm team has tested other servers, including Google Cloud Storage with website mode enabled, and S3 with website mode enabled.</p>
<p>A repository is characterized primarily(主要特征) by the presence(存在) of a special file called <code>index.yaml</code> that has a list of all of the packages supplied by the repository, together with metadata that allows retrieving and verifying those packages.</p>
<p>On the client side, repositories are managed with the <code>helm repo</code> commands. However, Helm does not provide tools for uploading charts to remote repository servers. This is because doing so would add substantial requirements(额外的要求) to an implementing server, and thus raise the <code>barrier</code>(障碍) for setting up a repository.</p>
<h3 id="chart-starter-packs">CHART STARTER PACKS</h3>
<p>The <code>helm create</code> command takes an optional &ndash;starter option that lets you specify a “starter chart”.</p>
<p>Starters are just regular charts, but are located in <code>$HELM_HOME/starters</code>. As a chart developer, you may author charts that are specifically designed to be used as starters. Such charts should be designed with the following considerations in mind:</p>
<ul>
<li>The <code>Chart.yaml</code> will be overwritten by the generator.</li>
<li>Users will expect to modify such a chart’s contents, so documentation should indicate how users can do so.</li>
<li>All occurrences of <code>&lt;CHARTNAME&gt;</code> in files within the templates directory will be replaced with the specified chart name so that starter charts can be used as templates. Additionally, occurrences of <code>&lt;CHARTNAME&gt;</code> in values.yaml will also be replaced.</li>
</ul>
<p>Currently the only way to add a chart to <code>$HELM_HOME/starters</code> is to manually copy it there. In your chart’s documentation, you may want to explain that process.</p>
<h2 id="hooks">Hooks</h2>
<p>Helm provides a hook mechanism to allow chart developers to intervene(干预) at certain points in a release’s life cycle. For example, you can use hooks to:</p>
<ul>
<li>Load a ConfigMap or Secret during install before any other charts are loaded.</li>
<li>Execute a Job to back up a database before installing a new chart, and then execute a second job after the upgrade in order to restore data.</li>
<li>Run a Job before deleting a release to gracefully take a service out of rotation before removing it.</li>
</ul>
<p>Hooks work like regular templates, but they have special annotations that cause Helm to utilize(利用) them differently. In this section, we cover the basic usage pattern for hooks.</p>
<p>Hooks are declared as an annotation in the metadata section of a manifest:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">apiVersion: ...
kind: ....
metadata:
  annotations:
    <span class="s2">&#34;helm.sh/hook&#34;</span>: <span class="s2">&#34;pre-install&#34;</span>
<span class="c1"># ...</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="the-available-hooks">THE AVAILABLE HOOKS</h3>
<p>The following hooks are defined:</p>
<ul>
<li>pre-install: Executes after templates are rendered, but before any resources are created in Kubernetes.</li>
<li>post-install: Executes after all resources are loaded into Kubernetes</li>
<li>pre-delete: Executes on a deletion request before any resources are deleted from Kubernetes.</li>
<li>post-delete: Executes on a deletion request after all of the release’s resources have been deleted.</li>
<li>pre-upgrade: Executes on an upgrade request after templates are rendered, but before any resources are loaded into Kubernetes (e.g. before a Kubernetes apply operation).</li>
<li>post-upgrade: Executes on an upgrade after all resources have been upgraded.</li>
<li>pre-rollback: Executes on a rollback request after templates are rendered, but before any resources have been rolled back.</li>
<li>post-rollback: Executes on a rollback request after all resources have been modified.</li>
<li>crd-install: Adds CRD resources before any other checks are run. This is used only on CRD definitions that are used by other manifests in the chart.</li>
<li>test-success: Executes when running <code>helm test</code> and expects the pod to return successfully (return code == 0).</li>
<li>test-failure: Executes when running <code>helm test</code> and expects the pod to fail (return code != 0).</li>
</ul>
<h3 id="hooks-and-the-release-lifecycle">HOOKS AND THE RELEASE LIFECYCLE</h3>
<p>Hooks allow you, the chart developer, an opportunity to perform operations at strategic points in a release lifecycle. For example, consider the lifecycle for a <code>helm install</code>. By default, the lifecycle looks like this:</p>
<ol>
<li>User runs <code>helm install foo</code></li>
<li>Chart is loaded into Tiller</li>
<li>After some verification, Tiller renders(渲染) the <code>foo</code> templates</li>
<li>Tiller loads the resulting resources into Kubernetes</li>
<li>Tiller returns the release name (and other data) to the client</li>
<li>The client exits</li>
</ol>
<p>Helm defines two hooks for the <code>install</code> lifecycle: <code>pre-install</code> and <code>post-install</code>. If the developer of the <code>foo</code> chart implements both hooks, the lifecycle is altered like this:</p>
<ol>
<li>User runs <code>helm install foo</code></li>
<li>Chart is loaded into Tiller</li>
<li>After some verification, Tiller renders the <code>foo</code> templates</li>
<li>Tiller prepares to execute the <code>pre-install</code> hooks (loading hook resources into Kubernetes)</li>
<li>Tiller sorts hooks by weight (assigning a weight of 0 by default) and by name for those hooks with the same weight in ascending order.</li>
<li>Tiller then loads the hook with the lowest weight first (negative to positive)</li>
<li>Tiller waits until the hook is “Ready” (except for CRDs)</li>
<li>Tiller loads the resulting resources into Kubernetes. Note that if the <code>--wait</code> flag is set, Tiller will wait until all resources are in a ready state and will not run the <code>post-install</code> hook until they are ready.</li>
<li>Tiller executes the post-install hook (loading hook resources)</li>
<li>Tiller waits until the hook is “Ready”</li>
<li>Tiller returns the release name (and other data) to the client</li>
<li>The client exits</li>
</ol>
<p>What does it mean to wait until a hook is ready? This depends on the resource declared in the hook. If the resources is a <code>Job</code> kind, Tiller will wait until the job successfully runs to completion. And if the job fails, the release will fail. This is a blocking operation, so the Helm client will pause while the Job is run.</p>
<p>For all other kinds, as soon as Kubernetes marks the resource as loaded (added or updated), the resource is considered “Ready”. When many resources are declared in a hook, the resources are executed serially(连续地). If they have hook weights (see below), they are executed in weighted order. Otherwise, ordering is not guaranteed. (In Helm 2.3.0 and after, they are sorted alphabetically(按字母顺序). That behavior, though, is not considered binding and could change in the future.) It is considered good practice to add a hook weight, and set it to 0 if weight is not important.</p>
<h4 id="hook-resources-are-not-managed-with-corresponding-releases">Hook resources are not managed with corresponding releases</h4>
<p>The resources that a hook creates are not tracked or managed as part of the release. Once Tiller verifies that the hook has reached its ready state, it will leave the hook resource alone.</p>
<p>Practically speaking, this means that if you create resources in a hook, you cannot rely upon <code>helm delete</code> to remove the resources. To destroy such resources, you need to either write code to perform this operation in a <code>pre-delete</code> or <code>post-delete</code> hook or add <code>&quot;helm.sh/hook-delete-policy&quot;</code> annotation to the hook template file.</p>
<h3 id="writing-a-hook">WRITING A HOOK</h3>
<p>Hooks are just Kubernetes manifest files with special annotations in the <code>metadata</code> section. Because they are template files, you can use all of the normal template features, including reading <code>.Values</code>, <code>.Release</code>, and <code>.Template</code>.</p>
<p>For example, this template, stored in <code>templates/post-install-job.yaml</code>, declares a job to be run on <code>post-install</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">apiVersion: batch/v1
kind: Job
metadata:
  name: <span class="s2">&#34;{{.Release.Name}}&#34;</span>
  labels:
    app.kubernetes.io/managed-by: <span class="o">{{</span>.Release.Service <span class="p">|</span> quote <span class="o">}}</span>
    app.kubernetes.io/instance: <span class="o">{{</span>.Release.Name <span class="p">|</span> quote <span class="o">}}</span>
    app.kubernetes.io/version: <span class="o">{{</span> .Chart.AppVersion <span class="o">}}</span>
    helm.sh/chart: <span class="s2">&#34;{{.Chart.Name}}-{{.Chart.Version}}&#34;</span>
  annotations:
    <span class="c1"># This is what defines this resource as a hook. Without this line, the</span>
    <span class="c1"># job is considered part of the release.</span>
    <span class="s2">&#34;helm.sh/hook&#34;</span>: post-install
    <span class="s2">&#34;helm.sh/hook-weight&#34;</span>: <span class="s2">&#34;-5&#34;</span>
    <span class="s2">&#34;helm.sh/hook-delete-policy&#34;</span>: hook-succeeded
spec:
  template:
    metadata:
      name: <span class="s2">&#34;{{.Release.Name}}&#34;</span>
      labels:
        app.kubernetes.io/managed-by: <span class="o">{{</span>.Release.Service <span class="p">|</span> quote <span class="o">}}</span>
        app.kubernetes.io/instance: <span class="o">{{</span>.Release.Name <span class="p">|</span> quote <span class="o">}}</span>
        helm.sh/chart: <span class="s2">&#34;{{.Chart.Name}}-{{.Chart.Version}}&#34;</span>
    spec:
      restartPolicy: Never
      containers:
      - name: post-install-job
        image: <span class="s2">&#34;alpine:3.3&#34;</span>
        command: <span class="o">[</span><span class="s2">&#34;/bin/sleep&#34;</span>,<span class="s2">&#34;{{default &#34;</span>10<span class="s2">&#34; .Values.sleepyTime}}&#34;</span><span class="o">]</span>
</code></pre></td></tr></table>
</div>
</div><p>What makes this template a hook is the annotation:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">  annotations:
    <span class="s2">&#34;helm.sh/hook&#34;</span>: post-install
</code></pre></td></tr></table>
</div>
</div><p>One resource can implement multiple hooks:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">  annotations:
    <span class="s2">&#34;helm.sh/hook&#34;</span>: post-install,post-upgrade
</code></pre></td></tr></table>
</div>
</div><p>Similarly, there is no limit to the number of different resources that may implement a given hook. For example, one could declare both a secret and a config map as a pre-install hook.</p>
<p>When subcharts declare hooks, those are also evaluated. There is no way for a top-level chart to disable the hooks declared by subcharts.</p>
<p>It is possible to define a weight for a hook which will help build a deterministic(确定性的) executing order. Weights are defined using the following annotation:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">  annotations:
    <span class="s2">&#34;helm.sh/hook-weight&#34;</span>: <span class="s2">&#34;5&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>Hook weights can be positive or negative numbers but must be represented as strings. When Tiller starts the execution cycle of hooks of a particular kind (ex. the <code>pre-install</code> hooks or <code>post-install</code> hooks, etc.) it will sort those hooks in ascending(上升的) order.</p>
<p>It is also possible to define policies that determine when to delete corresponding hook resources. Hook deletion policies are defined using the following annotation:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">  annotations:
    <span class="s2">&#34;helm.sh/hook-delete-policy&#34;</span>: hook-succeeded
</code></pre></td></tr></table>
</div>
</div><p>You can choose one or more defined annotation values:</p>
<ul>
<li><code>&quot;hook-succeeded&quot;</code> specifies Tiller should delete the hook after the hook is successfully executed.</li>
<li><code>&quot;hook-failed&quot;</code> specifies Tiller should delete the hook if the hook failed during execution.</li>
<li><code>&quot;before-hook-creation&quot;</code> specifies Tiller should delete the previous hook before the new hook is launched.</li>
</ul>
<p>By default Tiller will wait for 60 seconds for a deleted hook to no longer exist in the API server before timing out. This behavior can be changed using the <code>helm.sh/hook-delete-timeout</code> annotation. The value is the number of seconds Tiller should wait for the hook to be fully deleted. A value of 0 means Tiller does not wait at all.</p>
<h4 id="defining-a-crd-with-the-crd-install-hook">Defining a CRD with the <code>crd-install</code> Hook</h4>
<p>Custom Resource Definitions (CRDs) are a special kind in Kubernetes. They provide a way to define other kinds.</p>
<p>On occasion, a chart needs to both define a kind and then use it. This is done with the <code>crd-install</code> hook.</p>
<p>The <code>crd-install</code> hook is executed very early during an installation, before the rest of the manifests are verified. CRDs can be annotated with this hook so that they are installed before any instances of that CRD are referenced. In this way, when verification happens later, the CRDs will be available.</p>
<p>Here is an example of defining a CRD with a hook, and an instance of the CRD:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">apiVersion: apiextensions.k8s.io/v1beta1
kind: CustomResourceDefinition
metadata:
  name: crontabs.stable.example.com
  annotations:
    <span class="s2">&#34;helm.sh/hook&#34;</span>: crd-install
spec:
  group: stable.example.com
  version: v1
  scope: Namespaced
  names:
    plural: crontabs
    singular: crontab
    kind: CronTab
    shortNames:
    - ct
</code></pre></td></tr></table>
</div>
</div><p>And:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">apiVersion: stable.example.com/v1
kind: CronTab
metadata:
  name: <span class="o">{{</span> .Release.Name <span class="o">}}</span>-inst
</code></pre></td></tr></table>
</div>
</div><p>Both of these can now be in the same chart, provided that the CRD is correctly annotated.</p>
<h4 id="automatically-delete-hook-from-previous-release">Automatically delete hook from previous release</h4>
<p>When a helm release, that uses a hook, is being updated, it is possible that the hook resource might already exist in the cluster. In such circumstances, by default, helm will fail trying to install the hook resource with an <code>&quot;... already exists&quot;</code> error.</p>
<p>A common reason why the hook resource might already exist is that it was not deleted following use on a previous install/upgrade. There are, in fact, good reasons why one might want to keep the hook: for example, to aid manual debugging in case something went wrong. In this case, the recommended way of ensuring subsequent attempts to create the hook do not fail is to define a &ldquo;<code>hook-delete-policy</code>&rdquo; that can handle this: <code>&quot;helm.sh/hook-delete-policy&quot;: &quot;before-hook-creation&quot;</code>. This hook annotation causes any existing hook to be removed, before the new hook is installed.</p>
<p>If it is preferred to actually delete the hook after each use (rather than have to handle it on a subsequent use, as shown above), then this can be achieved using a delete policy of <code>&quot;helm.sh/hook-delete-policy&quot;: &quot;hook-succeeded,hook-failed&quot;</code>.</p>
<h3 id="chart-development-tips-and-tricks">Chart Development Tips and Tricks</h3>
<p>This guide covers some of the tips and tricks Helm chart developers have learned while building production-quality charts.</p>
<h4 id="know-your-template-functions">KNOW YOUR TEMPLATE FUNCTIONS</h4>
<p>Helm uses <a href="https://godoc.org/text/template" target="_blank" rel="noopener noreffer">Go templates</a> for templating your resource files. While Go ships several built-in functions, we have added many others.</p>
<p>First, we added almost all of the functions in the <a href="https://godoc.org/github.com/Masterminds/sprig" target="_blank" rel="noopener noreffer">Sprig library</a>. We removed two for security reasons: <code>env</code> and <code>expandenv</code> (which would have given chart authors access to Tiller’s environment).</p>
<p>We also added two special template functions: <code>include</code> and <code>required</code>. The <code>include</code> function allows you to bring in another template, and then pass the results to other template functions.</p>
<p>For example, this template snippet(片段) includes a template called <code>mytpl</code>, then lowercases the result, then wraps that in double quotes(双引号).</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">value: <span class="o">{{</span> include <span class="s2">&#34;mytpl&#34;</span> . <span class="p">|</span> lower <span class="p">|</span> quote <span class="o">}}</span>
</code></pre></td></tr></table>
</div>
</div><p>The <code>required</code> function allows you to declare a particular values entry as required for template rendering. If the value is empty, the template rendering will fail with a user submitted error message.</p>
<p>The following example of the <code>required</code> function declares an entry for .Values.who is required, and will print an error message when that entry is missing:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">value: <span class="o">{{</span> required <span class="s2">&#34;A valid .Values.who entry required!&#34;</span> .Values.who <span class="o">}}</span>
</code></pre></td></tr></table>
</div>
</div><p>When using the <code>include</code> function, you can pass it a custom object tree built from the current context by using the <code>dict</code> function:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">{{</span>- include <span class="s2">&#34;mytpl&#34;</span> <span class="o">(</span>dict <span class="s2">&#34;key1&#34;</span> .Values.originalKey1 <span class="s2">&#34;key2&#34;</span> .Values.originalKey2<span class="o">)</span> <span class="o">}}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="quote-strings-dont-quote-integers">QUOTE STRINGS, DON’T QUOTE INTEGERS</h4>
<p>When you are working with string data, you are always safer quoting the strings than leaving them as bare words:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">name: <span class="o">{{</span> .Values.MyName <span class="p">|</span> quote <span class="o">}}</span>
</code></pre></td></tr></table>
</div>
</div><p>But when working with integers do not quote the values. That can, in many cases, cause parsing errors inside of Kubernetes.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">port: <span class="o">{{</span> .Values.Port <span class="o">}}</span>
</code></pre></td></tr></table>
</div>
</div><p>This remark does not apply to env variables values which are expected to be string, even if they represent integers:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">env:
  -name: HOST
    value: <span class="s2">&#34;http://host&#34;</span>
  -name: PORT
    value: <span class="s2">&#34;1234&#34;</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="using-the-include-function">USING THE ‘INCLUDE’ FUNCTION</h4>
<p>Go provides a way of including one template in another using a built-in <code>template</code> directive. However, the built-in function cannot be used in Go template pipelines.</p>
<p>To make it possible to include a template, and then perform an operation on that template’s output, Helm has a special <code>include</code> function:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">{{</span>- include <span class="s2">&#34;toYaml&#34;</span> <span class="nv">$value</span> <span class="p">|</span> nindent <span class="m">2</span> <span class="o">}}</span>
</code></pre></td></tr></table>
</div>
</div><p>The above includes a template called <code>toYaml</code>, passes it <code>$value</code>, and then passes the output of that template to the <code>nindent</code> function. Using the <code>{{- ... | nindent _n_ }}</code> pattern makes it easier to read the <code>include</code> in context, because it chomps the whitespace to the left (including the previous newline), then the <code>nindent</code> re-adds the newline and indents the included content by the requested amount.</p>
<p>Because YAML ascribes significance to indentation levels and whitespace(因为YAML将重要性归因于缩进级别和空白), this is one great way to include snippets of code, but handle indentation in a relevant context.</p>
<h4 id="using-the-required-function">USING THE ‘REQUIRED’ FUNCTION</h4>
<p>Go provides a way for setting template options to control behavior when a map is indexed with a key that’s not present in the map. This is typically set with <code>template.Options(“missingkey=option”)</code>, where option can be <code>default</code>, <code>zero</code>, or <code>error</code>. While setting this option to <code>error</code> will stop execution with an error, this would apply to every missing key in the map. There may be situations where a chart developer wants to enforce this behavior for select values in the values.yml file.</p>
<p>The <code>required</code> function gives developers the ability to declare a value entry as required for template rendering. If the entry is empty in values.yml, the template will not render and will return an error message supplied by the developer.</p>
<p>For example:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">{{</span> required <span class="s2">&#34;A valid foo is required!&#34;</span> .Values.foo <span class="o">}}</span>
</code></pre></td></tr></table>
</div>
</div><p>The above will render the template when .Values.foo is defined, but will fail to render and exit when .Values.foo is undefined.</p>
<h4 id="using-the-tpl-function">USING THE ‘TPL’ FUNCTION</h4>
<p>The <code>tpl</code> function allows developers to evaluate strings as templates inside a template(tpm 功能允许开发者来测试将字符串作为模板传递给template). This is useful to pass a template string as a value to a chart or render external configuration files. Syntax: <code>{{ tpl TEMPLATE_STRING VALUES }}</code></p>
<p>Examples:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># values</span>
template: <span class="s2">&#34;{{ .Values.name }}&#34;</span>
name: <span class="s2">&#34;Tom&#34;</span>

<span class="c1"># template</span>
<span class="o">{{</span> tpl .Values.template . <span class="o">}}</span>

<span class="c1"># output</span>
Tom
</code></pre></td></tr></table>
</div>
</div><p>Rendering a external configuration file:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># external configuration file conf/app.conf</span>
<span class="nv">firstName</span><span class="o">={{</span> .Values.firstName <span class="o">}}</span>
<span class="nv">lastName</span><span class="o">={{</span> .Values.lastName <span class="o">}}</span>

<span class="c1"># values</span>
firstName: Peter
lastName: Parker

<span class="c1"># template</span>
<span class="o">{{</span> tpl <span class="o">(</span>.Files.Get <span class="s2">&#34;conf/app.conf&#34;</span><span class="o">)</span> . <span class="o">}}</span>

<span class="c1"># output</span>
<span class="nv">firstName</span><span class="o">=</span>Peter
<span class="nv">lastName</span><span class="o">=</span>Parker
</code></pre></td></tr></table>
</div>
</div><h4 id="creating-image-pull-secrets">CREATING IMAGE PULL SECRETS</h4>
<p>Image pull secrets are essentially(实质上) a combination of <em><strong>registry</strong></em>, <em><strong>username</strong></em>, and <em><strong>password</strong></em>. You may need them in an application you are deploying, but to create them requires running <em><strong>base64</strong></em> a couple of times. We can write a helper template to compose the Docker configuration file for use as the Secret’s payload(有效载荷). Here is an example:</p>
<p>First, assume that the credentials are defined in the <code>values.yaml</code> file like so:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">imageCredentials:
  registry: quay.io
  username: someone
  password: sillyness
</code></pre></td></tr></table>
</div>
</div><p>We then define our helper template as follows:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">{{</span>- define <span class="s2">&#34;imagePullSecret&#34;</span> <span class="o">}}</span>
<span class="o">{{</span>- <span class="nb">printf</span> <span class="s2">&#34;{\&#34;auths\&#34;: {\&#34;%s\&#34;: {\&#34;auth\&#34;: \&#34;%s\&#34;}}}&#34;</span> .Values.imageCredentials.registry <span class="o">(</span><span class="nb">printf</span> <span class="s2">&#34;%s:%s&#34;</span> .Values.imageCredentials.username .Values.imageCredentials.password <span class="p">|</span> b64enc<span class="o">)</span> <span class="p">|</span> b64enc <span class="o">}}</span>
<span class="o">{{</span>- end <span class="o">}}</span>
</code></pre></td></tr></table>
</div>
</div><p>Finally, we use the helper template in a larger template to create the Secret manifest:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">apiVersion: v1
kind: Secret
metadata:
  name: myregistrykey
type: kubernetes.io/dockerconfigjson
data:
  .dockerconfigjson: <span class="o">{{</span> template <span class="s2">&#34;imagePullSecret&#34;</span> . <span class="o">}}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="automatically-roll-deployments-when-configmaps-or-secrets-change">AUTOMATICALLY ROLL DEPLOYMENTS WHEN CONFIGMAPS OR SECRETS CHANGE</h4>
<p>Often times configmaps or secrets are injected as configuration files in containers. Depending on the application a restart may be required should those be updated with a subsequent <code>helm upgrade</code>, but if the deployment spec itself didn’t change the application keeps running with the old configuration resulting in an inconsistent deployment.</p>
<p>The <code>sha256sum</code> function can be used to ensure a deployment’s annotation section is updated if another file changes:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">kind: Deployment
spec:
  template:
    metadata:
      annotations:
        checksum/config: <span class="o">{{</span> include <span class="o">(</span>print $.Template.BasePath <span class="s2">&#34;/configmap.yaml&#34;</span><span class="o">)</span> . <span class="p">|</span> sha256sum <span class="o">}}</span>
<span class="o">[</span>...<span class="o">]</span>
</code></pre></td></tr></table>
</div>
</div><p>See also the <code>helm upgrade --recreate-pods</code> flag for a slightly different way of addressing this issue.</p>
<h4 id="tell-tiller-not-to-delete-a-resource">TELL TILLER NOT TO DELETE A RESOURCE</h4>
<p>Sometimes there are resources that should not be deleted when Helm runs a <code>helm delete</code>. Chart developers can add an annotation to a resource to prevent it from being deleted.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">kind: Secret
metadata:
  annotations:
    <span class="s2">&#34;helm.sh/resource-policy&#34;</span>: keep
<span class="o">[</span>...<span class="o">]</span>
</code></pre></td></tr></table>
</div>
</div><p>(Quotation marks are required)</p>
<p>The annotation <code>&quot;helm.sh/resource-policy&quot;: keep</code> instructs Tiller to skip this resource during a <code>helm delete</code> operation. However, this resource becomes orphaned(孤儿). Helm will no longer manage it in any way. This can lead to problems if using <code>helm install --replace</code> on a release that has already been deleted, but has kept resources.</p>
<p>To explicitly(明确的) opt in to resource deletion, for example when overriding a chart’s default annotations, set the resource policy annotation value to <code>delete</code>.</p>
<h4 id="using-partials-and-template-includes">USING “PARTIALS” AND TEMPLATE INCLUDES</h4>
<p>Sometimes you want to create some reusable parts in your chart, whether they’re blocks or template partials(部分). And often, it’s cleaner to keep these in their own files.</p>
<p>In the <code>templates/</code> directory, any file that begins with an underscore(<code>_</code>) is not expected to output a Kubernetes manifest file. So by convention, helper templates and partials are placed in a <code>_helpers.tpl</code> file.</p>
<h4 id="complex-charts-with-many-dependencies">COMPLEX CHARTS WITH MANY DEPENDENCIES</h4>
<p>Many of the charts in the <a href="https://github.com/helm/charts" target="_blank" rel="noopener noreffer">official charts repository</a> are “building blocks” for creating more advanced applications. But charts may be used to create instances of large-scale applications. In such cases, a single umbrella chart may have multiple subcharts, each of which functions as a piece of the whole.</p>
<p>The current best practice for composing a complex application from discrete parts is to create a top-level umbrella chart that exposes the global configurations, and then use the <code>charts/</code> subdirectory to embed each of the components.</p>
<p>Two strong design patterns are illustrated by these projects:</p>
<p>SAP’s <a href="https://github.com/sapcc/helm-charts" target="_blank" rel="noopener noreffer">Converged charts</a>: These charts install SAP Converged Cloud a full OpenStack IaaS on Kubernetes. All of the charts are collected together in one GitHub repository, except for a few submodules.</p>
<p>Deis’s <a href="https://github.com/deis/workflow/tree/master/charts/workflow" target="_blank" rel="noopener noreffer">Workflow</a>: This chart exposes the entire Deis PaaS system with one chart. But it’s different from the SAP chart in that this umbrella chart is built from each component, and each component is tracked in a different Git repository. Check out the <code>requirements.yaml</code> file to see how this chart is composed by their CI/CD pipeline.</p>
<p>Both of these charts illustrate proven techniques for standing up complex environments using Helm.</p>
<h4 id="yaml-is-a-superset-of-json">YAML IS A SUPERSET OF JSON</h4>
<p>According to the YAML specification, YAML is a superset of JSON. That means that any valid JSON structure ought to be valid in YAML.</p>
<p>This has an advantage: Sometimes template developers may find it easier to express a data structure with a JSON-like syntax rather than deal with YAML’s whitespace sensitivity.</p>
<p>As a best practice, templates should follow a YAML-like syntax unless the JSON syntax substantially reduces the risk of a formatting issue.</p>
<h4 id="be-careful-with-generating-random-values">BE CAREFUL WITH GENERATING RANDOM VALUES</h4>
<p>There are functions in Helm that allow you to generate random data, cryptographic keys, and so on. These are fine to use. But be aware that during upgrades, templates are re-executed. When a template run generates data that differs from the last run, that will trigger an update of that resource.</p>
<h4 id="upgrade-a-release-idempotently">UPGRADE A RELEASE IDEMPOTENTLY</h4>
<p>In order to use the same command when installing and upgrading a release, use the following command:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">helm upgrade --install &lt;release name&gt; --values &lt;values file&gt; &lt;chart directory&gt;
</code></pre></td></tr></table>
</div>
</div><p>类似于 <code>kubectl apply</code>，一个命令既可以新建又可以更新。</p>
<h2 id="the-chart-repository-guide">The Chart Repository Guide</h2>
<p>This section explains how to create and work with Helm chart repositories. At a high level, a chart repository is a location where packaged charts can be stored and shared.</p>
<p>The official chart repository is maintained by the <a href="https://github.com/helm/charts" target="_blank" rel="noopener noreffer">Helm Charts</a>, and we welcome participation. But Helm also makes it easy to create and run your own chart repository. This guide explains how to do so.</p>
<h3 id="prerequisites">PREREQUISITES</h3>
<ul>
<li>Go through the <a href="https://helm.sh/docs/developing_charts/#quickstart" target="_blank" rel="noopener noreffer">Quickstart</a> Guide</li>
<li>Read through the <a href="https://helm.sh/docs/developing_charts/#charts" target="_blank" rel="noopener noreffer">Charts</a> document</li>
</ul>
<h3 id="create-a-chart-repository">CREATE A CHART REPOSITORY</h3>
<p>A <strong>chart repository</strong> is an HTTP server that houses an index.yaml file and optionally some packaged charts. When you’re ready to share your charts, the preferred way to do so is by uploading them to a chart repository.</p>
<p><strong>Note</strong>: For Helm 2.0.0, chart repositories do not have any intrinsic(固有) authentication(认证方式). There is an <a href="https://github.com/helm/helm/issues/1038" target="_blank" rel="noopener noreffer">issue tracking progress</a> in GitHub.</p>
<p>Because a chart repository can be any HTTP server that can serve YAML and tar files and can answer GET requests, you have a plethora(过多) of options when it comes down to hosting your own chart repository. For example, you can use a Google Cloud Storage (GCS) bucket(桶), Amazon S3 bucket, Github Pages, or even create your own web server.</p>
<h4 id="the-chart-repository-structure">The chart repository structure</h4>
<p>A chart repository consists of packaged charts and a special file called <code>index.yaml</code> which contains an index of all of the charts in the repository. Frequently(通常地), the charts that <code>index.yaml</code> describes are also hosted on the same server, as are the <a href="https://helm.sh/docs/developing_charts/#helm-provenance-and-integrity" target="_blank" rel="noopener noreffer">provenance files(源文件)</a>.</p>
<p>For example, the layout of the repository <code>https://example.com/charts</code> might look like this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">charts/
  <span class="p">|</span>
  <span class="p">|</span>- index.yaml
  <span class="p">|</span>
  <span class="p">|</span>- alpine-0.1.2.tgz
  <span class="p">|</span>
  <span class="p">|</span>- alpine-0.1.2.tgz.prov
</code></pre></td></tr></table>
</div>
</div><p>In this case, the index file would contain information about one chart, the Alpine chart, and provide the download URL <code>https://example.com/charts/alpine-0.1.2.tgz</code> for that chart.</p>
<p>It is not required that a chart package be located on the same server as the <code>index.yaml</code> file. However, doing so is often the easiest.</p>
<h4 id="the-index-file">The index file</h4>
<p>The index file is a yaml file called <code>index.yaml</code>. It contains some metadata about the package, including the contents of a chart’s <code>Chart.yaml</code> file. A valid chart repository must have an index file. The index file contains information about each chart in the chart repository. The <code>helm repo index</code> command will generate an index file based on a given local directory that contains packaged charts.</p>
<p>This is an example of an index file:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">apiVersion: v1
entries:
  alpine:
    - created: 2016-10-06T16:23:20.499814565-06:00
      description: Deploy a basic Alpine Linux pod
      digest: 99c76e403d752c84ead610644d4b1c2f2b453a74b921f422b9dcb8a7c8b559cd
      home: https://k8s.io/helm
      name: alpine
      sources:
      - https://github.com/helm/helm
      urls:
      - https://technosophos.github.io/tscharts/alpine-0.2.0.tgz
      version: 0.2.0
    - created: 2016-10-06T16:23:20.499543808-06:00
      description: Deploy a basic Alpine Linux pod
      digest: 515c58e5f79d8b2913a10cb400ebb6fa9c77fe813287afbacf1a0b897cd78727
      home: https://k8s.io/helm
      name: alpine
      sources:
      - https://github.com/helm/helm
      urls:
      - https://technosophos.github.io/tscharts/alpine-0.1.0.tgz
      version: 0.1.0
  nginx:
    - created: 2016-10-06T16:23:20.499543808-06:00
      description: Create a basic nginx HTTP server
      digest: aaff4545f79d8b2913a10cb400ebb6fa9c77fe813287afbacf1a0b897cdffffff
      home: https://k8s.io/helm
      name: nginx
      sources:
      - https://github.com/helm/charts
      urls:
      - https://technosophos.github.io/tscharts/nginx-1.1.0.tgz
      version: 1.1.0
generated: 2016-10-06T16:23:20.499029981-06:00
</code></pre></td></tr></table>
</div>
</div><p>A generated index and packages can be served from a basic webserver. You can test things out locally with the <code>helm serve</code> command, which starts a local server.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ helm serve --repo-path ./charts
Regenerating index. This may take a moment.
Now serving you on 127.0.0.1:8879
</code></pre></td></tr></table>
</div>
</div><p>The above starts a local webserver, serving the charts it finds in <code>./charts</code>. The serve command will automatically generate an <code>index.yaml</code> file for you during startup.</p>
<h3 id="hosting-chart-repositories">HOSTING CHART REPOSITORIES</h3>
<p>This part shows several ways to serve a chart repository.</p>
<h4 id="chartmuseum">ChartMuseum</h4>
<p>The Helm project provides an open-source Helm repository server called <a href="https://chartmuseum.com/" target="_blank" rel="noopener noreffer">ChartMuseum</a> that you can host yourself.</p>
<p>ChartMuseum supports multiple cloud storage backends. Configure it to point to the directory or bucket containing your chart packages, and the index.yaml file will be generated dynamically.</p>
<p>It can be deployed easily as a <a href="https://github.com/helm/charts/tree/master/stable/chartmuseum" target="_blank" rel="noopener noreffer">Helm chart</a>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">helm install stable/chartmuseum
</code></pre></td></tr></table>
</div>
</div><p>and also as a <a href="https://hub.docker.com/r/chartmuseum/chartmuseum/tags" target="_blank" rel="noopener noreffer">Docker image</a>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">docker run --rm -it <span class="se">\
</span><span class="se"></span>  -p 8080:8080 <span class="se">\
</span><span class="se"></span>  -v <span class="k">$(</span><span class="nb">pwd</span><span class="k">)</span>/charts:/charts <span class="se">\
</span><span class="se"></span>  -e <span class="nv">DEBUG</span><span class="o">=</span><span class="nb">true</span> <span class="se">\
</span><span class="se"></span>  -e <span class="nv">STORAGE</span><span class="o">=</span><span class="nb">local</span> <span class="se">\
</span><span class="se"></span>  -e <span class="nv">STORAGE_LOCAL_ROOTDIR</span><span class="o">=</span>/charts <span class="se">\
</span><span class="se"></span>  chartmuseum/chartmuseum
</code></pre></td></tr></table>
</div>
</div><p>You can then add the repo to your local repository list:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">helm repo add chartmuseum http://localhost:8080
</code></pre></td></tr></table>
</div>
</div><p>ChartMuseum provides other features, such as an API for chart uploads. Please see the <a href="https://github.com/helm/chartmuseum" target="_blank" rel="noopener noreffer">README</a> for more info.</p>
<h4 id="github-pages-example">Github Pages example</h4>
<p>In a similar way you can create charts repository using GitHub Pages.</p>
<p>GitHub allows you to serve static web pages in two different ways:</p>
<ul>
<li>By configuring a project to serve the contents of its <code>docs/</code> directory</li>
<li>By configuring a project to serve a particular branch</li>
</ul>
<p>We’ll take the second approach, though the first is just as easy.</p>
<p>The first step will be to <strong>create your gh-pages branch</strong>. You can do that locally as.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">git checkout -b gh-pages
</code></pre></td></tr></table>
</div>
</div><p>Or via web browser using <strong>Branch</strong> button on your Github repository:</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/images/create-a-gh-page-button-20191014.png"
        data-srcset="/images/create-a-gh-page-button-20191014.png, /images/create-a-gh-page-button-20191014.png 1.5x, /images/create-a-gh-page-button-20191014.png 2x"
        data-sizes="auto"
        alt="/images/create-a-gh-page-button-20191014.png"
        title="image" /></p>
<p>Next, you’ll want to make sure your <strong>gh-pages branch</strong> is set as Github Pages, click on your repo <strong>Settings</strong> and scroll down to <strong>Github pages</strong> section and set as per below:</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/images/set-a-gh-page-20191014.png"
        data-srcset="/images/set-a-gh-page-20191014.png, /images/set-a-gh-page-20191014.png 1.5x, /images/set-a-gh-page-20191014.png 2x"
        data-sizes="auto"
        alt="/images/set-a-gh-page-20191014.png"
        title="image" /></p>
<p>By default <strong>Source</strong> usually gets set to <strong>gh-pages branch</strong>. If this is not set by default, then select it.</p>
<p>You can use a <strong>custom domain</strong> there if you wish so.</p>
<p>And check that <strong>Enforce HTTPS</strong> is ticked, so the <strong>HTTPS</strong> will be used when charts are served.</p>
<p>In such setup you can use <strong>master branch</strong> to store your charts code, and <strong>gh-pages branch</strong> as charts repository, e.g.: <code>https://USERNAME.github.io/REPONAME</code>. The demonstration(示范) <a href="https://github.com/technosophos/tscharts" target="_blank" rel="noopener noreffer">TS Charts</a> repository is accessible at <code>https://technosophos.github.io/tscharts/</code>.</p>
<h4 id="ordinary普通的-web-servers">Ordinary(普通的) web servers</h4>
<p>To configure an ordinary web server to serve Helm charts, you merely need to do the following:</p>
<ul>
<li>Put your index and charts in a directory that the server can serve</li>
<li>Make sure the <code>index.yaml</code> file can be accessed with no authentication requirement</li>
<li>Make sure <code>yaml</code> files are served with the correct content type (<code>text/yaml</code> or <code>text/x-yaml</code>)</li>
</ul>
<p>For example, if you want to serve your charts out of <code>$WEBROOT/charts</code>, make sure there is a <code>charts/</code> directory in your web root, and put the index file and charts inside of that folder.</p>
<h3 id="managing-chart-repositories">MANAGING CHART REPOSITORIES</h3>
<p>Now that you have a chart repository, the last part of this guide explains how to maintain charts in that repository.</p>
<h4 id="store-charts-in-your-chart-repository">Store charts in your chart repository</h4>
<p>Now that you have a chart repository, let’s upload a chart and an index file to the repository. Charts in a chart repository must be packaged (<code>helm package chart-name/</code>) and versioned correctly (following <a href="https://semver.org/" target="_blank" rel="noopener noreffer">SemVer 2</a> guidelines).</p>
<p>These next steps compose an example workflow, but you are welcome to use whatever workflow you fancy for storing and updating charts in your chart repository.</p>
<p>Once you have a packaged chart ready, create a new directory, and move your packaged chart to that directory.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">helm package docs/examples/alpine/
mkdir fantastic-charts
mv alpine-0.1.0.tgz fantastic-charts/
helm repo index fantastic-charts --url https://fantastic-charts.storage.googleapis.com
</code></pre></td></tr></table>
</div>
</div><p>The last command takes the path of the local directory that you just created and the URL of your remote chart repository and composes an <code>index.yaml</code> file inside the given directory path.</p>
<p>Now you can upload the chart and the index file to your chart repository using a sync tool or manually. If you’re using Google Cloud Storage, check out this <a href="https://helm.sh/docs/developing_charts/#developing_charts_sync_example" target="_blank" rel="noopener noreffer">example workflow</a> using the gsutil client. For GitHub, you can simply put the charts in the appropriate destination branch.</p>
<h4 id="add-new-charts-to-an-existing-repository">Add new charts to an existing repository</h4>
<p>Each time you want to add a new chart to your repository, you must regenerate the index. The <code>helm repo index</code> command will completely rebuild the <code>index.yaml</code> file from scratch, including only the charts that it finds locally.</p>
<p>However, you can use the <code>--merge</code> flag to incrementally add new charts to an existing <code>index.yaml</code> file (a great option when working with a remote repository like GCS). Run <code>helm repo index --help</code> to learn more,</p>
<p>Make sure that you upload both the revised <code>index.yaml</code> file and the chart. And if you generated a provenance file, upload that too.</p>
<h4 id="share-your-charts-with-others">Share your charts with others</h4>
<p>When you’re ready to share your charts, simply let someone know what the URL of your repository is.</p>
<p>From there, they will add the repository to their helm client via the <code>helm repo add [NAME] [URL]</code> command with any name they would like to use to reference the repository.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">helm repo add fantastic-charts https://fantastic-charts.storage.googleapis.com
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ helm repo list
fantastic-charts    https://fantastic-charts.storage.googleapis.com
</code></pre></td></tr></table>
</div>
</div><p>If the charts are backed by HTTP basic authentication, you can also supply the username and password here:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">helm repo add fantastic-charts https://fantastic-charts.storage.googleapis.com --username my-username --password my-password
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ helm repo list
fantastic-charts    https://fantastic-charts.storage.googleapis.com
</code></pre></td></tr></table>
</div>
</div><p>Note: A repository will not be added if it does not contain a valid <code>index.yaml</code>.</p>
<p>After that, your users will be able to search through your charts. After you’ve updated the repository, they can use the <code>helm repo update</code> command to get the latest chart information.</p>
<p>Under the hood, the <code>helm repo add</code> and <code>helm repo update</code> commands are fetching the index.yaml file and storing them in the <code>$HELM_HOME/repository/cache/</code> directory. This is where the <code>helm search</code> function finds information about charts.</p>
<h3 id="chart-tests">Chart Tests</h3>
<p>A chart contains a number of Kubernetes resources and components that work together. As a chart author, you may want to write some tests that validate that your chart works as expected when it is installed. These tests also help the chart consumer understand what your chart is supposed to do.</p>
<p>A <strong>test</strong> in a helm chart lives under the <code>templates/</code> directory and is a pod definition that specifies a container with a given command to run. The container should exit successfully (exit 0) for a test to be considered a success. The pod definition must contain one of the helm test hook annotations: <code>helm.sh/hook: test-success</code> or <code>helm.sh/hook: test-failure</code>.</p>
<p>Example tests: - Validate that your configuration from the values.yaml file was properly injected. - Make sure your username and password work correctly - Make sure an incorrect username and password does not work - Assert that your services are up and correctly loadbalanced. - etc.</p>
<p>You can run the pre-defined tests in Helm on a release using the command <code>helm test &lt;RELEASE_NAME&gt;</code>. For a chart consumer, this is a great way to sanity check that their release of a chart (or application) works as expected.</p>
<h4 id="a-breakdown-of-the-helm-test-hooks">A BREAKDOWN OF THE HELM TEST HOOKS</h4>
<p>In Helm, there are two test hooks: <code>test-success</code> and <code>test-failure</code></p>
<p><code>test-success</code> indicates that test pod should complete successfully. In other words, the containers in the pod should exit 0. <code>test-failure</code> is a way to assert that a test pod should not complete successfully. If the containers in the pod do not exit 0, that indicates success.</p>
<h4 id="example-test">EXAMPLE TEST</h4>
<p>Here is an example of a helm test pod definition in an example wordpress chart. The test verifies the access and login to the mariadb database:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">wordpress/
  Chart.yaml
  README.md
  values.yaml
  charts/
  templates/
  templates/tests/test-mariadb-connection.yaml
</code></pre></td></tr></table>
</div>
</div><p>In <code>wordpress/templates/tests/test-mariadb-connection.yaml</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">apiVersion: v1
kind: Pod
metadata:
  name: <span class="s2">&#34;{{ .Release.Name }}-credentials-test&#34;</span>
  annotations:
    <span class="s2">&#34;helm.sh/hook&#34;</span>: test-success
spec:
  containers:
  - name: <span class="o">{{</span> .Release.Name <span class="o">}}</span>-credentials-test
    image: <span class="o">{{</span> .Values.image <span class="o">}}</span>
    env:
      - name: MARIADB_HOST
        value: <span class="o">{{</span> template <span class="s2">&#34;mariadb.fullname&#34;</span> . <span class="o">}}</span>
      - name: MARIADB_PORT
        value: <span class="s2">&#34;3306&#34;</span>
      - name: WORDPRESS_DATABASE_NAME
        value: <span class="o">{{</span> default <span class="s2">&#34;&#34;</span> .Values.mariadb.mariadbDatabase <span class="p">|</span> quote <span class="o">}}</span>
      - name: WORDPRESS_DATABASE_USER
        value: <span class="o">{{</span> default <span class="s2">&#34;&#34;</span> .Values.mariadb.mariadbUser <span class="p">|</span> quote <span class="o">}}</span>
      - name: WORDPRESS_DATABASE_PASSWORD
        valueFrom:
          secretKeyRef:
            name: <span class="o">{{</span> template <span class="s2">&#34;mariadb.fullname&#34;</span> . <span class="o">}}</span>
            key: mariadb-password
    command: <span class="o">[</span><span class="s2">&#34;sh&#34;</span>, <span class="s2">&#34;-c&#34;</span>, <span class="s2">&#34;mysql --host=</span><span class="nv">$MARIADB_HOST</span><span class="s2"> --port=</span><span class="nv">$MARIADB_PORT</span><span class="s2"> --user=</span><span class="nv">$WORDPRESS_DATABASE_USER</span><span class="s2"> --password=</span><span class="nv">$WORDPRESS_DATABASE_PASSWORD</span><span class="s2">&#34;</span><span class="o">]</span>
  restartPolicy: Never
</code></pre></td></tr></table>
</div>
</div><h4 id="steps-to-run-a-test-suite-on-a-release">STEPS TO RUN A TEST SUITE ON A RELEASE</h4>
<ol>
<li>
<p><code>$ helm install stable/wordpress</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">NAME:   quirky-walrus
LAST DEPLOYED: Mon Feb <span class="m">13</span> 13:50:43 <span class="m">2017</span>
NAMESPACE: default
STATUS: DEPLOYED
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><code>$ helm test quirky-walrus</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">RUNNING: quirky-walrus-credentials-test
SUCCESS: quirky-walrus-credentials-test
</code></pre></td></tr></table>
</div>
</div></li>
</ol>
<p><strong>NOTES:</strong></p>
<ul>
<li>You can define as many tests as you would like in a single yaml file or spread across several yaml files in the <code>templates/</code> directory</li>
<li>You are welcome to nest your test suite under a <code>tests/</code> directory like <code>&lt;chart-name&gt;/templates/tests/</code> for more isolation</li>
</ul>
<h2 id="the-chart-template-developers-guide">The Chart Template Developer’s Guide</h2>
<p>This guide provides an introduction to Helm’s chart templates, with emphasis(重点) on the template language.</p>
<p>Templates generate manifest files, which are YAML-formatted resource descriptions that Kubernetes can understand. We’ll look at how templates are structured, how they can be used, how to write Go templates, and how to debug your work.</p>
<p>This guide focuses on the following concepts:</p>
<ul>
<li>The Helm template language</li>
<li>Using values</li>
<li>Techniques for working with templates</li>
</ul>
<p>This guide is oriented toward learning the ins and outs of the Helm template language. Other guides provide introductory material(介绍性质的材料)), examples(示例), and best practices(最佳实践).</p>
<h3 id="getting-started-with-a-chart-template">Getting Started with a Chart Template</h3>
<p>In this section of the guide, we’ll create a chart and then add a first template. The chart we created here will be used throughout the rest of the guide.</p>
<p>To get going, let’s take a brief look at a Helm chart.</p>
<h4 id="charts-1">CHARTS</h4>
<p>As described in the <a href="https://helm.sh/docs/chart_template_guide/#../charts" target="_blank" rel="noopener noreffer">Charts Guide</a>, Helm charts are structured like this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">mychart/
  Chart.yaml
  values.yaml
  charts/
  templates/
  ...
</code></pre></td></tr></table>
</div>
</div><p>The <code>templates/</code> directory is for template files. When Tiller evaluates a chart, it will send all of the files in the <code>templates/</code> directory through the template rendering engine. Tiller then collects the results of those templates and sends them on to Kubernetes.</p>
<p>The <code>values.yaml</code> file is also important to templates. This file contains the <strong>default values</strong> for a chart. These values may be overridden by users during <code>helm install</code> or <code>helm upgrade</code>.</p>
<p>The <code>Chart.yaml</code> file contains a description of the chart. You can access it from within a template. The <code>charts/</code> directory <strong>may</strong> contain other charts (which we call <strong>subcharts</strong>). Later in this guide we will see how those work when it comes to template rendering.</p>
<h4 id="a-starter-chart">A STARTER CHART</h4>
<p>For this guide, we’ll create a simple chart called <code>mychart</code>, and then we’ll create some templates inside of the chart.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ helm create mychart
Creating mychart
</code></pre></td></tr></table>
</div>
</div><p>From here on, we’ll be working in the <code>mychart</code> directory.</p>
<h5 id="a-quick-glimpse-of-mycharttemplates">A Quick Glimpse of <code>mychart/templates/</code></h5>
<p>If you take a look at the <code>mychart/templates/</code> directory, you’ll notice a few files already there.</p>
<ul>
<li><strong>NOTES.txt</strong>: The “help text” for your chart. This will be displayed to your users when they run <code>helm install</code>.</li>
<li><strong>deployment.yaml</strong>: A basic manifest for creating a Kubernetes <a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" target="_blank" rel="noopener noreffer">deployment</a></li>
<li><strong>service.yaml</strong>: A basic manifest for creating a <a href="https://kubernetes.io/docs/concepts/services-networking/service/" target="_blank" rel="noopener noreffer">service endpoint</a> for your deployment</li>
<li><strong>_helpers.tpl</strong>: A place to put template helpers that you can re-use throughout the chart</li>
</ul>
<p>And what we’re going to do is… <em><strong>remove them all!</strong></em> That way we can work through our tutorial from scratch. We’ll actually create our own <code>NOTES.txt</code> and <code>_helpers.tpl</code> as we go.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">rm -rf mychart/templates/*.*
</code></pre></td></tr></table>
</div>
</div><p>When you’re writing production grade charts, having basic versions of these charts can be really useful. So in your day-to-day chart authoring, you probably won’t want to remove them.</p>
<h4 id="a-first-template">A FIRST TEMPLATE</h4>
<p>The first template we are going to create will be a <code>ConfigMap</code>. In Kubernetes, a ConfigMap is simply a container for storing configuration data. Other things, like pods, can access the data in a ConfigMap.</p>
<p>Because ConfigMaps are basic resources, they make a great starting point for us.</p>
<p>Let’s begin by creating a file called <code>mychart/templates/configmap.yaml</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">apiVersion: v1
kind: ConfigMap
metadata:
  name: mychart-configmap
data:
  myvalue: <span class="s2">&#34;Hello World&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>TIP</strong>: Template names do not follow a rigid(刚性，生硬，严格) naming pattern. However, we recommend using the suffix .yaml for YAML files and .tpl for helpers.</p>
<p>The YAML file above is a bare-bones ConfigMap, having the minimal necessary fields. In virtue of the fact that this file is in the <code>templates/</code> directory, it will be sent through the template engine.</p>
<p>It is just fine to put a plain YAML file like this in the <code>templates/</code> directory. When Tiller reads this template, it will simply send it to Kubernetes as-is.</p>
<p>With this simple template, we now have an installable chart. And we can install it like this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ helm install ./mychart
NAME: full-coral
LAST DEPLOYED: Tue Nov  <span class="m">1</span> 17:36:01 <span class="m">2016</span>
NAMESPACE: default
STATUS: DEPLOYED

RESOURCES:
<span class="o">==</span>&gt; v1/ConfigMap
NAME                DATA      AGE
mychart-configmap   <span class="m">1</span>         1m
</code></pre></td></tr></table>
</div>
</div><p>In the output above, we can see that our ConfigMap was created. Using Helm, we can retrieve the release and see the actual template that was loaded.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ helm get manifest full-coral
---
<span class="c1"># Source: mychart/templates/configmap.yaml</span>
apiVersion: v1
kind: ConfigMap
metadata:
  name: mychart-configmap
data:
  myvalue: <span class="s2">&#34;Hello World&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>The <code>helm get manifest</code> command takes a release name (<code>full-coral</code>) and prints out all of the Kubernetes resources that were uploaded to the server. Each file begins with <code>---</code> to indicate the start of a YAML document, and then is followed by an automatically generated comment line that tells us what template file generated this YAML document.</p>
<p>From there on, we can see that the YAML data is exactly what we put in our <code>configmap.yaml</code> file.</p>
<p>Now we can delete our release: <code>helm delete full-coral</code>.</p>
<h5 id="adding-a-simple-template-call">Adding a Simple Template Call</h5>
<p>Hard-coding the <code>name</code>: into a resource is usually considered to be bad practice. Names should be unique to a release. So we might want to generate a name field by inserting the release name.</p>
<p><strong>TIP</strong>: The <code>name</code>: field is limited to 63 characters because of limitations to the DNS system. For that reason, release names are limited to 53 characters. Kubernetes 1.3 and earlier limited to only 24 characters (thus 14 character names).</p>
<p>Let’s alter <code>configmap.yaml</code> accordingly.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">apiVersion: v1
kind: ConfigMap
metadata:
  name: <span class="o">{{</span> .Release.Name <span class="o">}}</span>-configmap
data:
  myvalue: <span class="s2">&#34;Hello World&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>The big change comes in the value of the <code>name:</code> field, which is now <code>{{ .Release.Name }}-configmap</code>.</p>
<p>A template directive(指示，指令) is enclosed in {{ and }} blocks.</p>
<p>The template directive <code>{{ .Release.Name }}</code> injects the release name into the template. The values that are passed into a template can be thought of as <code>namespaced objects</code>, where a dot (<code>.</code>) separates each namespaced element.</p>
<p>The leading dot before <code>Release</code> indicates that we start with the top-most namespace for this scope (we’ll talk about scope in a bit). So we could read <code>.Release.Name</code> as “start at the top namespace, find the <code>Release</code> object, then look inside of it for an object called <code>Name</code>”.</p>
<p>The <code>Release</code> object is one of the built-in objects for Helm, and we’ll cover it in more depth later. But for now, it is sufficient to say that this will display the release name that Tiller assigns to our release.</p>
<p>Now when we install our resource, we’ll immediately see the result of using this template directive:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ helm install ./mychart
NAME: clunky-serval
LAST DEPLOYED: Tue Nov  <span class="m">1</span> 17:45:37 <span class="m">2016</span>
NAMESPACE: default
STATUS: DEPLOYED

RESOURCES:
<span class="o">==</span>&gt; v1/ConfigMap
NAME                      DATA      AGE
clunky-serval-configmap   <span class="m">1</span>         1m
</code></pre></td></tr></table>
</div>
</div><p>Note that in the <code>RESOURCES</code> section, the name we see there is <code>clunky-serval-configmap</code> instead of <code>mychart-configmap</code>.</p>
<p>You can run <code>helm get manifest clunky-serval</code> to see the entire generated YAML.</p>
<p>At this point, we’ve seen templates at their most basic: YAML files that have template directives embedded in <code>{{</code> and <code>}}</code>. In the next part, we’ll take a deeper look into templates. But before moving on, there’s one quick trick that can make building templates faster: When you want to test the template rendering, but not actually install anything, you can use <code>helm install ./mychart --debug --dry-run</code>. This will send the chart to the Tiller server, which will render the templates. But instead of installing the chart, it will return the rendered template to you so you can see the output:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ helm install ./mychart --debug --dry-run
SERVER: <span class="s2">&#34;localhost:44134&#34;</span>
CHART PATH: /Users/mattbutcher/Code/Go/src/k8s.io/helm/_scratch/mychart
NAME:   goodly-guppy
TARGET NAMESPACE:   default
CHART:  mychart 0.1.0
MANIFEST:
---
<span class="c1"># Source: mychart/templates/configmap.yaml</span>
apiVersion: v1
kind: ConfigMap
metadata:
  name: goodly-guppy-configmap
data:
  myvalue: <span class="s2">&#34;Hello World&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>Using <code>--dry-run</code> will make it easier to test your code, but it won’t ensure that Kubernetes itself will accept the templates you generate. It’s best not to assume that your chart will install just because <code>--dry-run</code> works.</p>
<p>In the next few sections, we’ll take the basic chart we defined here and explore the Helm template language in detail. And we’ll get started with built-in objects.</p>
<h3 id="built-in-objects">Built-in Objects</h3>
<p>Objects are passed into a template from the template engine. And your code can pass objects around (we’ll see examples when we look at the <code>with</code> and <code>range</code> statements). There are even a few ways to create new objects within your templates, like with the <code>list</code> function we’ll see later.</p>
<p>Objects can be simple, and have just one value. Or they can contain other objects or functions. For example. the <code>Release</code> object contains several objects (like <code>Release.Name</code>) and the <code>Files</code> object has a few functions.</p>
<p>In the previous section, we use <code>{{.Release.Name}}</code> to insert the name of a release into a template. <code>Release</code> is one of the top-level objects that you can access in your templates.</p>
<ul>
<li>
<p><code>Release</code>: This object describes the release itself. It has several objects inside of it:</p>
<ul>
<li><code>Release.Name</code>: The release name</li>
<li><code>Release.Time</code>: The time of the release</li>
<li><code>Release.Namespace</code>: The namespace to be released into (if the manifest doesn’t override)</li>
<li><code>Release.Service</code>: The name of the releasing service (always <code>Tiller</code>).</li>
<li><code>Release.Revision</code>: The revision number of this release. It begins at 1 and is incremented for each helm upgrade.</li>
<li><code>Release.IsUpgrade</code>: This is set to <code>true</code> if the current operation is an upgrade or rollback.</li>
<li><code>Release.IsInstall</code>: This is set to <code>true</code> if the current operation is an install.</li>
</ul>
</li>
<li>
<p><code>Values</code>: Values passed into the template from the <code>values.yaml</code> file and from user-supplied files. By default, <code>Values</code> is empty.</p>
</li>
<li>
<p><code>Chart</code>: The contents of the <code>Chart.yaml</code> file. Any data in <code>Chart.yaml</code> will be accessible here. For example <code>{{.Chart.Name}}-{{.Chart.Version}}</code> will print out the <code>mychart-0.1.0</code>.</p>
<ul>
<li>The available fields are listed in the <a href="https://github.com/helm/helm/blob/master/docs/charts.md#the-chartyaml-file" target="_blank" rel="noopener noreffer">Charts Guide</a></li>
</ul>
</li>
<li>
<p><code>Files</code>: This provides access to all non-special files in a chart. While you cannot use it to access templates, you can use it to access other files in the chart. See the section <em>Accessing Files</em> for more.</p>
<ul>
<li><code>Files.Get</code> is a function for getting a file by name (<code>.Files.Get config.ini</code>)</li>
<li><code>Files.GetBytes</code> is a function for getting the contents of a file as an array of bytes instead of as a string. This is useful for things like images.</li>
</ul>
</li>
<li>
<p><code>Capabilities</code>(能力): This provides information about what capabilities the Kubernetes cluster supports.</p>
<ul>
<li><code>Capabilities.APIVersions</code> is a set of versions.</li>
<li><code>Capabilities.APIVersions.Has $version</code> indicates whether a version (e.g., <code>batch/v1</code>) or resource (e.g., <code>apps/v1/Deployment</code>) is available on the cluster. Note, resources were not available before Helm v2.15.</li>
<li><code>Capabilities.KubeVersion</code> provides a way to look up the Kubernetes version. It has the following values: <code>Major</code>, <code>Minor</code>, <code>GitVersion</code>, <code>GitCommit</code>, <code>GitTreeState</code>, <code>BuildDate</code>, <code>GoVersion</code>, <code>Compiler</code>, and <code>Platform</code>.</li>
<li><code>Capabilities.TillerVersion</code> provides a way to look up the Tiller version. It has the following values: <code>SemVer</code>, <code>GitCommit</code>, and <code>GitTreeState</code>.</li>
</ul>
</li>
<li>
<p><code>Template</code>: Contains information about the current template that is being executed</p>
<ul>
<li><code>Name</code>: A namespaced filepath to the current template (e.g. <code>mychart/templates/mytemplate.yaml</code>)</li>
<li><code>BasePath</code>: The namespaced path to the templates directory of the current chart (e.g. <code>mychart/templates</code>).</li>
</ul>
</li>
</ul>
<p>The values are available to any top-level template. As we will see later, this does not necessarily mean that they will be available everywhere.</p>
<p>The built-in values always begin with a capital letter. This is in keeping with Go’s naming convention. When you create your own names, you are free to use a convention that suits your team. Some teams, like the <a href="https://github.com/helm/charts" target="_blank" rel="noopener noreffer">Helm Charts</a> team, choose to use only initial lower case letters in order to distinguish local names from those built-in. In this guide, we follow that convention.</p>
<h3 id="values-files-1">Values Files</h3>
<p>In the previous section we looked at the built-in objects that Helm templates offer. One of these built-in objects is <code>Values</code>. This object provides access to values passed into the chart. Its contents come from four sources:</p>
<ul>
<li>The <code>values.yaml</code> file in the chart</li>
<li>If this is a subchart, the <code>values.yaml</code> file of a parent chart</li>
<li>A values file is passed into <code>helm install</code> or <code>helm upgrade</code> with the <code>-f</code> flag (<code>helm install -f myvals.yaml ./mychart</code>)</li>
<li>Individual parameters passed with <code>--set</code> (such as <code>helm install --set foo=bar ./mychart</code>)</li>
</ul>
<p>The list above is in order of specificity: <code>values.yaml</code> is the default, which can be overridden by a parent chart’s <code>values.yaml</code>, which can in turn be overridden by a user-supplied values file, which can in turn be overridden by <code>--set</code> parameters.</p>
<p>Values files are plain YAML files. Let’s edit <code>mychart/values.yaml</code> and then edit our ConfigMap template.</p>
<p>Removing the defaults in <code>values.yaml</code>, we’ll set just one parameter:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">favoriteDrink: coffee
</code></pre></td></tr></table>
</div>
</div><p>Now we can use this inside of a template:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">apiVersion: v1
kind: ConfigMap
metadata:
  name: <span class="o">{{</span> .Release.Name <span class="o">}}</span>-configmap
data:
  myvalue: <span class="s2">&#34;Hello World&#34;</span>
  drink: <span class="o">{{</span> .Values.favoriteDrink <span class="o">}}</span>
</code></pre></td></tr></table>
</div>
</div><p>Notice on the last line we access <code>favoriteDrink</code> as an attribute of <code>Values</code>: <code>{{ .Values.favoriteDrink }}</code>.</p>
<p>Let’s see how this renders.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ helm install --dry-run --debug ./mychart
SERVER: <span class="s2">&#34;localhost:44134&#34;</span>
CHART PATH: /Users/mattbutcher/Code/Go/src/k8s.io/helm/_scratch/mychart
NAME:   geared-marsupi
TARGET NAMESPACE:   default
CHART:  mychart 0.1.0
MANIFEST:
---
<span class="c1"># Source: mychart/templates/configmap.yaml</span>
apiVersion: v1
kind: ConfigMap
metadata:
  name: geared-marsupi-configmap
data:
  myvalue: <span class="s2">&#34;Hello World&#34;</span>
  drink: coffee
</code></pre></td></tr></table>
</div>
</div><p>Because <code>favoriteDrink</code> is set in the default <code>values.yaml</code> file to <code>coffee</code>, that’s the value displayed in the template. We can easily override that by adding a <code>--set</code> flag in our call to <code>helm install</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">helm install --dry-run --debug --set <span class="nv">favoriteDrink</span><span class="o">=</span>slurm ./mychart
SERVER: <span class="s2">&#34;localhost:44134&#34;</span>
CHART PATH: /Users/mattbutcher/Code/Go/src/k8s.io/helm/_scratch/mychart
NAME:   solid-vulture
TARGET NAMESPACE:   default
CHART:  mychart 0.1.0
MANIFEST:
---
<span class="c1"># Source: mychart/templates/configmap.yaml</span>
apiVersion: v1
kind: ConfigMap
metadata:
  name: solid-vulture-configmap
data:
  myvalue: <span class="s2">&#34;Hello World&#34;</span>
  drink: slurm
</code></pre></td></tr></table>
</div>
</div><p>Since <code>--set</code> has a higher precedence than the default <code>values.yaml</code> file, our template generates <code>drink: slurm</code>.</p>
<p>Values files can contain more structured content, too. For example, we could create a <code>favorite</code> section in our <code>values.yaml</code> file, and then add several keys there:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">favorite:
  drink: coffee
  food: pizza
</code></pre></td></tr></table>
</div>
</div><p>Now we would have to modify the template slightly:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">apiVersion: v1
kind: ConfigMap
metadata:
  name: <span class="o">{{</span> .Release.Name <span class="o">}}</span>-configmap
data:
  myvalue: <span class="s2">&#34;Hello World&#34;</span>
  drink: <span class="o">{{</span> .Values.favorite.drink <span class="o">}}</span>
  food: <span class="o">{{</span> .Values.favorite.food <span class="o">}}</span>
</code></pre></td></tr></table>
</div>
</div><p>While structuring data this way is possible, the recommendation is that you keep your values trees shallow, favoring flatness. When we look at assigning values to subcharts, we’ll see how values are named using a tree structure.</p>
<h4 id="deleting-a-default-key">DELETING A DEFAULT KEY</h4>
<p>If you need to delete a key from the default values, you may override the value of the key to be <code>null</code>, in which case Helm will remove the key from the overridden values merge.</p>
<p>For example, the stable Drupal chart allows configuring the liveness probe, in case you configure a custom image. Here are the default values:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">livenessProbe:
  httpGet:
    path: /user/login
    port: http
  initialDelaySeconds: <span class="m">120</span>
</code></pre></td></tr></table>
</div>
</div><p>If you try to override the livenessProbe handler to <code>exec</code> instead of <code>httpGet</code> using <code>--set livenessProbe.exec.command=[cat,docroot/CHANGELOG.txt]</code>, Helm will coalesce the default and overridden keys together, resulting in the following YAML:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">livenessProbe:
  httpGet:
    path: /user/login
    port: http
  exec:
    command:
    - cat
    - docroot/CHANGELOG.txt
  initialDelaySeconds: <span class="m">120</span>
</code></pre></td></tr></table>
</div>
</div><p>However, Kubernetes would then fail because you can not declare more than one livenessProbe handler. To overcome this, you may instruct Helm to delete the <code>livenessProbe.httpGet</code> by setting it to null:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">helm install stable/drupal --set <span class="nv">image</span><span class="o">=</span>my-registry/drupal:0.1.0 --set livenessProbe.exec.command<span class="o">=[</span>cat,docroot/CHANGELOG.txt<span class="o">]</span> --set livenessProbe.httpGet<span class="o">=</span>null
</code></pre></td></tr></table>
</div>
</div><p>At this point, we’ve seen several built-in objects, and used them to inject information into a template. Now we will take a look at another aspect of the template engine: functions and pipelines.</p>
<h3 id="template-functions-and-pipelines">Template Functions and Pipelines</h3>
<p>So far, we’ve seen how to place information into a template. But that information is placed into the template unmodified. Sometimes we want to transform the supplied data in a way that makes it more usable to us.</p>
<p>Let’s start with a best practice: When injecting strings from the <code>.Values</code> object into the template, we ought to quote these strings. We can do that by calling the <code>quote</code> function in the template directive:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">apiVersion: v1
kind: ConfigMap
metadata:
  name: <span class="o">{{</span> .Release.Name <span class="o">}}</span>-configmap
data:
  myvalue: <span class="s2">&#34;Hello World&#34;</span>
  drink: <span class="o">{{</span> quote .Values.favorite.drink <span class="o">}}</span>
  food: <span class="o">{{</span> quote .Values.favorite.food <span class="o">}}</span>
</code></pre></td></tr></table>
</div>
</div><p>Template functions follow the syntax <code>functionName arg1 arg2....</code> In the snippet above, <code>quote .Values.favorite.drink</code> calls the quote function and passes it a single argument.</p>
<p>Helm has over 60 available functions. Some of them are defined by the <a href="https://godoc.org/text/template" target="_blank" rel="noopener noreffer">Go template language</a> itself. Most of the others are part of the <a href="https://godoc.org/github.com/Masterminds/sprig" target="_blank" rel="noopener noreffer">Sprig template library</a>. We’ll see many of them as we progress through the examples.</p>
<p>While we talk about the “Helm template language” as if it is Helm-specific, it is actually a combination of the Go template language, some extra functions, and a variety of wrappers to expose certain objects to the templates. Many resources on Go templates may be helpful as you learn about templating.</p>
<h4 id="pipelines">PIPELINES</h4>
<p>One of the powerful features of the template language is its concept of <strong>pipelines</strong>(管道). Drawing on a concept from UNIX, pipelines are a tool for chaining together a series of template commands to compactly express a series of transformations. In other words, pipelines are an efficient way of getting several things done in sequence. Let’s rewrite the above example using a pipeline.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">apiVersion: v1
kind: ConfigMap
metadata:
  name: <span class="o">{{</span> .Release.Name <span class="o">}}</span>-configmap
data:
  myvalue: <span class="s2">&#34;Hello World&#34;</span>
  drink: <span class="o">{{</span> .Values.favorite.drink <span class="p">|</span> quote <span class="o">}}</span>
  food: <span class="o">{{</span> .Values.favorite.food <span class="p">|</span> quote <span class="o">}}</span>
</code></pre></td></tr></table>
</div>
</div><p>In this example, instead of calling <code>quote ARGUMENT</code>, we inverted the order. We “sent” the argument to the function using a pipeline (<code>|</code>): <code>.Values.favorite.drink | quote</code>. Using pipelines, we can chain several functions together:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">apiVersion: v1
kind: ConfigMap
metadata:
  name: <span class="o">{{</span> .Release.Name <span class="o">}}</span>-configmap
data:
  myvalue: <span class="s2">&#34;Hello World&#34;</span>
  drink: <span class="o">{{</span> .Values.favorite.drink <span class="p">|</span> quote <span class="o">}}</span>
  food: <span class="o">{{</span> .Values.favorite.food <span class="p">|</span> upper <span class="p">|</span> quote <span class="o">}}</span>
</code></pre></td></tr></table>
</div>
</div><p>Inverting the order is a common practice in templates. You will see <code>.val | quote</code> more often than <code>quote .val</code>. Either practice is fine.</p>
<p>When evaluated, that template will produce this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># Source: mychart/templates/configmap.yaml</span>
apiVersion: v1
kind: ConfigMap
metadata:
  name: trendsetting-p-configmap
data:
  myvalue: <span class="s2">&#34;Hello World&#34;</span>
  drink: <span class="s2">&#34;coffee&#34;</span>
  food: <span class="s2">&#34;PIZZA&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>Note that our original <code>pizza</code> has now been transformed to <code>&quot;PIZZA&quot;</code>.</p>
<p>When pipelining arguments like this, the result of the first evaluation (<code>.Values.favorite.drink</code>) is sent as the <em><strong>last argument to the function</strong></em>. We can modify the drink example above to illustrate with a function that takes two arguments: <code>repeat COUNT STRING</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">apiVersion: v1
kind: ConfigMap
metadata:
  name: <span class="o">{{</span> .Release.Name <span class="o">}}</span>-configmap
data:
  myvalue: <span class="s2">&#34;Hello World&#34;</span>
  drink: <span class="o">{{</span> .Values.favorite.drink <span class="p">|</span> repeat <span class="m">5</span> <span class="p">|</span> quote <span class="o">}}</span>
  food: <span class="o">{{</span> .Values.favorite.food <span class="p">|</span> upper <span class="p">|</span> quote <span class="o">}}</span>
</code></pre></td></tr></table>
</div>
</div><p>The <code>repeat</code> function will echo the given string the given number of times, so we will get this for output:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># Source: mychart/templates/configmap.yaml</span>
apiVersion: v1
kind: ConfigMap
metadata:
  name: melting-porcup-configmap
data:
  myvalue: <span class="s2">&#34;Hello World&#34;</span>
  drink: <span class="s2">&#34;coffeecoffeecoffeecoffeecoffee&#34;</span>
  food: <span class="s2">&#34;PIZZA&#34;</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="using-the-default-function">USING THE <code>DEFAULT</code> FUNCTION</h4>
<p>One function frequently used in templates is the <code>default</code> function: <code>default DEFAULT_VALUE GIVEN_VALUE</code>. This function allows you to specify a default value inside of the template, in case the value is omitted. Let’s use it to modify the drink example above:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">drink: <span class="o">{{</span> .Values.favorite.drink <span class="p">|</span> default <span class="s2">&#34;tea&#34;</span> <span class="p">|</span> quote <span class="o">}}</span>
</code></pre></td></tr></table>
</div>
</div><p>If we run this as normal, we’ll get our <code>coffee</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># Source: mychart/templates/configmap.yaml</span>
apiVersion: v1
kind: ConfigMap
metadata:
  name: virtuous-mink-configmap
data:
  myvalue: <span class="s2">&#34;Hello World&#34;</span>
  drink: <span class="s2">&#34;coffee&#34;</span>
  food: <span class="s2">&#34;PIZZA&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>Now, we will remove the favorite drink setting from <code>values.yaml</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">favorite:
  <span class="c1">#drink: coffee</span>
  food: pizza
</code></pre></td></tr></table>
</div>
</div><p>Now re-running <code>helm install --dry-run --debug ./mychart</code> will produce this YAML:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># Source: mychart/templates/configmap.yaml</span>
apiVersion: v1
kind: ConfigMap
metadata:
  name: fair-worm-configmap
data:
  myvalue: <span class="s2">&#34;Hello World&#34;</span>
  drink: <span class="s2">&#34;tea&#34;</span>
  food: <span class="s2">&#34;PIZZA&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>In an actual chart, all static default values should live in the values.yaml, and should not be repeated using the <code>default</code> command (otherwise they would be redundant). However, the <code>default</code> command is perfect for computed values, which can not be declared inside values.yaml. For example:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">drink: <span class="o">{{</span> .Values.favorite.drink <span class="p">|</span> default <span class="o">(</span><span class="nb">printf</span> <span class="s2">&#34;%s-tea&#34;</span> <span class="o">(</span>include <span class="s2">&#34;fullname&#34;</span> .<span class="o">))</span> <span class="o">}}</span>
</code></pre></td></tr></table>
</div>
</div><p>In some places, an <code>if</code> conditional guard may be better suited than <code>default</code>. We’ll see those in the next section.</p>
<p>Template functions and pipelines are a powerful way to transform information and then insert it into your YAML. But sometimes it’s necessary to add some template logic that is a little more sophisticated than just inserting a string. In the next section we will look at the control structures provided by the template language.</p>
<h4 id="operators-are-functions">OPERATORS ARE FUNCTIONS</h4>
<p>Operators are implemented as functions that return a boolean value. To use <code>eq</code>, <code>ne</code>, <code>lt</code>, <code>gt</code>, and, <code>or</code>, <code>not</code> etcetera(等等) place the operator at the front of the statement followed by its parameters just as you would a function. To chain multiple operations together, separate individual functions by surrounding them with parentheses.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">{{</span>/* include the body of this <span class="k">if</span> statement when the variable .Values.fooString exists and is <span class="nb">set</span> to <span class="s2">&#34;foo&#34;</span> */<span class="o">}}</span>
<span class="o">{{</span> <span class="k">if</span> and .Values.fooString <span class="o">(</span>eq .Values.fooString <span class="s2">&#34;foo&#34;</span><span class="o">)</span> <span class="o">}}</span>
    <span class="o">{{</span> ... <span class="o">}}</span>
<span class="o">{{</span> end <span class="o">}}</span>


<span class="o">{{</span>/* include the body of this <span class="k">if</span> statement when the variable .Values.anUnsetVariable is <span class="nb">set</span> or .values.aSetVariable is not <span class="nb">set</span> */<span class="o">}}</span>
<span class="o">{{</span> <span class="k">if</span> or .Values.anUnsetVariable <span class="o">(</span>not .Values.aSetVariable<span class="o">)</span> <span class="o">}}</span>
   <span class="o">{{</span> ... <span class="o">}}</span>
<span class="o">{{</span> end <span class="o">}}</span>
</code></pre></td></tr></table>
</div>
</div><p>Now we can turn from functions and pipelines to flow control with conditions, loops, and scope modifiers.</p>
<h3 id="flow-control">Flow Control</h3>
<p>Control structures (called “actions” in template parlance(用语)) provide you, the template author, with the ability to control the flow of a template’s generation. Helm’s template language provides the following control structures:</p>
<ul>
<li><code>if/else</code> for creating conditional blocks</li>
<li><code>with</code> to specify a scope</li>
<li><code>range</code>, which provides a “for each”-style loop</li>
</ul>
<p>In addition to these, it provides a few actions for declaring and using named template segments:</p>
<ul>
<li><code>define</code> declares a new named template inside of your template</li>
<li><code>template</code> imports a named template</li>
<li><code>block</code> declares a special kind of fillable template area</li>
</ul>
<p>In this section, we’ll talk about <code>if</code>, <code>with</code>, and <code>range</code>. The others are covered in the “Named Templates” section later in this guide.</p>
<h4 id="ifelse">IF/ELSE</h4>
<p>The first control structure we’ll look at is for conditionally including blocks of text in a template. This is the <code>if</code>/<code>else</code> block.</p>
<p>The basic structure for a conditional looks like this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">{{</span> <span class="k">if</span> PIPELINE <span class="o">}}</span>
  <span class="c1"># Do something</span>
<span class="o">{{</span> <span class="k">else</span> <span class="k">if</span> OTHER PIPELINE <span class="o">}}</span>
  <span class="c1"># Do something else</span>
<span class="o">{{</span> <span class="k">else</span> <span class="o">}}</span>
  <span class="c1"># Default case</span>
<span class="o">{{</span> end <span class="o">}}</span>
</code></pre></td></tr></table>
</div>
</div><p>Notice that we’re now talking about <code>pipelines</code> instead of values. The reason for this is to make it clear that control structures can execute an entire pipeline, not just evaluate a value.</p>
<p>A pipeline is evaluated as <strong>false</strong> if the value is:</p>
<ul>
<li>a boolean false</li>
<li>a numeric zero</li>
<li>an empty string</li>
<li>a <code>nil</code> (empty or null)</li>
<li>an empty collection (<code>map</code>, <code>slice</code>, <code>tuple</code>, <code>dict</code>, <code>array</code>)</li>
</ul>
<p>In any other case, the condition is evaluated to true and the pipeline is executed.</p>
<p>Let’s add a simple conditional to our ConfigMap. We’ll add another setting if the drink is set to coffee:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">apiVersion: v1
kind: ConfigMap
metadata:
  name: <span class="o">{{</span> .Release.Name <span class="o">}}</span>-configmap
data:
  myvalue: <span class="s2">&#34;Hello World&#34;</span>
  drink: <span class="o">{{</span> .Values.favorite.drink <span class="p">|</span> default <span class="s2">&#34;tea&#34;</span> <span class="p">|</span> quote <span class="o">}}</span>
  food: <span class="o">{{</span> .Values.favorite.food <span class="p">|</span> upper <span class="p">|</span> quote <span class="o">}}</span>
  <span class="o">{{</span> <span class="k">if</span> and .Values.favorite.drink <span class="o">(</span>eq .Values.favorite.drink <span class="s2">&#34;coffee&#34;</span><span class="o">)</span> <span class="o">}}</span>mug: true<span class="o">{{</span> end <span class="o">}}</span>
</code></pre></td></tr></table>
</div>
</div><p>Note that <code>.Values.favorite.drink</code> must be defined or else it will throw an error when comparing it to “coffee”. Since we commented out <code>drink: coffee</code> in our last example, the output should not include a <code>mug: true</code> flag. But if we add that line back into our <code>values.yaml</code> file, the output should look like this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># Source: mychart/templates/configmap.yaml</span>
apiVersion: v1
kind: ConfigMap
metadata:
  name: eyewitness-elk-configmap
data:
  myvalue: <span class="s2">&#34;Hello World&#34;</span>
  drink: <span class="s2">&#34;coffee&#34;</span>
  food: <span class="s2">&#34;PIZZA&#34;</span>
  mug: <span class="nb">true</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="controlling-whitespace">CONTROLLING WHITESPACE</h4>
<p>While we’re looking at conditionals, we should take a quick look at the way whitespace is controlled in templates. Let’s take the previous example and format it to be a little easier to read:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">apiVersion: v1
kind: ConfigMap
metadata:
  name: <span class="o">{{</span> .Release.Name <span class="o">}}</span>-configmap
data:
  myvalue: <span class="s2">&#34;Hello World&#34;</span>
  drink: <span class="o">{{</span> .Values.favorite.drink <span class="p">|</span> default <span class="s2">&#34;tea&#34;</span> <span class="p">|</span> quote <span class="o">}}</span>
  food: <span class="o">{{</span> .Values.favorite.food <span class="p">|</span> upper <span class="p">|</span> quote <span class="o">}}</span>
  <span class="o">{{</span><span class="k">if</span> eq .Values.favorite.drink <span class="s2">&#34;coffee&#34;</span><span class="o">}}</span>
    mug: <span class="nb">true</span>
  <span class="o">{{</span>end<span class="o">}}</span>
</code></pre></td></tr></table>
</div>
</div><p>Initially, this looks good. But if we run it through the template engine, we’ll get an unfortunate result:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ helm install --dry-run --debug ./mychart
SERVER: <span class="s2">&#34;localhost:44134&#34;</span>
CHART PATH: /Users/mattbutcher/Code/Go/src/k8s.io/helm/_scratch/mychart
Error: YAML parse error on mychart/templates/configmap.yaml: error converting YAML to JSON: yaml: line 9: did not find expected key
</code></pre></td></tr></table>
</div>
</div><p>What happened? We generated incorrect YAML because of the whitespacing above.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># Source: mychart/templates/configmap.yaml</span>
apiVersion: v1
kind: ConfigMap
metadata:
  name: eyewitness-elk-configmap
data:
  myvalue: <span class="s2">&#34;Hello World&#34;</span>
  drink: <span class="s2">&#34;coffee&#34;</span>
  food: <span class="s2">&#34;PIZZA&#34;</span>
    mug: <span class="nb">true</span>
</code></pre></td></tr></table>
</div>
</div><p>mug is incorrectly indented. Let’s simply out-dent that one line, and re-run:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">apiVersion: v1
kind: ConfigMap
metadata:
  name: <span class="o">{{</span> .Release.Name <span class="o">}}</span>-configmap
data:
  myvalue: <span class="s2">&#34;Hello World&#34;</span>
  drink: <span class="o">{{</span> .Values.favorite.drink <span class="p">|</span> default <span class="s2">&#34;tea&#34;</span> <span class="p">|</span> quote <span class="o">}}</span>
  food: <span class="o">{{</span> .Values.favorite.food <span class="p">|</span> upper <span class="p">|</span> quote <span class="o">}}</span>
  <span class="o">{{</span><span class="k">if</span> eq .Values.favorite.drink <span class="s2">&#34;coffee&#34;</span><span class="o">}}</span>
  mug: <span class="nb">true</span>
  <span class="o">{{</span>end<span class="o">}}</span>
</code></pre></td></tr></table>
</div>
</div><p>When we sent that, we’ll get YAML that is valid, but still looks a little funny:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># Source: mychart/templates/configmap.yaml</span>
apiVersion: v1
kind: ConfigMap
metadata:
  name: telling-chimp-configmap
data:
  myvalue: <span class="s2">&#34;Hello World&#34;</span>
  drink: <span class="s2">&#34;coffee&#34;</span>
  food: <span class="s2">&#34;PIZZA&#34;</span>

  mug: <span class="nb">true</span>

</code></pre></td></tr></table>
</div>
</div><p>Notice that we received a few empty lines in our YAML. Why? When the template engine runs, it removes the contents inside of <code>{{</code> and <code>}}</code>, but it leaves the remaining whitespace exactly as is.</p>
<p>YAML ascribes meaning to whitespace, so managing the whitespace becomes pretty important. Fortunately, Helm templates have a few tools to help.</p>
<p>First, the curly brace syntax(花括号语法) of template declarations can be modified with special characters to tell the template engine to chomp(吃掉，去除) whitespace. <code>{{-</code> (with the dash(破折号) and space(空格) added) indicates that whitespace should be chomped left, while <code>-}}</code> means whitespace to the right should be consumed. <em><strong>Be careful! Newlines are whitespace!</strong></em></p>
<p>Make sure there is a <strong>space</strong> between the <code>-</code> and the rest of your directive. <code>{{- 3 }}</code> means “trim left whitespace and print 3” while <code>{{-3}}</code> means “print -3”.</p>
<p>Using this syntax, we can modify our template to get rid of those new lines:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">apiVersion: v1
kind: ConfigMap
metadata:
  name: <span class="o">{{</span> .Release.Name <span class="o">}}</span>-configmap
data:
  myvalue: <span class="s2">&#34;Hello World&#34;</span>
  drink: <span class="o">{{</span> .Values.favorite.drink <span class="p">|</span> default <span class="s2">&#34;tea&#34;</span> <span class="p">|</span> quote <span class="o">}}</span>
  food: <span class="o">{{</span> .Values.favorite.food <span class="p">|</span> upper <span class="p">|</span> quote <span class="o">}}</span>
  <span class="o">{{</span>- <span class="k">if</span> eq .Values.favorite.drink <span class="s2">&#34;coffee&#34;</span><span class="o">}}</span>
  mug: <span class="nb">true</span>
  <span class="o">{{</span>- end<span class="o">}}</span>
</code></pre></td></tr></table>
</div>
</div><p>Just for the sake of making this point clear, let’s adjust the above, and substitute an <code>*</code> for each whitespace that will be deleted following this rule. an <code>*</code> at the end of the line indicates a newline character that would be removed</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">apiVersion: v1
kind: ConfigMap
metadata:
  name: <span class="o">{{</span> .Release.Name <span class="o">}}</span>-configmap
data:
  myvalue: <span class="s2">&#34;Hello World&#34;</span>
  drink: <span class="o">{{</span> .Values.favorite.drink <span class="p">|</span> default <span class="s2">&#34;tea&#34;</span> <span class="p">|</span> quote <span class="o">}}</span>
  food: <span class="o">{{</span> .Values.favorite.food <span class="p">|</span> upper <span class="p">|</span> quote <span class="o">}}</span>*
**<span class="o">{{</span>- <span class="k">if</span> eq .Values.favorite.drink <span class="s2">&#34;coffee&#34;</span><span class="o">}}</span>
  mug: true*
**<span class="o">{{</span>- end<span class="o">}}</span>
</code></pre></td></tr></table>
</div>
</div><p>Keeping that in mind, we can run our template through Helm and see the result:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># Source: mychart/templates/configmap.yaml</span>
apiVersion: v1
kind: ConfigMap
metadata:
  name: clunky-cat-configmap
data:
  myvalue: <span class="s2">&#34;Hello World&#34;</span>
  drink: <span class="s2">&#34;coffee&#34;</span>
  food: <span class="s2">&#34;PIZZA&#34;</span>
  mug: <span class="nb">true</span>
</code></pre></td></tr></table>
</div>
</div><p>Be careful with the chomping modifiers. It is easy to accidentally do things like this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">  food: <span class="o">{{</span> .Values.favorite.food <span class="p">|</span> upper <span class="p">|</span> quote <span class="o">}}</span>
  <span class="o">{{</span>- <span class="k">if</span> eq .Values.favorite.drink <span class="s2">&#34;coffee&#34;</span> -<span class="o">}}</span>
  mug: <span class="nb">true</span>
  <span class="o">{{</span>- end -<span class="o">}}</span>

</code></pre></td></tr></table>
</div>
</div><p>That will produce <code>food: &quot;PIZZA&quot;mug:true</code> because it consumed newlines on both sides.</p>
<p>For the details on whitespace control in templates, see the <a href="https://godoc.org/text/template" target="_blank" rel="noopener noreffer">Official Go template documentation</a></p>
<p>Finally, sometimes it’s easier to tell the template system how to indent(缩进) for you instead of trying to master the spacing of template directives. For that reason, you may sometimes find it useful to use the <code>indent</code> function (<code>{{indent 2 &quot;mug:true&quot;}}</code>).</p>
<h4 id="modifying-scope-using-with">MODIFYING SCOPE USING <code>WITH</code></h4>
<p>The next control structure to look at is the <code>with</code> action. This controls variable scoping. Recall that <code>.</code> is a reference to the current scope. So <code>.Values</code> tells the template to find the <code>Values</code> object in the current scope.</p>
<p>The syntax for <code>with</code> is similar to a simple <code>if</code> statement:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">{{</span> with PIPELINE <span class="o">}}</span>
  <span class="c1"># restricted scope</span>
<span class="o">{{</span> end <span class="o">}}</span>
</code></pre></td></tr></table>
</div>
</div><p>Scopes can be changed. <code>with</code> can allow you to set the current scope (<code>.</code>) to a particular object. For example, we’ve been working with <code>.Values.favorites</code>. Let’s rewrite our ConfigMap to alter the <code>.</code> scope to point to <code>.Values.favorites</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">apiVersion: v1
kind: ConfigMap
metadata:
  name: <span class="o">{{</span> .Release.Name <span class="o">}}</span>-configmap
data:
  myvalue: <span class="s2">&#34;Hello World&#34;</span>
  <span class="o">{{</span>- with .Values.favorite <span class="o">}}</span>
  drink: <span class="o">{{</span> .drink <span class="p">|</span> default <span class="s2">&#34;tea&#34;</span> <span class="p">|</span> quote <span class="o">}}</span>
  food: <span class="o">{{</span> .food <span class="p">|</span> upper <span class="p">|</span> quote <span class="o">}}</span>
  <span class="o">{{</span>- end <span class="o">}}</span>
</code></pre></td></tr></table>
</div>
</div><p>(Note that we removed the <code>if</code> conditional from the previous exercise)</p>
<p>Notice that now we can reference <code>.drink</code> and <code>.food</code> without qualifying them. That is because the <code>with</code> statement sets <code>.</code> to point to <code>.Values.favorite</code>. The <code>.</code> is reset to its previous scope after <code>{{ end }}</code>.</p>
<p>But here’s a note of caution! Inside of the restricted scope, you will not be able to access the other objects from the parent scope. This, for example, will fail:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="o">{{</span>- with .Values.favorite <span class="o">}}</span>
  drink: <span class="o">{{</span> .drink <span class="p">|</span> default <span class="s2">&#34;tea&#34;</span> <span class="p">|</span> quote <span class="o">}}</span>
  food: <span class="o">{{</span> .food <span class="p">|</span> upper <span class="p">|</span> quote <span class="o">}}</span>
  release: <span class="o">{{</span> .Release.Name <span class="o">}}</span>
  <span class="o">{{</span>- end <span class="o">}}</span>
</code></pre></td></tr></table>
</div>
</div><p>It will produce an error because <code>Release.Name</code> is not inside of the restricted scope for <code>.</code>. However, if we swap the last two lines, all will work as expected because the scope is reset after <code>{{end}}</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="o">{{</span>- with .Values.favorite <span class="o">}}</span>
  drink: <span class="o">{{</span> .drink <span class="p">|</span> default <span class="s2">&#34;tea&#34;</span> <span class="p">|</span> quote <span class="o">}}</span>
  food: <span class="o">{{</span> .food <span class="p">|</span> upper <span class="p">|</span> quote <span class="o">}}</span>
  <span class="o">{{</span>- end <span class="o">}}</span>
  release: <span class="o">{{</span> .Release.Name <span class="o">}}</span>
</code></pre></td></tr></table>
</div>
</div><p>After looking at <code>range</code>, we will take a look at template variables, which offers one solution to the scoping issue above.</p>
<h4 id="looping-with-the-range-action">LOOPING WITH THE <code>RANGE</code> ACTION</h4>
<p>Many programming languages have support <code>for</code> looping using for loops, <code>foreach</code> loops, or similar functional mechanisms. In Helm’s template language, the way to iterate(重复) through a collection is to use the <code>range</code> operator.</p>
<p>To start, let’s add a list of pizza toppings to our <code>values.yaml</code> file:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">favorite:
  drink: coffee
  food: pizza
pizzaToppings:
  - mushrooms
  - cheese
  - peppers
  - onions
</code></pre></td></tr></table>
</div>
</div><p>Now we have a list (called a <code>slice</code> in templates) of <code>pizzaToppings</code>. We can modify our template to print this list into our ConfigMap:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">apiVersion: v1
kind: ConfigMap
metadata:
  name: <span class="o">{{</span> .Release.Name <span class="o">}}</span>-configmap
data:
  myvalue: <span class="s2">&#34;Hello World&#34;</span>
  <span class="o">{{</span>- with .Values.favorite <span class="o">}}</span>
  drink: <span class="o">{{</span> .drink <span class="p">|</span> default <span class="s2">&#34;tea&#34;</span> <span class="p">|</span> quote <span class="o">}}</span>
  food: <span class="o">{{</span> .food <span class="p">|</span> upper <span class="p">|</span> quote <span class="o">}}</span>
  <span class="o">{{</span>- end <span class="o">}}</span>
  toppings: <span class="p">|</span>-
    <span class="o">{{</span>- range .Values.pizzaToppings <span class="o">}}</span>
    - <span class="o">{{</span> . <span class="p">|</span> title <span class="p">|</span> quote <span class="o">}}</span>
    <span class="o">{{</span>- end <span class="o">}}</span>
</code></pre></td></tr></table>
</div>
</div><p>Let’s take a closer look at the <code>toppings</code>: list. The <code>range</code> function will “range over” (iterate through) the <code>pizzaToppings</code> list. But now something interesting happens. Just like <code>with</code> sets the scope of ., so does a <code>range</code> operator. Each time through the loop, . is set to the current pizza topping. That is, the first time, <code>.</code> is set to <code>mushrooms</code>. The second iteration it is set to <code>cheese</code>, and so on.</p>
<p>We can send the value of <code>.</code> directly down a pipeline, so when we do <code>{{ . | title | quote }}</code>, it sends <code>.</code> to <code>title</code> (title case function) and then to <code>quote</code>. If we run this template, the output will be:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># Source: mychart/templates/configmap.yaml</span>
apiVersion: v1
kind: ConfigMap
metadata:
  name: edgy-dragonfly-configmap
data:
  myvalue: <span class="s2">&#34;Hello World&#34;</span>
  drink: <span class="s2">&#34;coffee&#34;</span>
  food: <span class="s2">&#34;PIZZA&#34;</span>
  toppings: <span class="p">|</span>-
    - <span class="s2">&#34;Mushrooms&#34;</span>
    - <span class="s2">&#34;Cheese&#34;</span>
    - <span class="s2">&#34;Peppers&#34;</span>
    - <span class="s2">&#34;Onions&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>Now, in this example we’ve done something tricky(棘手的). The <code>toppings: |-</code> line is declaring a multi-line string. So our list of toppings is actually not a YAML list. It’s a big string. Why would we do this? Because the data in ConfigMaps <code>data</code> is composed of key/value pairs, where both the key and the value are simple strings. To understand why this is the case, take a look at the <a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/" target="_blank" rel="noopener noreffer">Kubernetes ConfigMap docs</a>. For us, though, this detail doesn’t matter much.</p>
<blockquote>
<p>The <code>|-</code> marker in YAML takes a multi-line string. This can be a useful technique for embedding big blocks of data inside of your manifests, as exemplified here.</p>
</blockquote>
<p>Sometimes it’s useful to be able to quickly make a list inside of your template, and then iterate over that list. Helm templates have a function that’s called just that: <code>list</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">  sizes: <span class="p">|</span>-
    <span class="o">{{</span>- range list <span class="s2">&#34;small&#34;</span> <span class="s2">&#34;medium&#34;</span> <span class="s2">&#34;large&#34;</span> <span class="o">}}</span>
    - <span class="o">{{</span> . <span class="o">}}</span>
    <span class="o">{{</span>- end <span class="o">}}</span>
</code></pre></td></tr></table>
</div>
</div><p>The above will produce this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">  sizes: <span class="p">|</span>-
    - small
    - medium
    - large
</code></pre></td></tr></table>
</div>
</div><p>In addition to lists, <code>range</code> can be used to iterate over collections that have a key and a value (like a <code>map</code> or <code>dict</code>). We’ll see how to do that in the next section when we introduce template variables.</p>
<h3 id="variables">Variables</h3>
<p>With functions, pipelines, objects, and control structures under our belts, we can turn to one of the more basic ideas in many programming languages: variables. In templates, they are less frequently used. But we will see how to use them to simplify code, and to make better use of <code>with</code> and <code>range</code>.</p>
<p>In an earlier example, we saw that this code will fail:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="o">{{</span>- with .Values.favorite <span class="o">}}</span>
  drink: <span class="o">{{</span> .drink <span class="p">|</span> default <span class="s2">&#34;tea&#34;</span> <span class="p">|</span> quote <span class="o">}}</span>
  food: <span class="o">{{</span> .food <span class="p">|</span> upper <span class="p">|</span> quote <span class="o">}}</span>
  release: <span class="o">{{</span> .Release.Name <span class="o">}}</span>
  <span class="o">{{</span>- end <span class="o">}}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>Release.Name</code> is not inside of the scope that’s restricted in the <code>with</code> block. One way to work around scoping issues is to assign objects to variables that can be accessed without respect to the present scope.</p>
<p>In Helm templates, a variable is a named reference to another object. It follows the form <code>$name</code>. Variables are assigned with a special assignment operator: <code>:=</code>. We can rewrite the above to use a variable for <code>Release.Name</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">apiVersion: v1
kind: ConfigMap
metadata:
  name: <span class="o">{{</span> .Release.Name <span class="o">}}</span>-configmap
data:
  myvalue: <span class="s2">&#34;Hello World&#34;</span>
  <span class="o">{{</span>- <span class="nv">$relname</span> :<span class="o">=</span> .Release.Name -<span class="o">}}</span>
  <span class="o">{{</span>- with .Values.favorite <span class="o">}}</span>
  drink: <span class="o">{{</span> .drink <span class="p">|</span> default <span class="s2">&#34;tea&#34;</span> <span class="p">|</span> quote <span class="o">}}</span>
  food: <span class="o">{{</span> .food <span class="p">|</span> upper <span class="p">|</span> quote <span class="o">}}</span>
  release: <span class="o">{{</span> <span class="nv">$relname</span> <span class="o">}}</span>
  <span class="o">{{</span>- end <span class="o">}}</span>
</code></pre></td></tr></table>
</div>
</div><p>Notice that before we start the <code>with</code> block, we assign <code>$relname := .Release.Name</code>. Now inside of the <code>with</code> block, the <code>$relname</code> variable still points to the release name.</p>
<p>Running that will produce this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># Source: mychart/templates/configmap.yaml</span>
apiVersion: v1
kind: ConfigMap
metadata:
  name: viable-badger-configmap
data:
  myvalue: <span class="s2">&#34;Hello World&#34;</span>
  drink: <span class="s2">&#34;coffee&#34;</span>
  food: <span class="s2">&#34;PIZZA&#34;</span>
  release: viable-badger
</code></pre></td></tr></table>
</div>
</div><p>Variables are particularly useful in <code>range</code> loops. They can be used on list-like objects to capture both the index and the value:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">  toppings: <span class="p">|</span>-
    <span class="o">{{</span>- range <span class="nv">$index</span>, <span class="nv">$topping</span> :<span class="o">=</span> .Values.pizzaToppings <span class="o">}}</span>
      <span class="o">{{</span> <span class="nv">$index</span> <span class="o">}}</span>: <span class="o">{{</span> <span class="nv">$topping</span> <span class="o">}}</span>
    <span class="o">{{</span>- end <span class="o">}}</span>
</code></pre></td></tr></table>
</div>
</div><p>Note that <code>range</code> comes first, then the variables, then the assignment operator, then the list. This will assign the integer index (starting from zero) to <code>$index</code> and the value to <code>$topping</code>. Running it will produce:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">  toppings: <span class="p">|</span>-
      0: mushrooms
      1: cheese
      2: peppers
      3: onions
</code></pre></td></tr></table>
</div>
</div><p>For data structures that have both a key and a value, we can use <code>range</code> to get both. For example, we can loop through <code>.Values.favorite</code> like this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">apiVersion: v1
kind: ConfigMap
metadata:
  name: <span class="o">{{</span> .Release.Name <span class="o">}}</span>-configmap
data:
  myvalue: <span class="s2">&#34;Hello World&#34;</span>
  <span class="o">{{</span>- range <span class="nv">$key</span>, <span class="nv">$val</span> :<span class="o">=</span> .Values.favorite <span class="o">}}</span>
  <span class="o">{{</span> <span class="nv">$key</span> <span class="o">}}</span>: <span class="o">{{</span> <span class="nv">$val</span> <span class="p">|</span> quote <span class="o">}}</span>
  <span class="o">{{</span>- end<span class="o">}}</span>
</code></pre></td></tr></table>
</div>
</div><p>Now on the first iteration, <code>$key</code> will be <code>drink</code> and <code>$val</code> will be <code>coffee</code>, and on the second, <code>$key</code> will be <code>food</code> and <code>$val</code> will be <code>pizza</code>. Running the above will generate this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># Source: mychart/templates/configmap.yaml</span>
apiVersion: v1
kind: ConfigMap
metadata:
  name: eager-rabbit-configmap
data:
  myvalue: <span class="s2">&#34;Hello World&#34;</span>
  drink: <span class="s2">&#34;coffee&#34;</span>
  food: <span class="s2">&#34;pizza&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>Variables are normally not “global”. They are scoped to the block in which they are declared. Earlier, we assigned <code>$relname</code> in the top level of the template. That variable will be in scope for the entire template. But in our last example, <code>$key</code> and <code>$val</code> will only be in scope inside of the <code>{{range...}}{{end}}</code> block.</p>
<p>However, there is one variable that is always global - <code>$</code> - this variable will always point to the root context. This can be very useful when you are looping in a range and need to know the chart’s release name.</p>
<p>An example illustrating this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">{{</span>- range .Values.tlsSecrets <span class="o">}}</span>
apiVersion: v1
kind: Secret
metadata:
  name: <span class="o">{{</span> .name <span class="o">}}</span>
  labels:
    <span class="c1"># Many helm templates would use `.` below, but that will not work,</span>
    <span class="c1"># however `$` will work here</span>
    app.kubernetes.io/name: <span class="o">{{</span> template <span class="s2">&#34;fullname&#34;</span> $ <span class="o">}}</span>
    <span class="c1"># I cannot reference .Chart.Name, but I can do $.Chart.Name</span>
    helm.sh/chart: <span class="s2">&#34;{{ </span>$<span class="s2">.Chart.Name }}-{{ </span>$<span class="s2">.Chart.Version }}&#34;</span>
    app.kubernetes.io/instance: <span class="s2">&#34;{{ </span>$<span class="s2">.Release.Name }}&#34;</span>
    <span class="c1"># Value from appVersion in Chart.yaml</span>
    app.kubernetes.io/version: <span class="s2">&#34;{{ </span>$<span class="s2">.Chart.AppVersion }}&#34;</span>
    app.kubernetes.io/managed-by: <span class="s2">&#34;{{ </span>$<span class="s2">.Release.Service }}&#34;</span>
type: kubernetes.io/tls
data:
  tls.crt: <span class="o">{{</span> .certificate <span class="o">}}</span>
  tls.key: <span class="o">{{</span> .key <span class="o">}}</span>
---
<span class="o">{{</span>- end <span class="o">}}</span>
</code></pre></td></tr></table>
</div>
</div><p>So far we have looked at just one template declared in just one file. But one of the powerful features of the Helm template language is its ability to declare multiple templates and use them together. We’ll turn to that in the next section.</p>
<h3 id="named-templates">Named Templates</h3>
<p>It is time to move beyond one template, and begin to create others. In this section, we will see how to define <em><strong>named templates</strong></em> in one file, and then use them elsewhere. A <em><strong>named template</strong></em> (sometimes called a <em><strong>partial</strong></em> or a <em><strong>subtemplate</strong></em>) is simply a template defined inside of a file, and given a name. We’ll see two ways to create them, and a few different ways to use them.</p>
<p>In the “Flow Control” section we introduced three actions for declaring and managing templates: <code>define</code>, <code>template</code>, and <code>block</code>. In this section, we’ll cover those three actions, and also introduce a special-purpose <code>include</code> function that works similarly to the <code>template</code> action.</p>
<p>An important detail to keep in mind when naming templates: <strong>template names are global</strong>. If you declare two templates with the same name, whichever one is loaded last will be the one used. Because templates in subcharts are compiled together with top-level templates, you should be careful to name your templates with <strong>chart-specific names</strong>.</p>
<p>One popular naming convention is to prefix each defined template with the name of the chart: <code>{{ define &quot;mychart.labels&quot; }}</code>. By using the specific chart name as a prefix we can avoid any conflicts that may arise due to two different charts that implement templates of the same name.</p>
<h4 id="partials-and-_-files">PARTIALS AND <code>_</code> FILES</h4>
<p>So far, we’ve used one file, and that one file has contained a single template. But Helm’s template language allows you to create named embedded templates, that can be accessed by name elsewhere.</p>
<p>Before we get to the nuts-and-bolts(螺母和螺栓) of writing those templates, there is file naming convention that deserves mention:</p>
<ul>
<li>Most files in <code>templates/</code> are treated as if they contain Kubernetes manifests</li>
<li>The <code>NOTES.txt</code> is one exception</li>
<li>But files whose name begins with an underscore (<code>_</code>) are assumed to <em><strong>not</strong></em> have a manifest inside. These files are not rendered to Kubernetes object definitions, but are available everywhere within other chart templates for use.</li>
</ul>
<p>These files are used to store partials and helpers. In fact, when we first created <code>mychart</code>, we saw a file called <code>_helpers.tpl</code>. That file is the default location for template partials.</p>
<h4 id="declaring-and-using-templates-with-define-and-template">DECLARING AND USING TEMPLATES WITH <code>DEFINE</code> AND <code>TEMPLATE</code></h4>
<p>The <code>define</code> action allows us to create a named template inside of a template file. Its syntax goes like this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">{{</span> define <span class="s2">&#34;MY.NAME&#34;</span> <span class="o">}}</span>
  <span class="c1"># body of template here</span>
<span class="o">{{</span> end <span class="o">}}</span>
</code></pre></td></tr></table>
</div>
</div><p>For example, we can define a template to encapsulate(封装) a Kubernetes block of labels:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">{{</span>- define <span class="s2">&#34;mychart.labels&#34;</span> <span class="o">}}</span>
  labels:
    generator: helm
    date: <span class="o">{{</span> now <span class="p">|</span> htmlDate <span class="o">}}</span>
<span class="o">{{</span>- end <span class="o">}}</span>
</code></pre></td></tr></table>
</div>
</div><p>Now we can embed this template inside of our existing ConfigMap, and then include it with the <code>template</code> action:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">{{</span>- define <span class="s2">&#34;mychart.labels&#34;</span> <span class="o">}}</span>
  labels:
    generator: helm
    date: <span class="o">{{</span> now <span class="p">|</span> htmlDate <span class="o">}}</span>
<span class="o">{{</span>- end <span class="o">}}</span>
apiVersion: v1
kind: ConfigMap
metadata:
  name: <span class="o">{{</span> .Release.Name <span class="o">}}</span>-configmap
  <span class="o">{{</span>- template <span class="s2">&#34;mychart.labels&#34;</span> <span class="o">}}</span>
data:
  myvalue: <span class="s2">&#34;Hello World&#34;</span>
  <span class="o">{{</span>- range <span class="nv">$key</span>, <span class="nv">$val</span> :<span class="o">=</span> .Values.favorite <span class="o">}}</span>
  <span class="o">{{</span> <span class="nv">$key</span> <span class="o">}}</span>: <span class="o">{{</span> <span class="nv">$val</span> <span class="p">|</span> quote <span class="o">}}</span>
  <span class="o">{{</span>- end <span class="o">}}</span>
</code></pre></td></tr></table>
</div>
</div><p>When the template engine reads this file, it will store away the reference to <code>mychart.labels</code> until <code>template &quot;mychart.labels&quot;</code> is called. Then it will render that template inline. So the result will look like this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># Source: mychart/templates/configmap.yaml</span>
apiVersion: v1
kind: ConfigMap
metadata:
  name: running-panda-configmap
  labels:
    generator: helm
    date: 2016-11-02
data:
  myvalue: <span class="s2">&#34;Hello World&#34;</span>
  drink: <span class="s2">&#34;coffee&#34;</span>
  food: <span class="s2">&#34;pizza&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>Conventionally(按照惯例), Helm charts put these templates inside of a partials file, usually <code>_helpers.tpl</code>. Let’s move this function there:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">{{</span>/* Generate basic labels */<span class="o">}}</span>
<span class="o">{{</span>- define <span class="s2">&#34;mychart.labels&#34;</span> <span class="o">}}</span>
  labels:
    generator: helm
    date: <span class="o">{{</span> now <span class="p">|</span> htmlDate <span class="o">}}</span>
<span class="o">{{</span>- end <span class="o">}}</span>
</code></pre></td></tr></table>
</div>
</div><p>By convention, <code>define</code> functions should have a simple documentation block (<code>{{/* ... */}}</code>) describing what they do.</p>
<p>Even though this definition is in <code>_helpers.tpl</code>, it can still be accessed in <code>configmap.yaml</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">apiVersion: v1
kind: ConfigMap
metadata:
  name: <span class="o">{{</span> .Release.Name <span class="o">}}</span>-configmap
  <span class="o">{{</span>- template <span class="s2">&#34;mychart.labels&#34;</span> <span class="o">}}</span>
data:
  myvalue: <span class="s2">&#34;Hello World&#34;</span>
  <span class="o">{{</span>- range <span class="nv">$key</span>, <span class="nv">$val</span> :<span class="o">=</span> .Values.favorite <span class="o">}}</span>
  <span class="o">{{</span> <span class="nv">$key</span> <span class="o">}}</span>: <span class="o">{{</span> <span class="nv">$val</span> <span class="p">|</span> quote <span class="o">}}</span>
  <span class="o">{{</span>- end <span class="o">}}</span>
</code></pre></td></tr></table>
</div>
</div><p>As mentioned above, <strong>template names are global</strong>. As a result of this, if two templates are declared with the same name the last occurrence will be the one that is used. Since templates in subcharts are compiled together with top-level templates, it is best to name your templates with chart specific names. A popular naming convention is to prefix each defined template with the name of the chart: <code>{{ define &quot;mychart.labels&quot; }}</code>.</p>
<h4 id="setting-the-scope-of-a-template">SETTING THE SCOPE OF A TEMPLATE</h4>
<p>In the template we defined above, we did not use any objects. We just used functions. Let’s modify our defined template to include the chart name and chart version:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">{{</span>/* Generate basic labels */<span class="o">}}</span>
<span class="o">{{</span>- define <span class="s2">&#34;mychart.labels&#34;</span> <span class="o">}}</span>
  labels:
    generator: helm
    date: <span class="o">{{</span> now <span class="p">|</span> htmlDate <span class="o">}}</span>
    chart: <span class="o">{{</span> .Chart.Name <span class="o">}}</span>
    version: <span class="o">{{</span> .Chart.Version <span class="o">}}</span>
<span class="o">{{</span>- end <span class="o">}}</span>
</code></pre></td></tr></table>
</div>
</div><p>If we render this, the result will not be what we expect:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># Source: mychart/templates/configmap.yaml</span>
apiVersion: v1
kind: ConfigMap
metadata:
  name: moldy-jaguar-configmap
  labels:
    generator: helm
    date: 2016-11-02
    chart:
    version:
</code></pre></td></tr></table>
</div>
</div><p>What happened to the name and version? They weren’t in the scope for our defined template. When a named template (created with <code>define</code>) is rendered, it will receive the scope passed in by the <code>template</code> call. In our example, we included the template like this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">{{</span>- template <span class="s2">&#34;mychart.labels&#34;</span> <span class="o">}}</span>
</code></pre></td></tr></table>
</div>
</div><p>No scope was passed in, so within the template we cannot access anything in <code>.</code>. This is easy enough to fix, though. We simply pass a scope to the template:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">apiVersion: v1
kind: ConfigMap
metadata:
  name: <span class="o">{{</span> .Release.Name <span class="o">}}</span>-configmap
  <span class="o">{{</span>- template <span class="s2">&#34;mychart.labels&#34;</span> . <span class="o">}}</span>
</code></pre></td></tr></table>
</div>
</div><p>Note that we pass <code>.</code> at the end of the <code>template</code> call. We could just as easily pass <code>.Values</code> or <code>.Values.favorite</code> or whatever scope we want. But what we want is the top-level scope.</p>
<p>Now when we execute this template with <code>helm install --dry-run --debug ./mychart</code>, we get this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># Source: mychart/templates/configmap.yaml</span>
apiVersion: v1
kind: ConfigMap
metadata:
  name: plinking-anaco-configmap
  labels:
    generator: helm
    date: 2016-11-02
    chart: mychart
    version: 0.1.0
</code></pre></td></tr></table>
</div>
</div><p>Now <code>{{ .Chart.Name }}</code> resolves to <code>mychart</code>, and <code>{{ .Chart.Version }}</code> resolves to <code>0.1.0</code>.</p>
<h4 id="the-include-function">THE <code>INCLUDE</code> FUNCTION</h4>
<p>Say we’ve defined a simple template that looks like this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">{{</span>- define <span class="s2">&#34;mychart.app&#34;</span> -<span class="o">}}</span>
app_name: <span class="o">{{</span> .Chart.Name <span class="o">}}</span>
app_version: <span class="s2">&#34;{{ .Chart.Version }}+{{ .Release.Time.Seconds }}&#34;</span>
<span class="o">{{</span>- end -<span class="o">}}</span>
</code></pre></td></tr></table>
</div>
</div><p>Now say I want to insert this both into the <code>labels:</code> section of my template, and also the <code>data:</code> section:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">apiVersion: v1
kind: ConfigMap
metadata:
  name: <span class="o">{{</span> .Release.Name <span class="o">}}</span>-configmap
  labels:
    <span class="o">{{</span> template <span class="s2">&#34;mychart.app&#34;</span> .<span class="o">}}</span>
data:
  myvalue: <span class="s2">&#34;Hello World&#34;</span>
  <span class="o">{{</span>- range <span class="nv">$key</span>, <span class="nv">$val</span> :<span class="o">=</span> .Values.favorite <span class="o">}}</span>
  <span class="o">{{</span> <span class="nv">$key</span> <span class="o">}}</span>: <span class="o">{{</span> <span class="nv">$val</span> <span class="p">|</span> quote <span class="o">}}</span>
  <span class="o">{{</span>- end <span class="o">}}</span>
<span class="o">{{</span> template <span class="s2">&#34;mychart.app&#34;</span> . <span class="o">}}</span>
</code></pre></td></tr></table>
</div>
</div><p>The output will not be what we expect:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># Source: mychart/templates/configmap.yaml</span>
apiVersion: v1
kind: ConfigMap
metadata:
  name: measly-whippet-configmap
  labels:
    app_name: mychart
app_version: <span class="s2">&#34;0.1.0+1478129847&#34;</span>
data:
  myvalue: <span class="s2">&#34;Hello World&#34;</span>
  drink: <span class="s2">&#34;coffee&#34;</span>
  food: <span class="s2">&#34;pizza&#34;</span>
app_name: mychart
app_version: <span class="s2">&#34;0.1.0+1478129847&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>Note that the indentation on <code>app_version</code> is wrong in both places. Why? Because the template that is substituted(替代的) in has the text aligned to the right. Because <code>template</code> is an action, and not a function, there is no way to pass the output of a <code>template</code> call to other functions; the data is simply inserted inline.</p>
<p>To work around this case, Helm provides an alternative to <code>template</code> that will import the contents of a template into the present pipeline where it can be passed along to other functions in the pipeline.</p>
<p>Here’s the example above, corrected to use <code>nindent</code> to indent the <code>mychart_app</code> template correctly:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">apiVersion: v1
kind: ConfigMap
metadata:
  name: <span class="o">{{</span> .Release.Name <span class="o">}}</span>-configmap
  labels:
    <span class="o">{{</span>- include <span class="s2">&#34;mychart.app&#34;</span> . <span class="p">|</span> nindent <span class="m">4</span> <span class="o">}}</span>
data:
  myvalue: <span class="s2">&#34;Hello World&#34;</span>
  <span class="o">{{</span>- range <span class="nv">$key</span>, <span class="nv">$val</span> :<span class="o">=</span> .Values.favorite <span class="o">}}</span>
  <span class="o">{{</span> <span class="nv">$key</span> <span class="o">}}</span>: <span class="o">{{</span> <span class="nv">$val</span> <span class="p">|</span> quote <span class="o">}}</span>
  <span class="o">{{</span>- end <span class="o">}}</span>
  <span class="o">{{</span>- include <span class="s2">&#34;mychart.app&#34;</span> . <span class="p">|</span> nindent <span class="m">2</span> <span class="o">}}</span>
</code></pre></td></tr></table>
</div>
</div><p>Now the produced YAML is correctly indented for each section:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># Source: mychart/templates/configmap.yaml</span>
apiVersion: v1
kind: ConfigMap
metadata:
  name: edgy-mole-configmap
  labels:
    app_name: mychart
    app_version: <span class="s2">&#34;0.1.0+1478129987&#34;</span>
data:
  myvalue: <span class="s2">&#34;Hello World&#34;</span>
  drink: <span class="s2">&#34;coffee&#34;</span>
  food: <span class="s2">&#34;pizza&#34;</span>
  app_name: mychart
  app_version: <span class="s2">&#34;0.1.0+1478129987&#34;</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>It is considered preferable to use <code>include</code> over <code>template</code> in Helm templates simply so that the output formatting can be handled better for YAML documents.</p>
</blockquote>
<p>Sometimes we want to import content, but not as templates. That is, we want to import files verbatim(逐字). We can achieve this by accessing files through the <code>.Files</code> object described in the next section.</p>
<h3 id="accessing-files-inside-templates">Accessing Files Inside Templates</h3>
<p>In the previous section we looked at several ways to create and access named templates. This makes it easy to import one template from within another template. But sometimes it is desirable to import a <em><strong>file that is not a template</strong></em> and inject its contents without sending the contents through the template renderer.</p>
<p>Helm provides access to files through the <code>.Files</code> object. Before we get going with the template examples, though, there are a few things to note about how this works:</p>
<ul>
<li>
<p>It is okay to add extra files to your Helm chart. These files will be bundled and sent to Tiller. Be careful, though. Charts must be smaller than 1M because of the storage limitations of Kubernetes objects.</p>
</li>
<li>
<p>Some files cannot be accessed through the <code>.Files</code> object, usually for security reasons.</p>
<ul>
<li>Files in <code>templates/</code> cannot be accessed.</li>
<li>Files excluded using <code>.helmignore</code> cannot be accessed.</li>
</ul>
</li>
<li>
<p>Charts do not preserve(保留) UNIX mode information, so file-level permissions will have no impact on the availability of a file when it comes to the <code>.Files</code> object.</p>
</li>
<li>
<p><a href="https://helm.sh/docs/chart_template_guide/#basic-example" target="_blank" rel="noopener noreffer">Basic example</a></p>
</li>
<li>
<p><a href="https://helm.sh/docs/chart_template_guide/#path-helpers" target="_blank" rel="noopener noreffer">Path helpers</a></p>
</li>
<li>
<p><a href="https://helm.sh/docs/chart_template_guide/#glob-patterns" target="_blank" rel="noopener noreffer">Glob patterns</a></p>
</li>
<li>
<p><a href="https://helm.sh/docs/chart_template_guide/#configmap-and-secrets-utility-functions" target="_blank" rel="noopener noreffer">ConfigMap and Secrets utility functions</a></p>
</li>
<li>
<p><a href="https://helm.sh/docs/chart_template_guide/#encoding" target="_blank" rel="noopener noreffer">Encoding</a></p>
</li>
<li>
<p><a href="https://helm.sh/docs/chart_template_guide/#lines" target="_blank" rel="noopener noreffer">Lines</a></p>
</li>
</ul>
<h4 id="basic-example">BASIC EXAMPLE</h4>
<p>With those caveats(注意事项) behind, let’s write a template that reads three files into our ConfigMap. To get started, we will add three files to the chart, putting all three directly inside of the <code>mychart/</code> directory.</p>
<p><code>config1.toml</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="nv">message</span> <span class="o">=</span> <span class="s2">&#34;Hello from config 1&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p><code>config2.toml</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="nv">message</span> <span class="o">=</span> <span class="s2">&#34;This is config 2&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p><code>config3.toml</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="nv">message</span> <span class="o">=</span> <span class="s2">&#34;Goodbye from config 3&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>Each of these is a simple TOML file (think old-school Windows INI files). We know the names of these files, so we can use a <code>range</code> function to loop through them and inject their contents into our ConfigMap.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">apiVersion: v1
kind: ConfigMap
metadata:
  name: <span class="o">{{</span> .Release.Name <span class="o">}}</span>-configmap
data:
  <span class="o">{{</span>- <span class="nv">$files</span> :<span class="o">=</span> .Files <span class="o">}}</span>
  <span class="o">{{</span>- range list <span class="s2">&#34;config1.toml&#34;</span> <span class="s2">&#34;config2.toml&#34;</span> <span class="s2">&#34;config3.toml&#34;</span> <span class="o">}}</span>
  <span class="o">{{</span> . <span class="o">}}</span>: <span class="p">|</span>-
    <span class="o">{{</span> <span class="nv">$files</span>.Get . <span class="o">}}</span>
  <span class="o">{{</span>- end <span class="o">}}</span>
</code></pre></td></tr></table>
</div>
</div><p>This config map uses several of the techniques discussed in previous sections. For example, we create a <code>$files</code> variable to hold a reference to the <code>.Files</code> object. We also use the <code>list</code> function to create a list of files that we loop through. Then we print each file name (<code>{{.}}: |-</code>) followed by the contents of the file <code>{{ $files.Get . }}</code>.</p>
<p>Running this template will produce a single ConfigMap with the contents of all three files:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># Source: mychart/templates/configmap.yaml</span>
apiVersion: v1
kind: ConfigMap
metadata:
  name: quieting-giraf-configmap
data:
  config1.toml: <span class="p">|</span>-
    <span class="nv">message</span> <span class="o">=</span> <span class="s2">&#34;Hello from config 1&#34;</span>

  config2.toml: <span class="p">|</span>-
    <span class="nv">message</span> <span class="o">=</span> <span class="s2">&#34;This is config 2&#34;</span>

  config3.toml: <span class="p">|</span>-
    <span class="nv">message</span> <span class="o">=</span> <span class="s2">&#34;Goodbye from config 3&#34;</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="path-helpers">PATH HELPERS</h4>
<p>When working with files, it can be very useful to perform some standard operations on the file paths themselves. To help with this, Helm imports many of the functions from Go’s <a href="https://golang.org/pkg/path/" target="_blank" rel="noopener noreffer">path</a> package for your use. They are all accessible with the same names as in the Go package, but with a lowercase first letter. For example, <code>Base</code> becomes <code>base</code>, etc.</p>
<p>The imported functions are:</p>
<ul>
<li>Base</li>
<li>Dir</li>
<li>Ext</li>
<li>IsAbs</li>
<li>Clean</li>
</ul>
<h4 id="glob-patterns">GLOB PATTERNS</h4>
<p>As your chart grows, you may find you have a greater need to organize your files more, and so we provide a <code>Files.Glob(pattern string)</code> method to assist in extracting certain files with all the flexibility of <a href="https://godoc.org/github.com/gobwas/glob" target="_blank" rel="noopener noreffer">glob patterns</a>.</p>
<p><code>.Glob</code> returns a <code>Files</code> type, so you may call any of the <code>Files</code> methods on the returned object.</p>
<p>For example, imagine the directory structure:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">foo/:
  foo.txt foo.yaml

bar/:
  bar.go bar.conf baz.yaml
</code></pre></td></tr></table>
</div>
</div><p>You have multiple options with Globs:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">{{</span> <span class="nv">$root</span> :<span class="o">=</span> . <span class="o">}}</span>
<span class="o">{{</span> range <span class="nv">$path</span>, <span class="nv">$bytes</span> :<span class="o">=</span> .Files.Glob <span class="s2">&#34;**.yaml&#34;</span> <span class="o">}}</span>
<span class="o">{{</span> <span class="nv">$path</span> <span class="o">}}</span>: <span class="p">|</span>-
<span class="o">{{</span> <span class="nv">$root</span>.Files.Get <span class="nv">$path</span> <span class="o">}}</span>
<span class="o">{{</span> end <span class="o">}}</span>
</code></pre></td></tr></table>
</div>
</div><p>Or</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">{{</span> <span class="nv">$root</span> :<span class="o">=</span> . <span class="o">}}</span>
<span class="o">{{</span> range <span class="nv">$path</span>, <span class="nv">$bytes</span> :<span class="o">=</span> .Files.Glob <span class="s2">&#34;foo/*&#34;</span> <span class="o">}}</span>
<span class="o">{{</span> base <span class="nv">$path</span> <span class="o">}}</span>: <span class="s1">&#39;{{ $root.Files.Get $path | b64enc }}&#39;</span>
<span class="o">{{</span> end <span class="o">}}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="configmap-and-secrets-utility-functions">CONFIGMAP AND SECRETS UTILITY FUNCTIONS</h4>
<p>(Not present in version 2.0.2 or prior(之前的))</p>
<p>It is very common to want to place file content into both configmaps and secrets, for mounting into your pods at run time. To help with this, we provide a couple utility methods on the <code>Files</code> type.</p>
<p>For further organization, it is especially useful to use these methods in conjunction with the <code>Glob</code> method.</p>
<p>Given the directory structure from the <a href="https://helm.sh/docs/chart_template_guide/#glob-patterns" target="_blank" rel="noopener noreffer">Glob</a> example above:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">apiVersion: v1
kind: ConfigMap
metadata:
  name: conf
data:
  <span class="o">{{</span>- <span class="o">(</span>.Files.Glob <span class="s2">&#34;foo/*&#34;</span><span class="o">)</span>.AsConfig <span class="p">|</span> nindent <span class="m">2</span> <span class="o">}}</span>
---
apiVersion: v1
kind: Secret
metadata:
  name: very-secret
type: Opaque
data:
  <span class="o">{{</span>- <span class="o">(</span>.Files.Glob <span class="s2">&#34;bar/*&#34;</span><span class="o">)</span>.AsSecrets <span class="p">|</span> nindent <span class="m">2</span> <span class="o">}}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="encoding">ENCODING</h4>
<p>You can import a file and have the template base-64 encode it to ensure successful transmission:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">apiVersion: v1
kind: Secret
metadata:
  name: <span class="o">{{</span> .Release.Name <span class="o">}}</span>-secret
type: Opaque
data:
  token: <span class="p">|</span>-
    <span class="o">{{</span> .Files.Get <span class="s2">&#34;config1.toml&#34;</span> <span class="p">|</span> b64enc <span class="o">}}</span>
</code></pre></td></tr></table>
</div>
</div><p>The above will take the same <code>config1.toml</code> file we used before and encode it:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># Source: mychart/templates/secret.yaml</span>
apiVersion: v1
kind: Secret
metadata:
  name: lucky-turkey-secret
type: Opaque
data:
  token: <span class="p">|</span>-
    bWVzc2FnZSA9IEhlbGxvIGZyb20gY29uZmlnIDEK
</code></pre></td></tr></table>
</div>
</div><h4 id="lines">LINES</h4>
<p>Sometimes it is desirable to access each line of a file in your template. We provide a convenient <code>Lines</code> method for this.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">data:
  some-file.txt: <span class="o">{{</span> range .Files.Lines <span class="s2">&#34;foo/bar.txt&#34;</span> <span class="o">}}</span>
    <span class="o">{{</span> . <span class="o">}}{{</span> end <span class="o">}}</span>
</code></pre></td></tr></table>
</div>
</div><p>Currently, there is no way to pass files external to the chart during <code>helm install</code>. So if you are asking users to supply data, it must be loaded using <code>helm install -f</code> or <code>helm install --set</code>.</p>
<p>This discussion wraps up our dive into the tools and techniques for writing Helm templates. In the next section we will see how you can use one special file, <code>templates/NOTES.txt</code>, to send post-installation instructions to the users of your chart.</p>
<h3 id="creating-a-notestxt-file">Creating a NOTES.txt File</h3>
<p>In this section we are going to look at Helm’s tool for providing instructions to your chart users. At the end of a <code>helm install</code> or <code>helm upgrade</code>, Helm can print out a block of helpful information for users. This information is highly customizable using templates.</p>
<p>To add installation notes to your chart, simply create a <code>templates/NOTES.txt</code> file. This file is plain text, but it is processed like as a template, and has all the normal template functions and objects available.</p>
<p>Let’s create a simple <code>NOTES.txt</code> file:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-txt" data-lang="txt">Thank you for installing {{ .Chart.Name }}.

Your release is named {{ .Release.Name }}.

To learn more about the release, try:

  $ helm status {{ .Release.Name }}
  $ helm get {{ .Release.Name }}

</code></pre></td></tr></table>
</div>
</div><p>Now if we run <code>helm install ./mychart</code> we will see this message at the bottom:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">RESOURCES:
<span class="o">==</span>&gt; v1/Secret
NAME                   TYPE      DATA      AGE
rude-cardinal-secret   Opaque    <span class="m">1</span>         <span class="nv">0s</span>

<span class="o">==</span>&gt; v1/ConfigMap
NAME                      DATA      AGE
rude-cardinal-configmap   <span class="m">3</span>         0s


NOTES:
Thank you <span class="k">for</span> installing mychart.

Your release is named rude-cardinal.

To learn more about the release, try:

  $ helm status rude-cardinal
  $ helm get rude-cardinal
</code></pre></td></tr></table>
</div>
</div><p>Using <code>NOTES.txt</code> this way is a great way to give your users detailed information about how to use their newly installed chart. Creating a <code>NOTES.txt</code> file is strongly recommended, though it is not required.</p>
<h3 id="subcharts-and-global-values">Subcharts and Global Values</h3>
<p>To this point we have been working only with one chart. But charts can have dependencies, called <em><strong>subcharts</strong></em>, that also have their own values and templates. In this section we will create a subchart and see the different ways we can access values from within templates.</p>
<p>Before we dive into the code, there are a few important details to learn about subcharts.</p>
<ol>
<li>A subchart is considered “stand-alone”, which means a subchart can never explicitly(明确的) depend on its parent chart.</li>
<li>For that reason, a subchart cannot access the values of its parent.</li>
<li>A parent chart can override values for subcharts.</li>
<li>Helm has a concept of global values that can be accessed by all charts.</li>
</ol>
<p>As we walk through the examples in this section, many of these concepts will become clearer.</p>
<h4 id="creating-a-subchart">CREATING A SUBCHART</h4>
<p>For these exercises, we’ll start with the <code>mychart/</code> chart we created at the beginning of this guide, and we’ll add a new chart inside of it.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ <span class="nb">cd</span> mychart/charts
$ helm create mysubchart
Creating mysubchart
$ rm -rf mysubchart/templates/*.*
</code></pre></td></tr></table>
</div>
</div><p>Notice that just as before, we deleted all of the base templates so that we can start from scratch. In this guide, we are focused on how templates work, not on managing dependencies. But the <a href="https://helm.sh/docs/chart_template_guide/#../charts" target="_blank" rel="noopener noreffer">Charts Guide</a> has more information on how subcharts work.</p>
<h4 id="adding-values-and-a-template-to-the-subchart">ADDING VALUES AND A TEMPLATE TO THE SUBCHART</h4>
<p>Next, let’s create a simple template and values file for our <code>mysubchart</code> chart. There should already be a <code>values.yaml</code> in <code>mychart/charts/mysubchart</code>. We’ll set it up like this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">dessert: cake
</code></pre></td></tr></table>
</div>
</div><p>Next, we’ll create a new ConfigMap template in <code>mychart/charts/mysubchart/templates/configmap.yaml</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">apiVersion: v1
kind: ConfigMap
metadata:
  name: <span class="o">{{</span> .Release.Name <span class="o">}}</span>-cfgmap2
data:
  dessert: <span class="o">{{</span> .Values.dessert <span class="o">}}</span>
</code></pre></td></tr></table>
</div>
</div><p>Because every subchart is a stand-alone chart, we can test mysubchart on its own:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ helm install --dry-run --debug mychart/charts/mysubchart
SERVER: <span class="s2">&#34;localhost:44134&#34;</span>
CHART PATH: /Users/mattbutcher/Code/Go/src/k8s.io/helm/_scratch/mychart/charts/mysubchart
NAME:   newbie-elk
TARGET NAMESPACE:   default
CHART:  mysubchart 0.1.0
MANIFEST:
---
<span class="c1"># Source: mysubchart/templates/configmap.yaml</span>
apiVersion: v1
kind: ConfigMap
metadata:
  name: newbie-elk-cfgmap2
data:
  dessert: cake
</code></pre></td></tr></table>
</div>
</div><h4 id="overriding-values-of-a-child-chart">OVERRIDING VALUES OF A CHILD CHART</h4>
<p>Our original chart, <code>mychart</code> is now the <em><strong>parent</strong></em> chart of <code>mysubchart</code>. This relationship is based entirely on the fact that <code>mysubchart</code> is within <code>mychart/charts</code>.</p>
<p>Because <code>mychart</code> is a parent, we can specify configuration in <code>mychart</code> and have that configuration pushed into <code>mysubchart</code>. For example, we can modify <code>mychart/values.yaml</code> like this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">favorite:
  drink: coffee
  food: pizza
pizzaToppings:
  - mushrooms
  - cheese
  - peppers
  - onions

mysubchart:
  dessert: ice cream
</code></pre></td></tr></table>
</div>
</div><p>Note the last two lines. Any directives inside of the <code>mysubchart</code> section will be sent to the <code>mysubchart</code> chart. So if we run <code>helm install --dry-run --debug mychart</code>, one of the things we will see is the <code>mysubchart</code> ConfigMap:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># Source: mychart/charts/mysubchart/templates/configmap.yaml</span>
apiVersion: v1
kind: ConfigMap
metadata:
  name: unhinged-bee-cfgmap2
data:
  dessert: ice cream
</code></pre></td></tr></table>
</div>
</div><p>The value at the top level has now overridden the value of the subchart.</p>
<p>There’s an important detail to notice here. We didn’t change the template of <code>mychart/charts/mysubchart/templates/configmap.yaml</code> to point to <code>.Values.mysubchart.dessert</code>. From that template’s perspective, the value is still located at <code>.Values.dessert</code>. As the template engine passes values along, it sets the scope. So for the <code>mysubchart</code> templates, only values specifically for <code>mysubchart</code> will be available in <code>.Values</code>.</p>
<p>Sometimes, though, you do want certain values to be available to all of the templates. This is accomplished using global chart values.</p>
<h4 id="global-chart-values">GLOBAL CHART VALUES</h4>
<p>Global values are values that can be accessed from any chart or subchart by exactly the same name. Globals require explicit declaration. You can’t use an existing non-global as if it were a global.</p>
<p>The Values data type has a reserved section called <code>Values.global</code> where global values can be set. Let’s set one in our <code>mychart/values.yaml</code> file.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">favorite:
  drink: coffee
  food: pizza
pizzaToppings:
  - mushrooms
  - cheese
  - peppers
  - onions

mysubchart:
  dessert: ice cream

global:
  salad: caesar
</code></pre></td></tr></table>
</div>
</div><p>Because of the way globals work, both <code>mychart/templates/configmap.yaml</code> and <code>mychart/charts/mysubchart/templates/configmap.yaml</code> should be able to access that value as <code>{{ .Values.global.salad}}</code>.</p>
<p><code>mychart/templates/configmap.yaml</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">apiVersion: v1
kind: ConfigMap
metadata:
  name: <span class="o">{{</span> .Release.Name <span class="o">}}</span>-configmap
data:
  salad: <span class="o">{{</span> .Values.global.salad <span class="o">}}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>mychart/charts/mysubchart/templates/configmap.yaml</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">apiVersion: v1
kind: ConfigMap
metadata:
  name: <span class="o">{{</span> .Release.Name <span class="o">}}</span>-cfgmap2
data:
  dessert: <span class="o">{{</span> .Values.dessert <span class="o">}}</span>
  salad: <span class="o">{{</span> .Values.global.salad <span class="o">}}</span>
</code></pre></td></tr></table>
</div>
</div><p>Now if we run a dry run install, we’ll see the same value in both outputs:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># Source: mychart/templates/configmap.yaml</span>
apiVersion: v1
kind: ConfigMap
metadata:
  name: silly-snake-configmap
data:
  salad: caesar

---
<span class="c1"># Source: mychart/charts/mysubchart/templates/configmap.yaml</span>
apiVersion: v1
kind: ConfigMap
metadata:
  name: silly-snake-cfgmap2
data:
  dessert: ice cream
  salad: caesar
</code></pre></td></tr></table>
</div>
</div><p>Globals are useful for passing information like this, though it does take some planning to make sure the right templates are configured to use globals.</p>
<h4 id="sharing-templates-with-subcharts">SHARING TEMPLATES WITH SUBCHARTS</h4>
<p>Parent charts and subcharts can share templates. Any defined block in any chart is available to other charts.</p>
<p>For example, we can define a simple template like this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">{{</span>- define <span class="s2">&#34;labels&#34;</span> <span class="o">}}</span>from: mychart<span class="o">{{</span> end <span class="o">}}</span>
</code></pre></td></tr></table>
</div>
</div><p>Recall how the labels on templates are <em><strong>globally shared</strong></em>. Thus, the <code>labels</code> chart can be included from any other chart.</p>
<p>While chart developers have a choice between <code>include</code> and <code>template</code>, one advantage of using <code>include</code> is that <code>include</code> can dynamically reference templates:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">{{</span> include <span class="nv">$mytemplate</span> <span class="o">}}</span>
</code></pre></td></tr></table>
</div>
</div><p>The above will dereference <code>$mytemplate</code>. The <code>template</code> function, in contrast(相反地), will only accept a string literal.</p>
<h4 id="avoid-using-blocks">AVOID USING BLOCKS</h4>
<p>The Go template language provides a · keyword that allows developers to provide a default implementation which is overridden later. In Helm charts, blocks are not the best tool for overriding because if multiple implementations of the same block are provided, the one selected is unpredictable.</p>
<p>The suggestion is to instead use <code>include</code>.</p>
<h3 id="debugging-templates">Debugging Templates</h3>
<p>Debugging templates can be tricky(棘手的) simply because the templates are rendered on the Tiller server, not the Helm client. And then the rendered templates are sent to the Kubernetes API server, which may reject the YAML files for reasons other than formatting.</p>
<p>There are a few commands that can help you debug.</p>
<ul>
<li><code>helm lint</code> is your go-to tool for verifying that your chart follows best practices</li>
<li><code>helm install --dry-run --debug</code>: We’ve seen this trick already. It’s a great way to have the server render your templates, then return the resulting manifest file.</li>
<li><code>helm get manifest</code>: This is a good way to see what templates are installed on the server.</li>
</ul>
<p>When your YAML is failing to parse, but you want to see what is generated, one easy way to retrieve the YAML is to comment out the problem section in the template, and then re-run <code>helm install --dry-run --debug</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">apiVersion: v1
<span class="c1"># some: problem section</span>
<span class="c1"># {{ .Values.foo | quote }}</span>
</code></pre></td></tr></table>
</div>
</div><p>The above will be rendered and returned with the comments intact:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">apiVersion: v1
<span class="c1"># some: problem section</span>
<span class="c1">#  &#34;bar&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>This provides a quick way of viewing the generated content without YAML parse errors blocking.</p>
<h3 id="wrapping-up">Wrapping Up</h3>
<p>This guide is intended to give you, the chart developer, a strong understanding of how to use Helm’s template language. The guide focuses on the technical aspects of template development.</p>
<p>But there are many things this guide has not covered when it comes to the practical day-to-day development of charts. Here are some useful pointers to other documentation that will help you as you create new charts:</p>
<ul>
<li>The <a href="https://github.com/helm/charts" target="_blank" rel="noopener noreffer">Helm Charts project</a> is an indispensable(必不可少的) source of charts. That project is also sets the standard for best practices in chart development.</li>
<li>The Kubernetes <a href="https://kubernetes.io/docs/home/" target="_blank" rel="noopener noreffer">Documentation</a> provides detailed examples of the various resource kinds that you can use, from ConfigMaps and Secrets to DaemonSets and Deployments.</li>
<li>The Helm <a href="https://helm.sh/docs/chart_template_guide/#../charts" target="_blank" rel="noopener noreffer">Charts Guide</a> explains the workflow of using charts.</li>
<li>The Helm <a href="https://helm.sh/docs/chart_template_guide/#../charts_hooks" target="_blank" rel="noopener noreffer">Chart Hooks Guide</a> explains how to create lifecycle hooks.</li>
<li>The Helm <a href="https://helm.sh/docs/chart_template_guide/#../chart-development-tips-and-tricks" target="_blank" rel="noopener noreffer">Charts Tips and Tricks</a> article provides some useful tips for writing charts.</li>
<li>The <a href="https://github.com/Masterminds/sprig" target="_blank" rel="noopener noreffer">Sprig documentation</a> documents more than sixty of the template functions.</li>
<li>The <a href="https://godoc.org/text/template" target="_blank" rel="noopener noreffer">Go template docs</a> explain the template syntax in detail.</li>
<li>The <a href="https://github.com/databus23/schelm" target="_blank" rel="noopener noreffer">Schelm tool</a> is a nice helper utility for debugging charts.</li>
</ul>
<p>Sometimes it’s easier to ask a few questions and get answers from experienced developers. The best place to do this is in the <a href="https://kubernetes.slack.com/" target="_blank" rel="noopener noreffer">Kubernetes Slack</a> Helm channels:</p>
<ul>
<li><a href="https://kubernetes.slack.com/messages/helm-users" target="_blank" rel="noopener noreffer">#helm-users</a></li>
<li><a href="https://kubernetes.slack.com/messages/helm-dev" target="_blank" rel="noopener noreffer">#helm-dev</a></li>
<li><a href="https://kubernetes.slack.com/messages/charts" target="_blank" rel="noopener noreffer">#charts</a></li>
</ul>
<p>Finally, if you find errors or omissions in this document, want to suggest some new content, or would like to contribute, visit <a href="https://github.com/helm/helm" target="_blank" rel="noopener noreffer">The Helm Project</a>.</p>
<h2 id="yaml-techniques">YAML Techniques</h2>
<p>Most of this guide has been focused on writing the template language. Here, we’ll look at the YAML format. YAML has some useful features that we, as template authors, can use to make our templates less error prone and easier to read.</p>
<h3 id="scalars-and-collections">SCALARS AND COLLECTIONS</h3>
<p>According to the <a href="https://yaml.org/spec/1.2/spec.html" target="_blank" rel="noopener noreffer">YAML spec</a>, there are two types of collections, and many scalar types.</p>
<p>The two types of collections are maps and sequences:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">map:
  one: <span class="m">1</span>
  two: <span class="m">2</span>
  three: <span class="m">3</span>

sequence:
  - one
  - two
  - three
</code></pre></td></tr></table>
</div>
</div><p>Scalar values(标量值) are individual values (as opposed to collections)</p>
<h3 id="scalar-types-in-yaml">Scalar Types in YAML</h3>
<p>In Helm’s dialect(方言) of YAML, the scalar data type of a value is determined by a complex set of rules, including the Kubernetes schema for resource definitions. But when inferring types, the following rules tend to hold true.</p>
<p>If an integer or float is an unquoted bare word, it is typically treated as a numeric type:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">count: <span class="m">1</span>
size: 2.34
</code></pre></td></tr></table>
</div>
</div><p>But if they are quoted, they are treated as strings:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">count: <span class="s2">&#34;1&#34;</span> <span class="c1"># &lt;-- string, not int</span>
size: <span class="s1">&#39;2.34&#39;</span> <span class="c1"># &lt;-- string, not float</span>
</code></pre></td></tr></table>
</div>
</div><p>The same is true of booleans:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">isGood: <span class="nb">true</span>   <span class="c1"># bool</span>
answer: <span class="s2">&#34;true&#34;</span> <span class="c1"># string</span>
</code></pre></td></tr></table>
</div>
</div><p>The word for an empty value is <code>null</code> (not <code>nil</code>).</p>
<p>Note that <code>port: &quot;80&quot;</code> is valid YAML, and will pass through both the template engine and the YAML parser, but will fail if Kubernetes expects <code>port</code> to be an integer.</p>
<p>In some cases, you can force a particular type inference(推理) using YAML node tags:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">coffee: <span class="s2">&#34;yes, please&#34;</span>
age: !!str <span class="m">21</span>
port: !!int <span class="s2">&#34;80&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>In the above, <code>!!str</code> tells the parser that <code>age</code> is a string, even if it looks like an int. And <code>port</code> is treated as an int, even though it is quoted.</p>
<h3 id="strings-in-yaml">STRINGS IN YAML</h3>
<p>Much of the data that we place in YAML documents are strings. YAML has more than one way to represent a string. This section explains the ways and demonstrates how to use some of them.</p>
<p>There are three “inline” ways of declaring a string:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">way1: bare words
way2: <span class="s2">&#34;double-quoted strings&#34;</span>
way3: <span class="s1">&#39;single-quoted strings&#39;</span>
</code></pre></td></tr></table>
</div>
</div><p>All inline styles must be on one line.</p>
<ul>
<li>Bare words are unquoted, and are not escaped. For this reason, you have to be careful what characters you use.</li>
<li>Double-quoted strings can have specific characters escaped with <code>\</code>. For example <code>&quot;\&quot;Hello\&quot;, she said&quot;</code>. You can escape line breaks with <code>\n</code>.</li>
<li>Single-quoted strings are “literal” strings, and do not use the <code>\</code> to escape characters. The only escape sequence is <code>''</code>, which is decoded as a single <code>'</code>.</li>
</ul>
<p>In addition to the one-line strings, you can declare multi-line strings:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">coffee: <span class="p">|</span>
  Latte
  Cappuccino
  Espresso
</code></pre></td></tr></table>
</div>
</div><p>The above will treat the value of <code>coffee</code> as a single string equivalent to <code>Latte\nCappuccino\nEspresso\n</code>.</p>
<p>Note that the first line after the <code>|</code> must be correctly indented. So we could break the example above by doing this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">coffee: <span class="p">|</span>
         Latte
  Cappuccino
  Espresso
</code></pre></td></tr></table>
</div>
</div><p>Because <code>Latte</code> is incorrectly indented, we’d get an error like this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">Error parsing file: error converting YAML to JSON: yaml: line 7: did not find expected key
</code></pre></td></tr></table>
</div>
</div><p>In templates, it is sometimes safer to put a fake “first line” of content in a multi-line document just for protection from the above error:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">coffee: <span class="p">|</span>
  <span class="c1"># Commented first line</span>
         Latte
  Cappuccino
  Espresso
</code></pre></td></tr></table>
</div>
</div><p>Note that whatever that first line is, it will be preserved in the output of the string. So if you are, for example, using this technique to inject a file’s contents into a ConfigMap, the comment should be of the type expected by whatever is reading that entry.</p>
<h3 id="controlling-spaces-in-multi-line-strings">Controlling Spaces in Multi-line Strings</h3>
<p>In the example above, we used <code>|</code> to indicate a multi-line string. But notice that the content of our string was followed with a trailing <code>\n</code>. If we want the YAML processor to strip off the trailing newline, we can add a <code>-</code> after the <code>|</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">coffee: <span class="p">|</span>-
  Latte
  Cappuccino
  Espresso
</code></pre></td></tr></table>
</div>
</div><p>Now the <code>coffee</code> value will be: <code>Latte\nCappuccino\nEspresso</code> (with no trailing <code>\n</code>).</p>
<p>Other times, we might want all trailing whitespace to be preserved(保留所有尾随的空白). We can do this with the <code>|+</code> notation:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">coffee: <span class="p">|</span>+
  Latte
  Cappuccino
  Espresso


another: value
</code></pre></td></tr></table>
</div>
</div><p>Now the value of <code>coffee</code> will be <code>Latte\nCappuccino\nEspresso\n\n\n</code>.</p>
<p>Indentation inside of a text block is preserved, and results in the preservation of line breaks, too(保留文本块内部的缩进，并且也导致换行符的保留):</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">coffee: <span class="p">|</span>-
  Latte
    <span class="m">12</span> oz
    <span class="m">16</span> oz
  Cappuccino
  Espresso
</code></pre></td></tr></table>
</div>
</div><p>In the above case, <code>coffee</code> will be <code>Latte\n 12 oz\n 16 oz\nCappuccino\nEspresso</code>.</p>
<h3 id="indenting-and-templates">Indenting and Templates</h3>
<p>When writing templates, you may find yourself wanting to inject the contents of a file into the template. As we saw in previous chapters, there are two ways of doing this:</p>
<ul>
<li>Use <code>{{ .Files.Get &quot;FILENAME&quot; }}</code> to get the contents of a file in the chart.</li>
<li>Use <code>{{ include &quot;TEMPLATE&quot; . }}</code> to render a template and then place its contents into the chart.
When inserting files into YAML, it’s good to understand the multi-line rules above. Often times, the easiest way to insert a static file is to do something like this:</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">myfile: <span class="p">|</span>
<span class="o">{{</span> .Files.Get <span class="s2">&#34;myfile.txt&#34;</span> <span class="p">|</span> indent <span class="m">2</span> <span class="o">}}</span>
</code></pre></td></tr></table>
</div>
</div><p>Note how we do the indentation above: <code>indent 2</code> tells the template engine to indent every line in “myfile.txt” with two spaces. Note that we do not indent that template line. That’s because if we did, the file content of the first line would be indented twice.</p>
<h3 id="folded-multi-line-strings">Folded Multi-line Strings</h3>
<p>Sometimes you want to represent a string in your YAML with multiple lines, but want it to be treated as one long line when it is interpreted(被解释). This is called “folding”. To declare a folded block, use <code>&gt;</code> instead of <code>|</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">coffee: &gt;
  Latte
  Cappuccino
  Espresso

</code></pre></td></tr></table>
</div>
</div><p>The value of <code>coffee</code> above will be <code>Latte Cappuccino Espresso\n</code>. Note that all but the last line feed will be converted to spaces. You can combine the whitespace controls with the folded text marker, so <code>&gt;-</code> will replace or trim all newlines.</p>
<p>Note that in the folded syntax, indenting text will cause lines to be preserved.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">coffee: &gt;-
  Latte
    <span class="m">12</span> oz
    <span class="m">16</span> oz
  Cappuccino
  Espresso
</code></pre></td></tr></table>
</div>
</div><p>The above will produce <code>Latte\n 12 oz\n 16 oz\nCappuccino Espresso</code>. Note that both the spacing and the newlines are still there.</p>
<h3 id="embedding-multiple-documents-in-one-file">EMBEDDING MULTIPLE DOCUMENTS IN ONE FILE</h3>
<p>It is possible to place more than one YAML documents into a single file. This is done by prefixing a new document with <code>---</code> and ending the document with <code>...</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">---
document:1
...
---
document: <span class="m">2</span>
...
</code></pre></td></tr></table>
</div>
</div><p>In many cases, either the <code>---</code> or the <code>...</code> may be omitted.</p>
<p>Some files in Helm cannot contain more than one doc. If, for example, more than one document is provided inside of a <code>values.yaml</code> file, only the first will be used.</p>
<p>Template files, however, may have more than one document. When this happens, the file (and all of its documents) is treated as one object during template rendering. But then the resulting YAML is split into multiple documents before it is fed to Kubernetes.</p>
<p>We recommend only using multiple documents per file when it is absolutely necessary. Having multiple documents in a file can be difficult to debug.</p>
<h3 id="yaml-is-a-superset-of-json-1">YAML IS A SUPERSET OF JSON</h3>
<p>Because YAML is a superset of JSON, any valid JSON document should be valid YAML.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
  <span class="nt">&#34;coffee&#34;</span><span class="p">:</span> <span class="s2">&#34;yes, please&#34;</span><span class="p">,</span>
  <span class="nt">&#34;coffees&#34;</span><span class="p">:</span> <span class="p">[</span>
    <span class="s2">&#34;Latte&#34;</span><span class="p">,</span> <span class="s2">&#34;Cappuccino&#34;</span><span class="p">,</span> <span class="s2">&#34;Espresso&#34;</span>
  <span class="p">]</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The above is another way of representing this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">coffee</span><span class="p">:</span><span class="w"> </span><span class="kc">yes</span><span class="p">,</span><span class="w"> </span><span class="l">please</span><span class="w">
</span><span class="w"></span><span class="nt">coffees</span><span class="p">:</span><span class="w">
</span><span class="w"></span>- <span class="l">Latte</span><span class="w">
</span><span class="w"></span>- <span class="l">Cappuccino</span><span class="w">
</span><span class="w"></span>- <span class="l">Espresso</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>And the two can be mixed (with care):</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">coffee</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;yes, please&#34;</span><span class="w">
</span><span class="w"></span><span class="nt">coffees</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="s2">&#34;Latte&#34;</span><span class="p">,</span><span class="w"> </span><span class="s2">&#34;Cappuccino&#34;</span><span class="p">,</span><span class="w"> </span><span class="s2">&#34;Espresso&#34;</span><span class="p">]</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>All three of these should parse into the same internal representation.</p>
<p>While this means that files such as <code>values.yaml</code> may contain JSON data, Helm does not treat the file extension <code>.json</code> as a valid suffix.</p>
<h3 id="yaml-anchors锚">YAML ANCHORS(锚))</h3>
<p>The YAML spec provides a way to store a reference to a value, and later refer to that value by reference. YAML refers to this as “anchoring”:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">coffee</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;yes, please&#34;</span><span class="w">
</span><span class="w"></span><span class="nt">favorite</span><span class="p">:</span><span class="w"> </span><span class="cp">&amp;favoriteCoffee</span><span class="w"> </span><span class="s2">&#34;Cappucino&#34;</span><span class="w">
</span><span class="w"></span><span class="nt">coffees</span><span class="p">:</span><span class="w">
</span><span class="w">  </span>- <span class="l">Latte</span><span class="w">
</span><span class="w">  </span>- <span class="cp">*favoriteCoffee</span><span class="w">
</span><span class="w">  </span>- <span class="l">Espresso</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>In the above, <code>&amp;favoriteCoffee</code> sets a reference to <code>Cappuccino</code>. Later, that reference is used as <code>*favoriteCoffee</code>. So <code>coffees</code> becomes <code>Latte, Cappuccino, Espresso</code>.</p>
<p>While there are a few cases where anchors are useful, there is one aspect of them that can cause subtle bugs: The first time the YAML is consumed, the reference is expanded and then discarded.</p>
<p>So if we were to decode and then re-encode the example above, the resulting YAML would be:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">coffee</span><span class="p">:</span><span class="w"> </span><span class="kc">yes</span><span class="p">,</span><span class="w"> </span><span class="l">please</span><span class="w">
</span><span class="w"></span><span class="nt">favorite</span><span class="p">:</span><span class="w"> </span><span class="l">Cappucino</span><span class="w">
</span><span class="w"></span><span class="nt">coffees</span><span class="p">:</span><span class="w">
</span><span class="w"></span>- <span class="l">Latte</span><span class="w">
</span><span class="w"></span>- <span class="l">Cappucino</span><span class="w">
</span><span class="w"></span>- <span class="l">Espresso</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>Because Helm and Kubernetes often read, modify, and then rewrite YAML files, the anchors will be lost.</p>
<h2 id="appendix-go-data-types-and-templates">Appendix: Go Data Types and Templates</h2>
<p>The Helm template language is implemented in the strongly typed Go programming language. For that reason, variables in templates are <em><strong>typed</strong></em>. For the most part, variables will be exposed as one of the following types:</p>
<ul>
<li>string: A string of text</li>
<li>bool: a true or false</li>
<li>int: An integer value (there are also 8, 16, 32, and 64 bit signed and unsigned variants of this)</li>
<li>float64: a 64-bit floating point value (there are also 8, 16, and 32 bit varieties of this)</li>
<li>a byte slice ([]byte), often used to hold (potentially) binary data</li>
<li>struct: an object with properties and methods</li>
<li>a slice (indexed list) of one of the previous types</li>
<li>a string-keyed map (map[string]interface{}) where the value is one of the previous types</li>
</ul>
<p>There are many other types in Go, and sometimes you will have to convert between them in your templates. The easiest way to debug an object’s type is to pass it through <code>printf &quot;%t&quot;</code> in a template, which will print the type. Also see the <code>typeOf</code> and <code>kindOf</code> functions.</p>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2019-10-13</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"><span>
                            <a class="link-to-markdown" href="/posts/k8s/helm-v2.14.3-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/index.md" target="_blank">阅读原始文档</a>
                        </span></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="分享到 Twitter" data-sharer="twitter" data-url="https://msdemt.github.io/posts/k8s/helm-v2.14.3-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" data-title="Helm v2.14.3 官方文档阅读笔记" data-hashtags="k8s,tag2,tag3"><i class="fab fa-twitter fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Facebook" data-sharer="facebook" data-url="https://msdemt.github.io/posts/k8s/helm-v2.14.3-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" data-hashtag="k8s"><i class="fab fa-facebook-square fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Hacker News" data-sharer="hackernews" data-url="https://msdemt.github.io/posts/k8s/helm-v2.14.3-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" data-title="Helm v2.14.3 官方文档阅读笔记"><i class="fab fa-hacker-news fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Line" data-sharer="line" data-url="https://msdemt.github.io/posts/k8s/helm-v2.14.3-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" data-title="Helm v2.14.3 官方文档阅读笔记"><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@2.14.0/icons/line.svg"></i></a><a href="javascript:void(0);" title="分享到 微博" data-sharer="weibo" data-url="https://msdemt.github.io/posts/k8s/helm-v2.14.3-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" data-title="Helm v2.14.3 官方文档阅读笔记" data-ralateuid="xxxx"><i class="fab fa-weibo fa-fw"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/k8s/">k8s</a>,&nbsp;<a href="/tags/tag2/">tag2</a>,&nbsp;<a href="/tags/tag3/">tag3</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/posts/linux/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BF%A1%E6%81%AF%E6%9F%A5%E8%AF%A2/" class="prev" rel="prev" title="Linux服务器信息查询"><i class="fas fa-angle-left fa-fw"></i>Linux服务器信息查询</a>
            <a href="/posts/k8s/k8s-v1.15.0-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%B9%E5%BC%8F%E9%83%A8%E7%BD%B2/" class="next" rel="next" title="k8s v1.15.0 二进制方式部署">k8s v1.15.0 二进制方式部署<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
</article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.80.0">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2019 - 2021</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/" target="_blank">xxxx</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/smooth-scroll@16.1.3/dist/smooth-scroll.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/autocomplete.js@0.37.1/dist/autocomplete.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/algoliasearch@4.2.0/dist/algoliasearch-lite.umd.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.2.2/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/sharer.js@0.4.0/sharer.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":10},"comment":{},"search":{"algoliaAppID":"PASDMWALPK","algoliaIndex":"index.zh-cn","algoliaSearchKey":"b42948e51daaa93df92381c8e2ac0f93","highlightTag":"em","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"algolia"}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
