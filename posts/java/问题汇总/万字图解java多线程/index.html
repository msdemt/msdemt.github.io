<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>万字图解Java多线程 - MyBlog</title><meta name="Description" content="我的博客"><meta property="og:title" content="万字图解Java多线程" />
<meta property="og:description" content="转载自： https://blog.csdn.net/qq_35598736/article/details/108431422 什么是 Java 多线程？ 进程与线程 进程 当一个程序被运行，就开启了一个进程，比如 qq 程序由指令和数据组成，指令要运行，数据要加载，指令被 cpu 加载" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://msdemt.github.io/posts/java/%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/%E4%B8%87%E5%AD%97%E5%9B%BE%E8%A7%A3java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" />
<meta property="og:image" content="https://msdemt.github.io/logo.png"/>
<meta property="article:published_time" content="2021-02-20T09:38:54+08:00" />
<meta property="article:modified_time" content="2021-02-20T09:38:54+08:00" />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://msdemt.github.io/logo.png"/>

<meta name="twitter:title" content="万字图解Java多线程"/>
<meta name="twitter:description" content="转载自： https://blog.csdn.net/qq_35598736/article/details/108431422 什么是 Java 多线程？ 进程与线程 进程 当一个程序被运行，就开启了一个进程，比如 qq 程序由指令和数据组成，指令要运行，数据要加载，指令被 cpu 加载"/>
<meta name="application-name" content="LoveIt">
<meta name="apple-mobile-web-app-title" content="LoveIt"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://msdemt.github.io/posts/java/%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/%E4%B8%87%E5%AD%97%E5%9B%BE%E8%A7%A3java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" /><link rel="prev" href="https://msdemt.github.io/posts/java/%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/java%E7%BA%BF%E7%A8%8Bapi/" /><link rel="next" href="https://msdemt.github.io/posts/java/%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/%E6%A2%B3%E7%90%86javaio%E6%B5%81/" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "万字图解Java多线程",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/msdemt.github.io\/posts\/java\/%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB\/%E4%B8%87%E5%AD%97%E5%9B%BE%E8%A7%A3java%E5%A4%9A%E7%BA%BF%E7%A8%8B\/"
        },"image": ["https:\/\/msdemt.github.io\/images\/Apple-Devices-Preview.png"],"genre": "posts","wordcount":  40015 ,
        "url": "https:\/\/msdemt.github.io\/posts\/java\/%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB\/%E4%B8%87%E5%AD%97%E5%9B%BE%E8%A7%A3java%E5%A4%9A%E7%BA%BF%E7%A8%8B\/","datePublished": "2021-02-20T09:38:54+08:00","dateModified": "2021-02-20T09:38:54+08:00","license": "This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher": {
            "@type": "Organization",
            "name": "xxxx","logo": "https:\/\/msdemt.github.io\/images\/avatar.png"},"author": {
                "@type": "Person",
                "name": "hekai"
            },"description": ""
    }
    </script></head>
    <body header-desktop="fixed" header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="MyBlog"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw'></i></span>MyBlog</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 所有文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><a class="menu-item" href="/categories/documentation/"> 文档 </a><a class="menu-item" href="/about/"> 关于 </a><a class="menu-item" href="https://github.com/dillonzq/LoveIt" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i>  </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="MyBlog"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw'></i></span>MyBlog</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/posts/" title="">所有文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a class="menu-item" href="/categories/documentation/" title="">文档</a><a class="menu-item" href="/about/" title="">关于</a><a class="menu-item" href="https://github.com/dillonzq/LoveIt" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i></a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animated flipInX">万字图解Java多线程</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="/" title="Author" rel=" author" class="author"><i class="fas fa-user-circle fa-fw"></i>hekai</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2021-02-20">2021-02-20</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 40015 字&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 80 分钟&nbsp;</div>
        </div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#什么是-java-多线程">什么是 Java 多线程？</a>
      <ul>
        <li><a href="#进程与线程">进程与线程</a></li>
        <li><a href="#并发与并行">并发与并行</a></li>
      </ul>
    </li>
    <li><a href="#为什么用多线程">为什么用多线程？</a></li>
    <li><a href="#多线程难在那里">多线程难在那里？</a></li>
    <li><a href="#多线程的基本使用">多线程的基本使用</a>
      <ul>
        <li><a href="#定义任务创建和运行线程">定义任务、创建和运行线程</a></li>
        <li><a href="#上下文切换">上下文切换</a></li>
        <li><a href="#线程的礼让---yield--线程优先级">线程的礼让 - yield() &amp; 线程优先级</a></li>
        <li><a href="#守护线程">守护线程</a></li>
        <li><a href="#线程的阻塞">线程的阻塞</a>
          <ul>
            <li><a href="#sleep">sleep()</a></li>
            <li><a href="#join">join()</a></li>
            <li><a href="#interrupt">interrupt()</a></li>
          </ul>
        </li>
        <li><a href="#线程的状态">线程的状态</a></li>
        <li><a href="#线程的相关方法总结">线程的相关方法总结</a></li>
      </ul>
    </li>
    <li><a href="#同步锁">同步锁</a>
      <ul>
        <li><a href="#线程安全">线程安全</a></li>
        <li><a href="#synchronized">synchronized</a></li>
        <li><a href="#lock">Lock</a>
          <ul>
            <li><a href="#condition">Condition</a>
              <ul>
                <li><a href="#condition接口介绍">Condition接口介绍</a></li>
                <li><a href="#condition接口常用方法">Condition接口常用方法</a></li>
                <li><a href="#condition接口原理解析">Condition接口原理解析</a></li>
              </ul>
            </li>
            <li><a href="#reentrantlock">ReentrantLock</a>
              <ul>
                <li><a href="#reentrantlock-实现的可重入性">ReentrantLock 实现的可重入性</a></li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#线程通信">线程通信</a>
      <ul>
        <li><a href="#wait--notify">wait &amp; notify</a></li>
        <li><a href="#park--unpark">park &amp; unpark</a></li>
        <li><a href="#生产者消费者模型">生产者消费者模型</a></li>
      </ul>
    </li>
    <li><a href="#死锁">死锁</a></li>
    <li><a href="#java内存模型jmm">Java内存模型（JMM）</a>
      <ul>
        <li><a href="#什么是-java-内存模型jmm">什么是 Java 内存模型（JMM）</a></li>
        <li><a href="#java内存模型和深度剖析volatile">Java内存模型和深度剖析volatile</a>
          <ul>
            <li><a href="#内存模型的相关概念">内存模型的相关概念</a></li>
            <li><a href="#并发编程中的三个概念">并发编程中的三个概念</a>
              <ul>
                <li><a href="#原子性">原子性</a></li>
                <li><a href="#可见性">可见性</a></li>
                <li><a href="#有序性">有序性</a></li>
              </ul>
            </li>
            <li><a href="#java-内存模型">Java 内存模型</a>
              <ul>
                <li><a href="#原子性-1">原子性</a></li>
                <li><a href="#可见性-1">可见性</a></li>
                <li><a href="#有序性-1">有序性</a></li>
              </ul>
            </li>
            <li><a href="#深入剖析volatile关键字">深入剖析volatile关键字</a>
              <ul>
                <li><a href="#volatile关键字的两层语义">volatile关键字的两层语义</a></li>
                <li><a href="#volatile保证原子性吗">volatile保证原子性吗？</a></li>
                <li><a href="#volatile-能保证有序性吗">volatile 能保证有序性吗？</a></li>
                <li><a href="#volatile的原理和实现机制">volatile的原理和实现机制</a></li>
                <li><a href="#使用volatile关键字的场景">使用volatile关键字的场景</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#java中的可见性问题">Java中的可见性问题</a>
          <ul>
            <li><a href="#什么是java内存模型">什么是Java内存模型</a></li>
            <li><a href="#程序的顺序性">程序的顺序性</a></li>
            <li><a href="#happens-before-规则">Happens-Before 规则</a>
              <ul>
                <li><a href="#volatile-变量规则">volatile 变量规则</a></li>
                <li><a href="#传递性规则">传递性规则</a></li>
                <li><a href="#管程中锁的规则">管程中锁的规则</a></li>
                <li><a href="#线程-start-规则">线程 start() 规则</a></li>
                <li><a href="#线程-join-规则">线程 join() 规则</a></li>
                <li><a href="#线程中断规则">线程中断规则</a></li>
                <li><a href="#final-规则">final 规则</a></li>
                <li><a href="#总结">总结</a></li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#cas">CAS</a>
      <ul>
        <li><a href="#cas-实现">CAS 实现</a></li>
        <li><a href="#aba问题">ABA问题</a></li>
        <li><a href="#其他问题">其他问题</a></li>
        <li><a href="#cas-的应用">CAS 的应用</a></li>
      </ul>
    </li>
    <li><a href="#线程池">线程池</a>
      <ul>
        <li><a href="#线程池的构造方法">线程池的构造方法</a></li>
        <li><a href="#线程池案例">线程池案例</a></li>
        <li><a href="#线程池的状态">线程池的状态</a></li>
        <li><a href="#线程池的主要流程">线程池的主要流程</a></li>
        <li><a href="#execetors创建线程池">Execetors创建线程池</a></li>
        <li><a href="#线程池的关闭">线程池的关闭</a></li>
        <li><a href="#线程池使用的正确姿势">线程池使用的正确姿势</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><blockquote>
<p>转载自：<br>
<a href="https://blog.csdn.net/qq_35598736/article/details/108431422">https://blog.csdn.net/qq_35598736/article/details/108431422</a></p>
</blockquote>
<h2 id="什么是-java-多线程">什么是 Java 多线程？</h2>
<h3 id="进程与线程">进程与线程</h3>
<p>进程</p>
<ul>
<li>当一个程序被运行，就开启了一个进程，比如 qq</li>
<li>程序由指令和数据组成，指令要运行，数据要加载，指令被 cpu 加载运行，数据被加载到内存，指令运行时可由 cpu 调度硬盘、网络等设备</li>
</ul>
<p>线程</p>
<ul>
<li>一个进程可分为多个线程</li>
<li>一个线程就是一个指令流， cpu 调度的最小单位，由 cpu 一条一条执行指令</li>
</ul>
<h3 id="并发与并行">并发与并行</h3>
<p>并发</p>
<ul>
<li>单核 cpu 运行多线程时，时间片进行很快的切换。线程轮流执行 cpu ，同一时刻只有一个线程被执行</li>
</ul>
<p>并行</p>
<ul>
<li>多核 cpu 运行多线程时，真正的在同一时刻，多个线程同时在运行。</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/images/20210220-%e5%b9%b6%e5%8f%91%e4%b8%8e%e5%b9%b6%e8%a1%8c.png"
        data-srcset="/images/20210220-%e5%b9%b6%e5%8f%91%e4%b8%8e%e5%b9%b6%e8%a1%8c.png, /images/20210220-%e5%b9%b6%e5%8f%91%e4%b8%8e%e5%b9%b6%e8%a1%8c.png 1.5x, /images/20210220-%e5%b9%b6%e5%8f%91%e4%b8%8e%e5%b9%b6%e8%a1%8c.png 2x"
        data-sizes="auto"
        alt="/images/20210220-并发与并行.png"
        title="并发与并行" /></p>
<p>Java 提供了丰富的 api 来支持多线程。</p>
<h2 id="为什么用多线程">为什么用多线程？</h2>
<p>多线程能实现的都可以用单线程来完成，那么 java 为什么要引入多线程的概念呢？</p>
<p>多线程的好处</p>
<ul>
<li>程序运行的更快</li>
<li>充分利用 cpu 资源，目前几乎没有单核的 cpu ，多线程能发挥多核 cpu 的优势</li>
</ul>
<h2 id="多线程难在那里">多线程难在那里？</h2>
<p>单线程只有一条执行线，过程容易理解，可以清晰勾勒出代码的执行流程</p>
<p>多线程确实多条执行线同时运行，而且多条执行线之间可能还会有交互，多条执行线之间有时还需要通信，一般难点有以下几点</p>
<ul>
<li>多线程的执行结果不确定，受 cpu 调度的影响</li>
<li>多线程的安全问题</li>
<li>线程资源宝贵，依赖线程池操作线程，线程池的参数设置问题</li>
<li>多线程的执行是动态的，同时难以追踪执行过程</li>
<li>多线程的底层是操作系统层面的，源码难度大</li>
</ul>
<h2 id="多线程的基本使用">多线程的基本使用</h2>
<h3 id="定义任务创建和运行线程">定义任务、创建和运行线程</h3>
<p>任务：线程的执行体，也就是期望线程运行的代码逻辑</p>
<p><strong>定义任务</strong></p>
<ul>
<li>继承 Thread 类（将任务与线程耦合在一起了）</li>
<li>实现 Runnable 接口（任务与线程解耦合）</li>
<li>实现 Callable 接口（任务与线程解耦合，可以获取到任务的执行结果）</li>
</ul>
<p>继承 Thread 类实现任务的局限性</p>
<ul>
<li>任务逻辑写在 Thread 类的 run 方法中，存在单继承的局限性</li>
<li>创建多线程时，每个任务有成员变量时不能共享，必须加上 static 才能做到共享</li>
</ul>
<p>实现 Runnable 接口和实现 Callable 接口实现任务解决了 继承 Thread 类的局限性</p>
<p>但是实现 Runnable 接口与 实现Callable 接口相比，有如下局限性</p>
<ul>
<li>任务没有返回值</li>
<li>任务无法抛出异常给调用方</li>
</ul>
<p><strong>定义任务示例如下</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">T</span> <span class="kd">extends</span> <span class="n">Thread</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;继承Thread的任务&#34;</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">R</span> <span class="kd">implements</span> <span class="n">Runnable</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;实现Runnable的任务&#34;</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">C</span> <span class="kd">implements</span> <span class="n">Callable</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">Object</span> <span class="nf">call</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;实现Callable的任务&#34;</span><span class="o">);</span>
        <span class="k">return</span> <span class="s">&#34;success&#34;</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>创建线程的方式</strong></p>
<ul>
<li>通过 Thread 类直接创建线程</li>
<li>利用线程池内部创建线程</li>
</ul>
<p><strong>启动线程的方式</strong></p>
<ul>
<li>调用线程的 start() 方法</li>
</ul>
<p><strong>通过 Thread 类创建并启动线程示例</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">//启动继承Thread类的任务
</span><span class="c1"></span><span class="k">new</span> <span class="n">T</span><span class="o">().</span><span class="na">start</span><span class="o">();</span>

<span class="c1">//使用Thread匿名内部类启动任务
</span><span class="c1"></span><span class="k">new</span> <span class="n">Thread</span><span class="o">(){</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;Thread匿名内部类的任务&#34;</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}.</span><span class="na">start</span><span class="o">();</span>

<span class="c1">//启动实现Runnable接口的任务
</span><span class="c1"></span><span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="k">new</span> <span class="n">R</span><span class="o">()).</span><span class="na">start</span><span class="o">();</span>

<span class="c1">//启动实现Runnable匿名实现类的任务
</span><span class="c1"></span><span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="k">new</span> <span class="n">Runnable</span><span class="o">()</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;Runnable匿名内部类的任务&#34;</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}).</span><span class="na">start</span><span class="o">();</span>

<span class="c1">//启动实现Runnable的lambda简化后的任务
</span><span class="c1"></span><span class="k">new</span> <span class="n">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;Runnable的lambda简化后的任务&#34;</span><span class="o">)).</span><span class="na">start</span><span class="o">();</span>

<span class="c1">//启动实现了Callable接口的任务 结合FutureTask 可以获取线程执行的结果
</span><span class="c1"></span><span class="n">FutureTask</span> <span class="n">futureTask</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FutureTask</span><span class="o">&lt;&gt;(</span><span class="k">new</span> <span class="n">C</span><span class="o">());</span>
<span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="n">futureTask</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>
<span class="k">try</span> <span class="o">{</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">futureTask</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">ExecutionException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>通过线程池创建启动线程示例</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">ExecutorService</span> <span class="n">executorService</span> <span class="o">=</span> <span class="n">Executors</span><span class="o">.</span><span class="na">newFixedThreadPool</span><span class="o">(</span><span class="n">10</span><span class="o">);</span>
<span class="c1">//使用线程池执行实现Runnable接口的任务，任务没有返回值
</span><span class="c1"></span><span class="n">executorService</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="k">new</span> <span class="n">R</span><span class="o">());</span>

<span class="c1">//使用线程池执行实现Runnable接口的任务，任务执行成功后，返回值为null
</span><span class="c1"></span><span class="n">Future</span><span class="o">&lt;?&gt;</span> <span class="n">future</span> <span class="o">=</span> <span class="n">executorService</span><span class="o">.</span><span class="na">submit</span><span class="o">(</span><span class="k">new</span> <span class="n">R</span><span class="o">());</span>
<span class="k">try</span> <span class="o">{</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;future 执行结果：&#34;</span> <span class="o">+</span> <span class="n">future</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">ExecutionException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">//使用线程池执行实现Callable接口的任务，可以接收到任务返回值
</span><span class="c1"></span><span class="n">Future</span> <span class="n">future1</span> <span class="o">=</span> <span class="n">executorService</span><span class="o">.</span><span class="na">submit</span><span class="o">(</span><span class="k">new</span> <span class="n">C</span><span class="o">());</span>
<span class="k">try</span> <span class="o">{</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;future1 执行结果：&#34;</span> <span class="o">+</span> <span class="n">future1</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">ExecutionException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">//使用线程池执行实现Runnable接口的任务，可以接收到任务返回值
</span><span class="c1"></span><span class="n">Data</span> <span class="n">data</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Data</span><span class="o">();</span>
<span class="n">Future</span><span class="o">&lt;</span><span class="n">Data</span><span class="o">&gt;</span> <span class="n">future2</span> <span class="o">=</span> <span class="n">executorService</span><span class="o">.</span><span class="na">submit</span><span class="o">(</span><span class="k">new</span> <span class="n">R</span><span class="o">(</span><span class="n">data</span><span class="o">),</span> <span class="n">data</span><span class="o">);</span>
<span class="k">try</span> <span class="o">{</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;future2 执行结果：&#34;</span> <span class="o">+</span> <span class="n">future2</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">ExecutionException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">//线程池用完后关闭，否则程序无法退出
</span><span class="c1"></span><span class="n">executorService</span><span class="o">.</span><span class="na">shutdown</span><span class="o">();</span>
</code></pre></td></tr></table>
</div>
</div><p>上述测试完整代码如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">org.msdemt.simple</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.concurrent.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MultiThreadTest</span> <span class="o">{</span>
    <span class="kd">static</span>
    <span class="kd">class</span> <span class="nc">T</span> <span class="kd">extends</span> <span class="n">Thread</span> <span class="o">{</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;继承Thread的任务&#34;</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">static</span>
    <span class="kd">class</span> <span class="nc">R</span> <span class="kd">implements</span> <span class="n">Runnable</span> <span class="o">{</span>
        <span class="kd">private</span> <span class="n">Data</span> <span class="n">data</span><span class="o">;</span>

        <span class="kd">public</span> <span class="nf">R</span><span class="o">()</span> <span class="o">{</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="nf">R</span><span class="o">(</span><span class="n">Data</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;实现Runnable的任务&#34;</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">data</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">data</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&#34;abc&#34;</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">static</span>
    <span class="kd">class</span> <span class="nc">C</span> <span class="kd">implements</span> <span class="n">Callable</span> <span class="o">{</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="n">Object</span> <span class="nf">call</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;实现Callable的任务&#34;</span><span class="o">);</span>
            <span class="k">return</span> <span class="s">&#34;success&#34;</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">static</span>
    <span class="kd">class</span> <span class="nc">Data</span> <span class="o">{</span>
        <span class="n">String</span> <span class="n">name</span><span class="o">;</span>

        <span class="kd">public</span> <span class="n">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">name</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setName</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="s">&#34;Data{&#34;</span> <span class="o">+</span>
                    <span class="s">&#34;name=&#39;&#34;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="sc">&#39;\&#39;&#39;</span> <span class="o">+</span>
                    <span class="sc">&#39;}&#39;</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="cm">/*new T().start();
</span><span class="cm">
</span><span class="cm">        new Thread(){
</span><span class="cm">            @Override
</span><span class="cm">            public void run() {
</span><span class="cm">                System.out.println(&#34;Thread匿名内部类的任务&#34;);
</span><span class="cm">            }
</span><span class="cm">        }.start();
</span><span class="cm">
</span><span class="cm">        new Thread(new R()).start();
</span><span class="cm">
</span><span class="cm">        new Thread(new Runnable() {
</span><span class="cm">            @Override
</span><span class="cm">            public void run() {
</span><span class="cm">                System.out.println(&#34;Runnable匿名内部类的任务&#34;);
</span><span class="cm">            }
</span><span class="cm">        }).start();
</span><span class="cm">
</span><span class="cm">        new Thread(() -&gt; System.out.println(&#34;Runnable的lambda简化后的任务&#34;)).start();
</span><span class="cm">
</span><span class="cm">        FutureTask futureTask = new FutureTask&lt;&gt;(new C());
</span><span class="cm">        new Thread(futureTask).start();
</span><span class="cm">        try {
</span><span class="cm">            System.out.println(futureTask.get());
</span><span class="cm">        } catch (InterruptedException e) {
</span><span class="cm">            e.printStackTrace();
</span><span class="cm">        } catch (ExecutionException e) {
</span><span class="cm">            e.printStackTrace();
</span><span class="cm">        }*/</span>

        <span class="n">ExecutorService</span> <span class="n">executorService</span> <span class="o">=</span> <span class="n">Executors</span><span class="o">.</span><span class="na">newFixedThreadPool</span><span class="o">(</span><span class="n">10</span><span class="o">);</span>
        <span class="c1">//使用线程池执行实现Runnable接口的任务，任务没有返回值
</span><span class="c1"></span>        <span class="n">executorService</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="k">new</span> <span class="n">R</span><span class="o">());</span>

        <span class="c1">//使用线程池执行实现Runnable接口的任务，任务执行成功后，返回值为null
</span><span class="c1"></span>        <span class="n">Future</span><span class="o">&lt;?&gt;</span> <span class="n">future</span> <span class="o">=</span> <span class="n">executorService</span><span class="o">.</span><span class="na">submit</span><span class="o">(</span><span class="k">new</span> <span class="n">R</span><span class="o">());</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;future 执行结果：&#34;</span> <span class="o">+</span> <span class="n">future</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">ExecutionException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="c1">//使用线程池执行实现Callable接口的任务，可以接收到任务返回值
</span><span class="c1"></span>        <span class="n">Future</span> <span class="n">future1</span> <span class="o">=</span> <span class="n">executorService</span><span class="o">.</span><span class="na">submit</span><span class="o">(</span><span class="k">new</span> <span class="n">C</span><span class="o">());</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;future1 执行结果：&#34;</span> <span class="o">+</span> <span class="n">future1</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">ExecutionException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="n">Data</span> <span class="n">data</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Data</span><span class="o">();</span>
        <span class="n">Future</span><span class="o">&lt;</span><span class="n">Data</span><span class="o">&gt;</span> <span class="n">future2</span> <span class="o">=</span> <span class="n">executorService</span><span class="o">.</span><span class="na">submit</span><span class="o">(</span><span class="k">new</span> <span class="n">R</span><span class="o">(</span><span class="n">data</span><span class="o">),</span> <span class="n">data</span><span class="o">);</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;future2 执行结果：&#34;</span> <span class="o">+</span> <span class="n">future2</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">ExecutionException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="n">executorService</span><span class="o">.</span><span class="na">shutdown</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="上下文切换">上下文切换</h3>
<p>多核 cpu 下，多线程是并行工作的，如果线程数多，单个核又会并发的调度线程，运行时就会有上下文切换的概念。</p>
<p>cpu 执行线程的任务时，会为线程分配时间片，以下几种情况会发生上下文切换</p>
<ul>
<li>线程的 cpu 时间片用完</li>
<li>垃圾回收</li>
<li>线程自己调用了 sleep 、 yield 、 wait 、 join 、 park 、 synchronized 、 lock 等方法</li>
</ul>
<p>当发生上下文切换时，操作系统会保存当前线程的状态，并恢复另一个线程的状态， jvm 中有块内存地址叫程序计数器，用于记录线程执行到哪一行代码，是线程私有的。</p>
<p>idea 打断点的时候在断点上右键可以设置为 Thread 模式，idea 的 debug 模式可以看出栈帧的变化。</p>
<h3 id="线程的礼让---yield--线程优先级">线程的礼让 - yield() &amp; 线程优先级</h3>
<p>yield() 方法会让运行中的线程切换到就绪状态，重新争抢 cpu 的时间片，争抢时是否获取到时间片看 cpu 的分配。</p>
<p>yield() 定义如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="cm">/**
</span><span class="cm"> * A hint to the scheduler that the current thread is willing to yield
</span><span class="cm"> * its current use of a processor. The scheduler is free to ignore this
</span><span class="cm"> * hint.
</span><span class="cm"> *
</span><span class="cm"> * &lt;p&gt; Yield is a heuristic attempt to improve relative progression
</span><span class="cm"> * between threads that would otherwise over-utilise a CPU. Its use
</span><span class="cm"> * should be combined with detailed profiling and benchmarking to
</span><span class="cm"> * ensure that it actually has the desired effect.
</span><span class="cm"> *
</span><span class="cm"> * &lt;p&gt; It is rarely appropriate to use this method. It may be useful
</span><span class="cm"> * for debugging or testing purposes, where it may help to reproduce
</span><span class="cm"> * bugs due to race conditions. It may also be useful when designing
</span><span class="cm"> * concurrency control constructs such as the ones in the
</span><span class="cm"> * {@link java.util.concurrent.locks} package.
</span><span class="cm"> */</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kd">native</span> <span class="kt">void</span> <span class="nf">yield</span><span class="o">();</span>
</code></pre></td></tr></table>
</div>
</div><p>示例</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Runnable</span> <span class="n">r1</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(;;){</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;r1 ---&gt; &#34;</span> <span class="o">+</span> <span class="n">count</span><span class="o">++);</span>
        <span class="o">}</span>
    <span class="o">};</span>
    <span class="n">Runnable</span> <span class="n">r2</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(;;){</span>
            <span class="n">Thread</span><span class="o">.</span><span class="na">yield</span><span class="o">();</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;r2 ---&gt; &#34;</span> <span class="o">+</span> <span class="n">count</span><span class="o">++);</span>
        <span class="o">}</span>
    <span class="o">};</span>

    <span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="n">r1</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>
    <span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="n">r2</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>运行结果</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">r1 ---&gt; 755182
r1 ---&gt; 755183
r1 ---&gt; 755184
r1 ---&gt; 755185
r1 ---&gt; 755186
r2 ---&gt; 35811
r1 ---&gt; 755187
r1 ---&gt; 755188
r1 ---&gt; 755189
r1 ---&gt; 755190
r1 ---&gt; 755191
</code></pre></td></tr></table>
</div>
</div><p>可以看到， t2 线程每次执行时进行了 yield() ，线程1执行的机会明显比线程2要多。</p>
<p><strong>线程优先级</strong></p>
<p>线程内部用 1~10 来调整线程的优先级，默认的线程优先级为 <code>NORM_PRIORITY = 5</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="cm">/**
</span><span class="cm"> * The minimum priority that a thread can have.
</span><span class="cm"> */</span>
<span class="kd">public</span> <span class="kd">final</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">MIN_PRIORITY</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span>

<span class="cm">/**
</span><span class="cm"> * The default priority that is assigned to a thread.
</span><span class="cm"> */</span>
<span class="kd">public</span> <span class="kd">final</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">NORM_PRIORITY</span> <span class="o">=</span> <span class="n">5</span><span class="o">;</span>

<span class="cm">/**
</span><span class="cm"> * The maximum priority that a thread can have.
</span><span class="cm"> */</span>
<span class="kd">public</span> <span class="kd">final</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">MAX_PRIORITY</span> <span class="o">=</span> <span class="n">10</span><span class="o">;</span>


<span class="cm">/**
</span><span class="cm"> * Changes the priority of this thread.
</span><span class="cm"> * &lt;p&gt;
</span><span class="cm"> * First the &lt;code&gt;checkAccess&lt;/code&gt; method of this thread is called
</span><span class="cm"> * with no arguments. This may result in throwing a
</span><span class="cm"> * &lt;code&gt;SecurityException&lt;/code&gt;.
</span><span class="cm"> * &lt;p&gt;
</span><span class="cm"> * Otherwise, the priority of this thread is set to the smaller of
</span><span class="cm"> * the specified &lt;code&gt;newPriority&lt;/code&gt; and the maximum permitted
</span><span class="cm"> * priority of the thread&#39;s thread group.
</span><span class="cm"> *
</span><span class="cm"> * @param newPriority priority to set this thread to
</span><span class="cm"> * @exception  IllegalArgumentException  If the priority is not in the
</span><span class="cm"> *               range &lt;code&gt;MIN_PRIORITY&lt;/code&gt; to
</span><span class="cm"> *               &lt;code&gt;MAX_PRIORITY&lt;/code&gt;.
</span><span class="cm"> * @exception  SecurityException  if the current thread cannot modify
</span><span class="cm"> *               this thread.
</span><span class="cm"> * @see        #getPriority
</span><span class="cm"> * @see        #checkAccess()
</span><span class="cm"> * @see        #getThreadGroup()
</span><span class="cm"> * @see        #MAX_PRIORITY
</span><span class="cm"> * @see        #MIN_PRIORITY
</span><span class="cm"> * @see        ThreadGroup#getMaxPriority()
</span><span class="cm"> */</span>
<span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">setPriority</span><span class="o">(</span><span class="kt">int</span> <span class="n">newPriority</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">ThreadGroup</span> <span class="n">g</span><span class="o">;</span>
    <span class="n">checkAccess</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">newPriority</span> <span class="o">&gt;</span> <span class="n">MAX_PRIORITY</span> <span class="o">||</span> <span class="n">newPriority</span> <span class="o">&lt;</span> <span class="n">MIN_PRIORITY</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="k">if</span><span class="o">((</span><span class="n">g</span> <span class="o">=</span> <span class="n">getThreadGroup</span><span class="o">())</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">newPriority</span> <span class="o">&gt;</span> <span class="n">g</span><span class="o">.</span><span class="na">getMaxPriority</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">newPriority</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="na">getMaxPriority</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="n">setPriority0</span><span class="o">(</span><span class="n">priority</span> <span class="o">=</span> <span class="n">newPriority</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>cpu 比较忙时，优先级高的线程获取更多的时间片</p>
<p>cpu 比较闲时，优先级设置基本没用。</p>
<p>cpu 比较忙时，示例</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Runnable</span> <span class="n">r1</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(;;){</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;r1 ---&gt; &#34;</span> <span class="o">+</span> <span class="n">count</span><span class="o">++);</span>
        <span class="o">}</span>
    <span class="o">};</span>
    <span class="n">Runnable</span> <span class="n">r2</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(;;){</span>
            <span class="c1">//Thread.yield();
</span><span class="c1"></span>            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;r2 ---&gt; &#34;</span> <span class="o">+</span> <span class="n">count</span><span class="o">++);</span>
        <span class="o">}</span>
    <span class="o">};</span>

    <span class="n">Thread</span> <span class="n">t1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="n">r1</span><span class="o">);</span>
    <span class="n">t1</span><span class="o">.</span><span class="na">setPriority</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">NORM_PRIORITY</span><span class="o">);</span>
    <span class="n">t1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>

    <span class="n">Thread</span> <span class="n">t2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="n">r2</span><span class="o">);</span>
    <span class="n">t2</span><span class="o">.</span><span class="na">setPriority</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">MAX_PRIORITY</span><span class="o">);</span>
    <span class="n">t2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>运行结果</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">r2 ---&gt; 225257
r2 ---&gt; 225258
r2 ---&gt; 225259
r1 ---&gt; 35545
r1 ---&gt; 35546
r1 ---&gt; 35547
r2 ---&gt; 225260
r2 ---&gt; 225261
r2 ---&gt; 225262
r2 ---&gt; 225263
</code></pre></td></tr></table>
</div>
</div><p>cpu 比较闲时，示例</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Runnable</span> <span class="n">r1</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">10</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;r1 ---&gt; &#34;</span> <span class="o">+</span> <span class="n">count</span><span class="o">++);</span>
        <span class="o">}</span>
    <span class="o">};</span>
    <span class="n">Runnable</span> <span class="n">r2</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">10</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">//Thread.yield();
</span><span class="c1"></span>            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;r2 ---&gt; &#34;</span> <span class="o">+</span> <span class="n">count</span><span class="o">++);</span>
        <span class="o">}</span>
    <span class="o">};</span>

    <span class="n">Thread</span> <span class="n">t1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="n">r1</span><span class="o">);</span>
    <span class="n">t1</span><span class="o">.</span><span class="na">setPriority</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">NORM_PRIORITY</span><span class="o">);</span>
    <span class="n">t1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>

    <span class="n">Thread</span> <span class="n">t2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="n">r2</span><span class="o">);</span>
    <span class="n">t2</span><span class="o">.</span><span class="na">setPriority</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">MAX_PRIORITY</span><span class="o">);</span>
    <span class="n">t2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>运行结果（可能的结果：t1优先级低，却先运行完）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">r1 ---&gt; 0
r1 ---&gt; 1
r1 ---&gt; 2
r1 ---&gt; 3
r1 ---&gt; 4
r1 ---&gt; 5
r2 ---&gt; 0
r2 ---&gt; 1
r2 ---&gt; 2
r2 ---&gt; 3
r2 ---&gt; 4
r2 ---&gt; 5
r2 ---&gt; 6
r2 ---&gt; 7
r2 ---&gt; 8
r2 ---&gt; 9
r1 ---&gt; 6
r1 ---&gt; 7
r1 ---&gt; 8
r1 ---&gt; 9
</code></pre></td></tr></table>
</div>
</div><h3 id="守护线程">守护线程</h3>
<p>默认情况下， java 进程需要等待所有线程都运行结束，才会结束，但有一种特殊线程叫守护线程，当所有非守护线程都结束后，即使它没有执行完，也会强制结束。</p>
<p>默认的线程都是非守护线程。</p>
<p>垃圾回收线程就是典型的守护线程</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Thread</span> <span class="n">thread</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">){</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;thread running ...&#34;</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">});</span>
    <span class="c1">//true 将该线程设置为守护线程，主线程结束后，守护线程也会终止运行
</span><span class="c1"></span>    <span class="c1">//false 默认值，线程为非守护线程，主线程结束后，该线程还会继续运行
</span><span class="c1"></span>    <span class="n">thread</span><span class="o">.</span><span class="na">setDaemon</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
    <span class="n">thread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;主线程结束运行&#34;</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="线程的阻塞">线程的阻塞</h3>
<p>线程的阻塞可以分为好多种，从操作系统层面和 java 层面阻塞的定义可能不同，但是广义上使得线程阻塞的方式有下面几种</p>
<ul>
<li>BIO 阻塞，即使用了阻塞式的 io 流</li>
<li>sleep(long time) 让线程休眠进入阻塞状态</li>
<li>a.join() 调用该方法的线程进入阻塞，等待 a 线程执行完恢复运行</li>
<li>sychronized 或 ReentrantLock 造成线程未获得锁而进入阻塞状态</li>
<li>线程获得锁后调用 wait() 方法，也会进入阻塞状态</li>
<li>LockSupport.park() 让线程进入阻塞状态</li>
</ul>
<h4 id="sleep">sleep()</h4>
<p>sleep() 会让线程休眠，将运行中的线程进入阻塞状态。当休眠时间结束后，重新争抢 cpu 的时间片继续运行</p>
<p>sleep() 方法定义如下</p>
<p>java.lang.Thread#sleep(long)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="cm">/**
</span><span class="cm"> * Causes the currently executing thread to sleep (temporarily cease
</span><span class="cm"> * execution) for the specified number of milliseconds, subject to
</span><span class="cm"> * the precision and accuracy of system timers and schedulers. The thread
</span><span class="cm"> * does not lose ownership of any monitors.
</span><span class="cm"> *
</span><span class="cm"> * @param  millis
</span><span class="cm"> *         the length of time to sleep in milliseconds
</span><span class="cm"> *
</span><span class="cm"> * @throws  IllegalArgumentException
</span><span class="cm"> *          if the value of {@code millis} is negative
</span><span class="cm"> *
</span><span class="cm"> * @throws  InterruptedException
</span><span class="cm"> *          if any thread has interrupted the current thread. The
</span><span class="cm"> *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is
</span><span class="cm"> *          cleared when this exception is thrown.
</span><span class="cm"> */</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kd">native</span> <span class="kt">void</span> <span class="nf">sleep</span><span class="o">(</span><span class="kt">long</span> <span class="n">millis</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><p>示例</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="c1">//休眠2秒，休眠过程可被中断，中断后抛出 InterruptedException
</span><span class="c1"></span>        <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="n">2000</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="k">try</span> <span class="o">{</span>
        <span class="c1">//使用TimeUnit的api可替代Thread.sleep
</span><span class="c1"></span>        <span class="n">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="n">1</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="join">join()</h4>
<p>join() 的作用是 join() 方法所在的线程进入阻塞状态，等待调用 join() 方法的线程执行完后join() 方法所在的线程恢复运行</p>
<p>join() 方法可以指定时间，指定时间结束后，若调用join()的线程还未执行完，join() 方法所在线程不继续等待就恢复运行</p>
<p>join() 的定义如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="cm">/**
</span><span class="cm"> * Waits at most {@code millis} milliseconds for this thread to
</span><span class="cm"> * die. A timeout of {@code 0} means to wait forever.
</span><span class="cm"> *
</span><span class="cm"> * &lt;p&gt; This implementation uses a loop of {@code this.wait} calls
</span><span class="cm"> * conditioned on {@code this.isAlive}. As a thread terminates the
</span><span class="cm"> * {@code this.notifyAll} method is invoked. It is recommended that
</span><span class="cm"> * applications not use {@code wait}, {@code notify}, or
</span><span class="cm"> * {@code notifyAll} on {@code Thread} instances.
</span><span class="cm"> *
</span><span class="cm"> * @param  millis
</span><span class="cm"> *         the time to wait in milliseconds
</span><span class="cm"> *
</span><span class="cm"> * @throws  IllegalArgumentException
</span><span class="cm"> *          if the value of {@code millis} is negative
</span><span class="cm"> *
</span><span class="cm"> * @throws  InterruptedException
</span><span class="cm"> *          if any thread has interrupted the current thread. The
</span><span class="cm"> *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is
</span><span class="cm"> *          cleared when this exception is thrown.
</span><span class="cm"> */</span>
<span class="kd">public</span> <span class="kd">final</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">join</span><span class="o">(</span><span class="kt">long</span> <span class="n">millis</span><span class="o">)</span>
<span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
    <span class="kt">long</span> <span class="n">base</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
    <span class="kt">long</span> <span class="n">now</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">millis</span> <span class="o">&lt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">(</span><span class="s">&#34;timeout value is negative&#34;</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">millis</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">isAlive</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">wait</span><span class="o">(</span><span class="n">0</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">isAlive</span><span class="o">())</span> <span class="o">{</span>
            <span class="kt">long</span> <span class="n">delay</span> <span class="o">=</span> <span class="n">millis</span> <span class="o">-</span> <span class="n">now</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">delay</span> <span class="o">&lt;=</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">wait</span><span class="o">(</span><span class="n">delay</span><span class="o">);</span>
            <span class="n">now</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">()</span> <span class="o">-</span> <span class="n">base</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/**
</span><span class="cm"> * Waits at most {@code millis} milliseconds plus
</span><span class="cm"> * {@code nanos} nanoseconds for this thread to die.
</span><span class="cm"> *
</span><span class="cm"> * &lt;p&gt; This implementation uses a loop of {@code this.wait} calls
</span><span class="cm"> * conditioned on {@code this.isAlive}. As a thread terminates the
</span><span class="cm"> * {@code this.notifyAll} method is invoked. It is recommended that
</span><span class="cm"> * applications not use {@code wait}, {@code notify}, or
</span><span class="cm"> * {@code notifyAll} on {@code Thread} instances.
</span><span class="cm"> *
</span><span class="cm"> * @param  millis
</span><span class="cm"> *         the time to wait in milliseconds
</span><span class="cm"> *
</span><span class="cm"> * @param  nanos
</span><span class="cm"> *         {@code 0-999999} additional nanoseconds to wait
</span><span class="cm"> *
</span><span class="cm"> * @throws  IllegalArgumentException
</span><span class="cm"> *          if the value of {@code millis} is negative, or the value
</span><span class="cm"> *          of {@code nanos} is not in the range {@code 0-999999}
</span><span class="cm"> *
</span><span class="cm"> * @throws  InterruptedException
</span><span class="cm"> *          if any thread has interrupted the current thread. The
</span><span class="cm"> *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is
</span><span class="cm"> *          cleared when this exception is thrown.
</span><span class="cm"> */</span>
<span class="kd">public</span> <span class="kd">final</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">join</span><span class="o">(</span><span class="kt">long</span> <span class="n">millis</span><span class="o">,</span> <span class="kt">int</span> <span class="n">nanos</span><span class="o">)</span>
<span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">millis</span> <span class="o">&lt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">(</span><span class="s">&#34;timeout value is negative&#34;</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">nanos</span> <span class="o">&lt;</span> <span class="n">0</span> <span class="o">||</span> <span class="n">nanos</span> <span class="o">&gt;</span> <span class="n">999999</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">(</span>
                            <span class="s">&#34;nanosecond timeout value out of range&#34;</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">nanos</span> <span class="o">&gt;=</span> <span class="n">500000</span> <span class="o">||</span> <span class="o">(</span><span class="n">nanos</span> <span class="o">!=</span> <span class="n">0</span> <span class="o">&amp;&amp;</span> <span class="n">millis</span> <span class="o">==</span> <span class="n">0</span><span class="o">))</span> <span class="o">{</span>
        <span class="n">millis</span><span class="o">++;</span>
    <span class="o">}</span>

    <span class="n">join</span><span class="o">(</span><span class="n">millis</span><span class="o">);</span>
<span class="o">}</span>

<span class="cm">/**
</span><span class="cm"> * Waits for this thread to die.
</span><span class="cm"> *
</span><span class="cm"> * &lt;p&gt; An invocation of this method behaves in exactly the same
</span><span class="cm"> * way as the invocation
</span><span class="cm"> *
</span><span class="cm"> * &lt;blockquote&gt;
</span><span class="cm"> * {@linkplain #join(long) join}{@code (0)}
</span><span class="cm"> * &lt;/blockquote&gt;
</span><span class="cm"> *
</span><span class="cm"> * @throws  InterruptedException
</span><span class="cm"> *          if any thread has interrupted the current thread. The
</span><span class="cm"> *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is
</span><span class="cm"> *          cleared when this exception is thrown.
</span><span class="cm"> */</span>
<span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">join</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
    <span class="n">join</span><span class="o">(</span><span class="n">0</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>示例</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Integer</span> <span class="n">r</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
    <span class="n">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="k">try</span><span class="o">{</span>
            <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="n">3000</span><span class="o">);</span>
        <span class="o">}</span><span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">){</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;子线程运行结束&#34;</span><span class="o">);</span>
    <span class="o">});</span>

    <span class="n">t</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>

    <span class="k">try</span> <span class="o">{</span>
        <span class="n">t</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;主线程运行结束&#34;</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>输出结果：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">子线程运行结束
主线程运行结束
</code></pre></td></tr></table>
</div>
</div><p>若注释掉 t.join() 所在的代码块，或者配置 t.join(1000) ，则运行结果如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">主线程运行结束
子线程运行结束
</code></pre></td></tr></table>
</div>
</div><h4 id="interrupt">interrupt()</h4>
<p>线程的打断标记</p>
<ul>
<li>true 表示线程被打断</li>
<li>false 表示线程未被打断</li>
</ul>
<p>interrupt() 打断当前线程</p>
<ul>
<li>Unless the current thread is interrupting itself, which is always permitted, the checkAccess method of this thread is invoked, which may cause a SecurityException to be thrown.</li>
<li>可以打断 sleep 、 wait 、 join 等显式的抛出 InterruptedException 方法的线程，但是打断后线程的标记还是 false
<ul>
<li>If this thread is blocked in an invocation of the wait(), wait(long), or wait(long, int) methods of the Object class, or of the join(), join(long), join(long, int), sleep(long), or sleep(long, int), methods of this class, then its interrupt status will be cleared and it will receive an InterruptedException.</li>
</ul>
</li>
<li>If this thread is blocked in an I/O operation upon an InterruptibleChannel then the channel will be closed, the thread&rsquo;s interrupt status will be set, and the thread will receive a java.nio.channels.ClosedByInterruptException.</li>
<li>If this thread is blocked in a java.nio.channels.Selector then the thread&rsquo;s interrupt status will be set and it will return immediately from the selection operation, possibly with a non-zero value, just as if the selector&rsquo;s wakeup method were invoked.</li>
<li>打断正常线程，线程不会真正被中断，但是线程的打断标记为 true
<ul>
<li>If none of the previous conditions hold then this thread&rsquo;s interrupt status will be set.</li>
</ul>
</li>
<li>Interrupting a thread that is not alive need not have any effect.</li>
</ul>
<p>isInterrupted() 获取线程的打断标记，调用后不会修改线程的打断标记</p>
<ul>
<li>Tests whether this thread has been interrupted. The interrupted status of the thread is unaffected by this method.</li>
</ul>
<p>interrupted() 获取线程的打断标记，调用后清空打断标记，即如果获取的打断标记为 true ，调用该方法后会将打断标记置为 false</p>
<ul>
<li>Tests whether the current thread has been interrupted. The interrupted status of the thread is cleared by this method. In other words, if this method were to be called twice in succession, the second call would return false (unless the current thread were interrupted again, after the first call had cleared its interrupted status and before the second call had examined it).</li>
</ul>
<p>定义如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="cm">/**
</span><span class="cm"> * Interrupts this thread.
</span><span class="cm"> *
</span><span class="cm"> * &lt;p&gt; Unless the current thread is interrupting itself, which is
</span><span class="cm"> * always permitted, the {@link #checkAccess() checkAccess} method
</span><span class="cm"> * of this thread is invoked, which may cause a {@link
</span><span class="cm"> * SecurityException} to be thrown.
</span><span class="cm"> *
</span><span class="cm"> * &lt;p&gt; If this thread is blocked in an invocation of the {@link
</span><span class="cm"> * Object#wait() wait()}, {@link Object#wait(long) wait(long)}, or {@link
</span><span class="cm"> * Object#wait(long, int) wait(long, int)} methods of the {@link Object}
</span><span class="cm"> * class, or of the {@link #join()}, {@link #join(long)}, {@link
</span><span class="cm"> * #join(long, int)}, {@link #sleep(long)}, or {@link #sleep(long, int)},
</span><span class="cm"> * methods of this class, then its interrupt status will be cleared and it
</span><span class="cm"> * will receive an {@link InterruptedException}.
</span><span class="cm"> *
</span><span class="cm"> * &lt;p&gt; If this thread is blocked in an I/O operation upon an {@link
</span><span class="cm"> * java.nio.channels.InterruptibleChannel InterruptibleChannel}
</span><span class="cm"> * then the channel will be closed, the thread&#39;s interrupt
</span><span class="cm"> * status will be set, and the thread will receive a {@link
</span><span class="cm"> * java.nio.channels.ClosedByInterruptException}.
</span><span class="cm"> *
</span><span class="cm"> * &lt;p&gt; If this thread is blocked in a {@link java.nio.channels.Selector}
</span><span class="cm"> * then the thread&#39;s interrupt status will be set and it will return
</span><span class="cm"> * immediately from the selection operation, possibly with a non-zero
</span><span class="cm"> * value, just as if the selector&#39;s {@link
</span><span class="cm"> * java.nio.channels.Selector#wakeup wakeup} method were invoked.
</span><span class="cm"> *
</span><span class="cm"> * &lt;p&gt; If none of the previous conditions hold then this thread&#39;s interrupt
</span><span class="cm"> * status will be set. &lt;/p&gt;
</span><span class="cm"> *
</span><span class="cm"> * &lt;p&gt; Interrupting a thread that is not alive need not have any effect.
</span><span class="cm"> *
</span><span class="cm"> * @throws  SecurityException
</span><span class="cm"> *          if the current thread cannot modify this thread
</span><span class="cm"> *
</span><span class="cm"> * @revised 6.0
</span><span class="cm"> * @spec JSR-51
</span><span class="cm"> */</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">interrupt</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="k">this</span> <span class="o">!=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">())</span>
        <span class="n">checkAccess</span><span class="o">();</span>

    <span class="kd">synchronized</span> <span class="o">(</span><span class="n">blockerLock</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Interruptible</span> <span class="n">b</span> <span class="o">=</span> <span class="n">blocker</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">b</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">interrupt0</span><span class="o">();</span>           <span class="c1">// Just to set the interrupt flag
</span><span class="c1"></span>            <span class="n">b</span><span class="o">.</span><span class="na">interrupt</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="n">interrupt0</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kd">native</span> <span class="kt">void</span> <span class="nf">interrupt0</span><span class="o">();</span>


<span class="cm">/**
</span><span class="cm"> * Tests whether the current thread has been interrupted.  The
</span><span class="cm"> * &lt;i&gt;interrupted status&lt;/i&gt; of the thread is cleared by this method.  In
</span><span class="cm"> * other words, if this method were to be called twice in succession, the
</span><span class="cm"> * second call would return false (unless the current thread were
</span><span class="cm"> * interrupted again, after the first call had cleared its interrupted
</span><span class="cm"> * status and before the second call had examined it).
</span><span class="cm"> *
</span><span class="cm"> * &lt;p&gt;A thread interruption ignored because a thread was not alive
</span><span class="cm"> * at the time of the interrupt will be reflected by this method
</span><span class="cm"> * returning false.
</span><span class="cm"> *
</span><span class="cm"> * @return  &lt;code&gt;true&lt;/code&gt; if the current thread has been interrupted;
</span><span class="cm"> *          &lt;code&gt;false&lt;/code&gt; otherwise.
</span><span class="cm"> * @see #isInterrupted()
</span><span class="cm"> * @revised 6.0
</span><span class="cm"> */</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">interrupted</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">currentThread</span><span class="o">().</span><span class="na">isInterrupted</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
<span class="o">}</span>


<span class="cm">/**
</span><span class="cm"> * Tests whether this thread has been interrupted.  The &lt;i&gt;interrupted
</span><span class="cm"> * status&lt;/i&gt; of the thread is unaffected by this method.
</span><span class="cm"> *
</span><span class="cm"> * &lt;p&gt;A thread interruption ignored because a thread was not alive
</span><span class="cm"> * at the time of the interrupt will be reflected by this method
</span><span class="cm"> * returning false.
</span><span class="cm"> *
</span><span class="cm"> * @return  &lt;code&gt;true&lt;/code&gt; if this thread has been interrupted;
</span><span class="cm"> *          &lt;code&gt;false&lt;/code&gt; otherwise.
</span><span class="cm"> * @see     #interrupted()
</span><span class="cm"> * @revised 6.0
</span><span class="cm"> */</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isInterrupted</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">isInterrupted</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
<span class="o">}</span>

<span class="cm">/**
</span><span class="cm"> * Tests if some Thread has been interrupted.  The interrupted state
</span><span class="cm"> * is reset or not based on the value of ClearInterrupted that is
</span><span class="cm"> * passed.
</span><span class="cm"> */</span>
<span class="kd">private</span> <span class="kd">native</span> <span class="kt">boolean</span> <span class="nf">isInterrupted</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">ClearInterrupted</span><span class="o">);</span>

</code></pre></td></tr></table>
</div>
</div><p>示例代码如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="cm">/**
</span><span class="cm"> * ThreadTest
</span><span class="cm"> * 
</span><span class="cm"> * @author: hekai
</span><span class="cm"> */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ThreadTest</span> <span class="o">{</span>

    <span class="c1">// 监控线程
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">static</span> <span class="n">Thread</span> <span class="n">monitor</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">start</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">monitor</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">Thread</span> <span class="n">thread</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
                <span class="c1">// 判断当前线程释放被打断
</span><span class="c1"></span>                <span class="k">if</span> <span class="o">(</span><span class="n">thread</span><span class="o">.</span><span class="na">isInterrupted</span><span class="o">())</span> <span class="o">{</span>
                    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;当前线程被打断，结束运行&#34;</span><span class="o">);</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>

                <span class="k">try</span> <span class="o">{</span>
                    <span class="c1">// 打断 sleep 、 wait 、 join 等显式的抛出 InterruptedException 方法的线程时，
</span><span class="c1"></span>                    <span class="c1">// 打断后线程的标记还是 false ，需要在异常捕获处将打断标记置为 true
</span><span class="c1"></span>                    <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="n">1000</span><span class="o">);</span>
                    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;线程监控中...&#34;</span><span class="o">);</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">// 若睡眠被打断时跑出异常，在该处捕获
</span><span class="c1"></span>                    <span class="c1">// 再调用一次打断，使打断标记置为true
</span><span class="c1"></span>                    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;睡眠被打断时抛出了异常...&#34;</span><span class="o">);</span>
                    <span class="n">thread</span><span class="o">.</span><span class="na">interrupt</span><span class="o">();</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">});</span>

        <span class="n">monitor</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">stop</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">monitor</span><span class="o">.</span><span class="na">interrupt</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">start</span><span class="o">();</span>

        <span class="k">try</span> <span class="o">{</span>
            <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="n">30000</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="n">stop</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="线程的状态">线程的状态</h3>
<p>线程的状态从操作系统层面可分为五种，从 java api 层面可分为六种。</p>
<p>五种状态</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/images/20210220-%e7%ba%bf%e7%a8%8b%e7%9a%84%e4%ba%94%e7%a7%8d%e7%8a%b6%e6%80%81.png"
        data-srcset="/images/20210220-%e7%ba%bf%e7%a8%8b%e7%9a%84%e4%ba%94%e7%a7%8d%e7%8a%b6%e6%80%81.png, /images/20210220-%e7%ba%bf%e7%a8%8b%e7%9a%84%e4%ba%94%e7%a7%8d%e7%8a%b6%e6%80%81.png 1.5x, /images/20210220-%e7%ba%bf%e7%a8%8b%e7%9a%84%e4%ba%94%e7%a7%8d%e7%8a%b6%e6%80%81.png 2x"
        data-sizes="auto"
        alt="/images/20210220-线程的五种状态.png"
        title="线程的五种状态" /></p>
<ul>
<li>初始状态：创建线程对象时的状态</li>
<li>可运行状态（就绪状态）：调用 start() 方法后进入就绪状态，也就是准备好被 cpu 调度执行</li>
<li>运行状态：线程获取到 cpu 时间片，执行 run() 方法</li>
<li>阻塞状态：线程被阻塞，放弃 cpu 的控制权，等待解除阻塞后重新回到就绪状态争抢 cpu 时间片</li>
<li>终止状态：线程执行完成或者跑出异常后的状态</li>
</ul>
<p>六种状态</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/images/20210220-%e7%ba%bf%e7%a8%8b%e7%9a%84%e5%85%ad%e7%a7%8d%e7%8a%b6%e6%80%81.png"
        data-srcset="/images/20210220-%e7%ba%bf%e7%a8%8b%e7%9a%84%e5%85%ad%e7%a7%8d%e7%8a%b6%e6%80%81.png, /images/20210220-%e7%ba%bf%e7%a8%8b%e7%9a%84%e5%85%ad%e7%a7%8d%e7%8a%b6%e6%80%81.png 1.5x, /images/20210220-%e7%ba%bf%e7%a8%8b%e7%9a%84%e5%85%ad%e7%a7%8d%e7%8a%b6%e6%80%81.png 2x"
        data-sizes="auto"
        alt="/images/20210220-线程的六种状态.png"
        title="线程的六种状态" /></p>
<p>java.lang.Thread 类中的内部内举状态</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span><span class="lnt">93
</span><span class="lnt">94
</span><span class="lnt">95
</span><span class="lnt">96
</span><span class="lnt">97
</span><span class="lnt">98
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="cm">/**
</span><span class="cm"> * A thread state.  A thread can be in one of the following states:
</span><span class="cm"> * &lt;ul&gt;
</span><span class="cm"> * &lt;li&gt;{@link #NEW}&lt;br&gt;
</span><span class="cm"> *     A thread that has not yet started is in this state.
</span><span class="cm"> *     &lt;/li&gt;
</span><span class="cm"> * &lt;li&gt;{@link #RUNNABLE}&lt;br&gt;
</span><span class="cm"> *     A thread executing in the Java virtual machine is in this state.
</span><span class="cm"> *     &lt;/li&gt;
</span><span class="cm"> * &lt;li&gt;{@link #BLOCKED}&lt;br&gt;
</span><span class="cm"> *     A thread that is blocked waiting for a monitor lock
</span><span class="cm"> *     is in this state.
</span><span class="cm"> *     &lt;/li&gt;
</span><span class="cm"> * &lt;li&gt;{@link #WAITING}&lt;br&gt;
</span><span class="cm"> *     A thread that is waiting indefinitely for another thread to
</span><span class="cm"> *     perform a particular action is in this state.
</span><span class="cm"> *     &lt;/li&gt;
</span><span class="cm"> * &lt;li&gt;{@link #TIMED_WAITING}&lt;br&gt;
</span><span class="cm"> *     A thread that is waiting for another thread to perform an action
</span><span class="cm"> *     for up to a specified waiting time is in this state.
</span><span class="cm"> *     &lt;/li&gt;
</span><span class="cm"> * &lt;li&gt;{@link #TERMINATED}&lt;br&gt;
</span><span class="cm"> *     A thread that has exited is in this state.
</span><span class="cm"> *     &lt;/li&gt;
</span><span class="cm"> * &lt;/ul&gt;
</span><span class="cm"> *
</span><span class="cm"> * &lt;p&gt;
</span><span class="cm"> * A thread can be in only one state at a given point in time.
</span><span class="cm"> * These states are virtual machine states which do not reflect
</span><span class="cm"> * any operating system thread states.
</span><span class="cm"> *
</span><span class="cm"> * @since   1.5
</span><span class="cm"> * @see #getState
</span><span class="cm"> */</span>
<span class="kd">public</span> <span class="kd">enum</span> <span class="n">State</span> <span class="o">{</span>
    <span class="cm">/**
</span><span class="cm">     * Thread state for a thread which has not yet started.
</span><span class="cm">     */</span>
    <span class="n">NEW</span><span class="o">,</span>

    <span class="cm">/**
</span><span class="cm">     * Thread state for a runnable thread.  A thread in the runnable
</span><span class="cm">     * state is executing in the Java virtual machine but it may
</span><span class="cm">     * be waiting for other resources from the operating system
</span><span class="cm">     * such as processor.
</span><span class="cm">     */</span>
    <span class="n">RUNNABLE</span><span class="o">,</span>

    <span class="cm">/**
</span><span class="cm">     * Thread state for a thread blocked waiting for a monitor lock.
</span><span class="cm">     * A thread in the blocked state is waiting for a monitor lock
</span><span class="cm">     * to enter a synchronized block/method or
</span><span class="cm">     * reenter a synchronized block/method after calling
</span><span class="cm">     * {@link Object#wait() Object.wait}.
</span><span class="cm">     */</span>
    <span class="n">BLOCKED</span><span class="o">,</span>

    <span class="cm">/**
</span><span class="cm">     * Thread state for a waiting thread.
</span><span class="cm">     * A thread is in the waiting state due to calling one of the
</span><span class="cm">     * following methods:
</span><span class="cm">     * &lt;ul&gt;
</span><span class="cm">     *   &lt;li&gt;{@link Object#wait() Object.wait} with no timeout&lt;/li&gt;
</span><span class="cm">     *   &lt;li&gt;{@link #join() Thread.join} with no timeout&lt;/li&gt;
</span><span class="cm">     *   &lt;li&gt;{@link LockSupport#park() LockSupport.park}&lt;/li&gt;
</span><span class="cm">     * &lt;/ul&gt;
</span><span class="cm">     *
</span><span class="cm">     * &lt;p&gt;A thread in the waiting state is waiting for another thread to
</span><span class="cm">     * perform a particular action.
</span><span class="cm">     *
</span><span class="cm">     * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;
</span><span class="cm">     * on an object is waiting for another thread to call
</span><span class="cm">     * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on
</span><span class="cm">     * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;
</span><span class="cm">     * is waiting for a specified thread to terminate.
</span><span class="cm">     */</span>
    <span class="n">WAITING</span><span class="o">,</span>

    <span class="cm">/**
</span><span class="cm">     * Thread state for a waiting thread with a specified waiting time.
</span><span class="cm">     * A thread is in the timed waiting state due to calling one of
</span><span class="cm">     * the following methods with a specified positive waiting time:
</span><span class="cm">     * &lt;ul&gt;
</span><span class="cm">     *   &lt;li&gt;{@link #sleep Thread.sleep}&lt;/li&gt;
</span><span class="cm">     *   &lt;li&gt;{@link Object#wait(long) Object.wait} with timeout&lt;/li&gt;
</span><span class="cm">     *   &lt;li&gt;{@link #join(long) Thread.join} with timeout&lt;/li&gt;
</span><span class="cm">     *   &lt;li&gt;{@link LockSupport#parkNanos LockSupport.parkNanos}&lt;/li&gt;
</span><span class="cm">     *   &lt;li&gt;{@link LockSupport#parkUntil LockSupport.parkUntil}&lt;/li&gt;
</span><span class="cm">     * &lt;/ul&gt;
</span><span class="cm">     */</span>
    <span class="n">TIMED_WAITING</span><span class="o">,</span>

    <span class="cm">/**
</span><span class="cm">     * Thread state for a terminated thread.
</span><span class="cm">     * The thread has completed execution.
</span><span class="cm">     */</span>
    <span class="n">TERMINATED</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>New: 线程对象被创建</li>
<li>Runnable: 线程调用了 start() 方法后进入该状态，该状态包含三种情况
<ul>
<li>就绪状态：等待 cpu 分配时间片</li>
<li>运行状态：进入 Runnable 方法执行任务</li>
<li>阻塞状态：BIO 执行阻塞式 io 流时的状态</li>
</ul>
</li>
<li>Blocked: 没有获取到锁时的阻塞状态</li>
<li>WAITING: 调用 wait()、join() 等方法后的状态</li>
<li>TIMED_WAITING: 调用 sleep(time)、wait(time)、join(time)等方法后的状态</li>
<li>TERMINATED: 线程执行完成或抛出异常后的状态</li>
</ul>
<p>六种线程状态和java api方法的对应关系如下：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/images/20210220-%e5%85%ad%e7%a7%8d%e7%ba%bf%e7%a8%8b%e7%8a%b6%e6%80%81%e5%92%8capi%e6%96%b9%e6%b3%95%e5%af%b9%e5%ba%94%e5%85%b3%e7%b3%bb.png"
        data-srcset="/images/20210220-%e5%85%ad%e7%a7%8d%e7%ba%bf%e7%a8%8b%e7%8a%b6%e6%80%81%e5%92%8capi%e6%96%b9%e6%b3%95%e5%af%b9%e5%ba%94%e5%85%b3%e7%b3%bb.png, /images/20210220-%e5%85%ad%e7%a7%8d%e7%ba%bf%e7%a8%8b%e7%8a%b6%e6%80%81%e5%92%8capi%e6%96%b9%e6%b3%95%e5%af%b9%e5%ba%94%e5%85%b3%e7%b3%bb.png 1.5x, /images/20210220-%e5%85%ad%e7%a7%8d%e7%ba%bf%e7%a8%8b%e7%8a%b6%e6%80%81%e5%92%8capi%e6%96%b9%e6%b3%95%e5%af%b9%e5%ba%94%e5%85%b3%e7%b3%bb.png 2x"
        data-sizes="auto"
        alt="/images/20210220-六种线程状态和api方法对应关系.png"
        title="六种线程状态和api方法对应关系" /></p>
<h3 id="线程的相关方法总结">线程的相关方法总结</h3>
<p>Thread 类的核心方法</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>是否 static</th>
<th>方法说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>start()</td>
<td>否</td>
<td>让线程启动，进入就绪状态，等待cpu分配时间片</td>
</tr>
<tr>
<td>run()</td>
<td>否</td>
<td>重写Runnable接口的方法，线程获取到cpu时间片时执行的具体逻辑</td>
</tr>
<tr>
<td>yield()</td>
<td>是</td>
<td>线程的礼让，使得获取到cpu时间片的线程进入就绪状态，重新争抢时间片</td>
</tr>
<tr>
<td>sleep(time)</td>
<td>是</td>
<td>线程休眠固定时间，进入阻塞状态，休眠时间完成后重新争抢时间片，休眠可被打断</td>
</tr>
<tr>
<td>join()/join(time)</td>
<td>否</td>
<td>调用线程对象的join()方法，调用者线程进入阻塞，等待线程对象执行完或者到达指定时间才恢复，重新争抢时间片</td>
</tr>
<tr>
<td>isInterrupted()</td>
<td>否</td>
<td>获取线程的打断标记，true: 被打断，false: 没有被打断。调用后不会修改打断标记</td>
</tr>
<tr>
<td>interrupt()</td>
<td>否</td>
<td>打断线程，抛出 InterruptedException 异常的方法均可被打断，但是打断后不会修改打断标记，正常执行的线程被打断后会修改打断标记</td>
</tr>
<tr>
<td>interrupted()</td>
<td>否</td>
<td>获取线程的打断标记，调用后会清空打断标记</td>
</tr>
<tr>
<td>stop()</td>
<td>否</td>
<td>停止线程运行 不推荐</td>
</tr>
<tr>
<td>suspend()</td>
<td>否</td>
<td>挂起线程 不推荐</td>
</tr>
<tr>
<td>resume()</td>
<td>否</td>
<td>恢复线程运行 不推荐</td>
</tr>
<tr>
<td>currentThread()</td>
<td>是</td>
<td>获取当前线程</td>
</tr>
</tbody>
</table>
<p>Object 中与线程相关的方法</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>方法说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>wait()/wait(long timeout)</td>
<td>获取到锁的线程进入阻塞状态</td>
</tr>
<tr>
<td>notify()</td>
<td>随机唤醒被 wait() 的一个线程</td>
</tr>
<tr>
<td>notifyAll()</td>
<td>唤醒被 wait() 的所有线程，重新争抢时间片</td>
</tr>
</tbody>
</table>
<h2 id="同步锁">同步锁</h2>
<h3 id="线程安全">线程安全</h3>
<p>一个程序运行多个线程本身是没有问题的，但是如果多个线程访问共享资源时，若多个线程都是<strong>读</strong>共享资源，没有问题；若多个线程<strong>读写</strong>共享资源时，如果发生<strong>指令交错</strong>，就会出现问题</p>
<p><strong>临界区</strong>：一段代码如果是对共享资源的多线程读写操作，这段代码就被称为临界区</p>
<p>注意：<strong>指令交错</strong>是指java代码在解析成字节码文件时，java代码的一行代码在字节码中可能有多行，在线程上下文切换时就有可能交错。</p>
<p><strong>线程安全</strong>是指多线程调用同一个对象的临界区的方法时，对象的属性值一定不会发生错误，这就是保证了线程安全。</p>
<p>线程不安全示例</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">//对象的成员变量
</span><span class="c1"></span><span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
    <span class="c1">//t1线程对count加1执行5000次
</span><span class="c1"></span>    <span class="n">Thread</span> <span class="n">t1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">5000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">count</span><span class="o">++;</span>
        <span class="o">}</span>
    <span class="o">});</span>
    <span class="c1">//t2线程对count减1执行5000次
</span><span class="c1"></span>    <span class="n">Thread</span> <span class="n">t2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">5000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">count</span><span class="o">--;</span>
        <span class="o">}</span>
    <span class="o">});</span>

    <span class="n">t1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
    <span class="n">t2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>

    <span class="c1">//主线程等待t1和t2执行完
</span><span class="c1"></span>    <span class="n">t1</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
    <span class="n">t2</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
    <span class="c1">//输出最后的结果
</span><span class="c1"></span>    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">&#34;count = %d&#34;</span><span class="o">,</span> <span class="n">count</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上述代码中，t1 线程对变量 count 执行 5000 次加 1 操作，t2 线程对变量 count 执行 5000 次减 1 操作，如果是线程安全，那么 count 的输出结果应该为 0 。但是实际运行后，count 的结果每次都不同，且都不是 0 ，所以上述示例不是线程安全的。</p>
<p><strong>线程安全的类一定所有的操作都是线程安全吗？</strong></p>
<p>开发中经常会说到一些线程安全的类，比如 ConcurrentHashMap ，线程安全指的是类里每一个独立的方法是线程安全的，但是<strong>方法的组合就不一定是线程安全的</strong>。</p>
<p>成员变量和静态变量是否线程安全？</p>
<ul>
<li>如果没有多线程共享，则是线程安全的</li>
<li>如果存在多线程共享
<ul>
<li>多线程只有读操作，则线程安全</li>
<li>多线程存在写操作，写操作的代码又是临界区，则线程不安全</li>
</ul>
</li>
</ul>
<p>局部变量是否线程安全？</p>
<ul>
<li>局部变量是线程安全的</li>
<li>局部变量引用的对象未必是线程安全的
<ul>
<li>如果该对象没有逃离该方法的作用范围，则线程安全</li>
<li>如果该对象逃离了该方法的作用范围，比如方法的返回值，则需要考虑线程安全</li>
</ul>
</li>
</ul>
<h3 id="synchronized">synchronized</h3>
<p>同步锁，也叫对象锁，是锁在对象上的，不同的对象就是不同的锁</p>
<p>该关键字用于保证线程安全，是<strong>阻塞式</strong>的解决方案</p>
<p>让同一时刻最多只有一个线程能持有对象锁，其他线程再想获取这个对象锁就会被阻塞，不用担心上下文切换的问题。</p>
<p>注意：不要理解为若代码块加了 synchronized 锁，获取锁的线程进入 synchronized 代码块后会一直执行下去。如果该线程在 synchronized 代码块中发生了时间片切换，该线程会进入就绪状态，等待再次获得时间片后继续执行 synchronized 代码块，在这个过程中，当前线程还持有着锁。</p>
<p>当一个线程执行完 synchronized 代码块后，会唤醒正在等待的其他线程。</p>
<p>synchronized 实际上适用对象锁保证临界区的<strong>原子性</strong>，保证临界区的代码是不可分割的，不会因为线程切换而打断。</p>
<p>synchronized 的使用示例</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">//加在方法上，实际是对this对象加锁
</span><span class="c1"></span><span class="kd">private</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">a</span><span class="o">(){</span>

<span class="o">}</span>

<span class="c1">//同步代码块，锁对象可以是任意的，加在this上和 a() 方法的作用相同
</span><span class="c1"></span><span class="kd">private</span> <span class="kt">void</span> <span class="nf">b</span><span class="o">(){</span>
    <span class="kd">synchronized</span><span class="o">(</span><span class="k">this</span><span class="o">){</span>

    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">//加在静态方法上，实际是对类对象加锁
</span><span class="c1"></span><span class="kd">private</span> <span class="kd">synchronized</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">c</span><span class="o">(){</span>

<span class="o">}</span>

<span class="c1">//同步代码块，实际是对类对象加锁，和 c() 方法的作用相同
</span><span class="c1"></span><span class="kd">private</span> <span class="kt">void</span> <span class="nf">d</span><span class="o">(){</span>
    <span class="kd">synchronized</span> <span class="o">(</span><span class="n">TestSynchronized</span><span class="o">.</span><span class="na">class</span><span class="o">){</span>

    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>线程安全代码示例</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">//对象的成员变量
</span><span class="c1"></span><span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="n">Object</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Object</span><span class="o">();</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
    <span class="c1">//t1线程对count加1执行5000次
</span><span class="c1"></span>    <span class="n">Thread</span> <span class="n">t1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">5000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kd">synchronized</span> <span class="o">(</span><span class="n">lock</span><span class="o">){</span>
                <span class="n">count</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">});</span>
    <span class="c1">//t2线程对count减1执行5000次
</span><span class="c1"></span>    <span class="n">Thread</span> <span class="n">t2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">5000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kd">synchronized</span> <span class="o">(</span><span class="n">lock</span><span class="o">){</span>
                <span class="n">count</span><span class="o">--;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">});</span>

    <span class="n">t1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
    <span class="n">t2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>

    <span class="c1">//主线程等待t1和t2执行完
</span><span class="c1"></span>    <span class="n">t1</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
    <span class="n">t2</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
    <span class="c1">//输出最后的结果
</span><span class="c1"></span>    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">&#34;count = %d&#34;</span><span class="o">,</span> <span class="n">count</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>重点：加锁是加在对象上，一定要保证加在同一个对象上，加锁才能生效。</p>
<h3 id="lock">Lock</h3>
<p><a href="https://www.cnblogs.com/fsmly/p/10703804.html">https://www.cnblogs.com/fsmly/p/10703804.html</a></p>
<p><a href="https://blog.csdn.net/u013568373/article/details/98480603">https://blog.csdn.net/u013568373/article/details/98480603</a></p>
<p>synchronized锁： java 提供的内置锁机制，java中的每个对象都可以作为一个实现同步的锁（内置锁或监视器Monitor），线程在进入同步代码块之前需要获取这把锁，在退出同步代码块后会释放锁。 synchronized 这种内置锁是<strong>互斥</strong>的，即每把锁最多只能由一个线程持有。</p>
<p>lock锁：Lock 接口提供了与 synchronized 相似的同步功能，和 synchronized（隐式的获取和释放锁，主要体现在线程进入同步代码块之前需要获取锁，退出同步代码块时需要释放锁）不同的是，Lock 在使用的时候是显式的获取和释放锁。虽然 Lock 接口缺少了 synchronized 隐式获取和释放锁的便捷性，但是对于锁的操作具有更强的可操作性、可控制性以及提供可中断操作和超时获取锁等机制。</p>
<p>Lock 接口定义如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span><span class="lnt">203
</span><span class="lnt">204
</span><span class="lnt">205
</span><span class="lnt">206
</span><span class="lnt">207
</span><span class="lnt">208
</span><span class="lnt">209
</span><span class="lnt">210
</span><span class="lnt">211
</span><span class="lnt">212
</span><span class="lnt">213
</span><span class="lnt">214
</span><span class="lnt">215
</span><span class="lnt">216
</span><span class="lnt">217
</span><span class="lnt">218
</span><span class="lnt">219
</span><span class="lnt">220
</span><span class="lnt">221
</span><span class="lnt">222
</span><span class="lnt">223
</span><span class="lnt">224
</span><span class="lnt">225
</span><span class="lnt">226
</span><span class="lnt">227
</span><span class="lnt">228
</span><span class="lnt">229
</span><span class="lnt">230
</span><span class="lnt">231
</span><span class="lnt">232
</span><span class="lnt">233
</span><span class="lnt">234
</span><span class="lnt">235
</span><span class="lnt">236
</span><span class="lnt">237
</span><span class="lnt">238
</span><span class="lnt">239
</span><span class="lnt">240
</span><span class="lnt">241
</span><span class="lnt">242
</span><span class="lnt">243
</span><span class="lnt">244
</span><span class="lnt">245
</span><span class="lnt">246
</span><span class="lnt">247
</span><span class="lnt">248
</span><span class="lnt">249
</span><span class="lnt">250
</span><span class="lnt">251
</span><span class="lnt">252
</span><span class="lnt">253
</span><span class="lnt">254
</span><span class="lnt">255
</span><span class="lnt">256
</span><span class="lnt">257
</span><span class="lnt">258
</span><span class="lnt">259
</span><span class="lnt">260
</span><span class="lnt">261
</span><span class="lnt">262
</span><span class="lnt">263
</span><span class="lnt">264
</span><span class="lnt">265
</span><span class="lnt">266
</span><span class="lnt">267
</span><span class="lnt">268
</span><span class="lnt">269
</span><span class="lnt">270
</span><span class="lnt">271
</span><span class="lnt">272
</span><span class="lnt">273
</span><span class="lnt">274
</span><span class="lnt">275
</span><span class="lnt">276
</span><span class="lnt">277
</span><span class="lnt">278
</span><span class="lnt">279
</span><span class="lnt">280
</span><span class="lnt">281
</span><span class="lnt">282
</span><span class="lnt">283
</span><span class="lnt">284
</span><span class="lnt">285
</span><span class="lnt">286
</span><span class="lnt">287
</span><span class="lnt">288
</span><span class="lnt">289
</span><span class="lnt">290
</span><span class="lnt">291
</span><span class="lnt">292
</span><span class="lnt">293
</span><span class="lnt">294
</span><span class="lnt">295
</span><span class="lnt">296
</span><span class="lnt">297
</span><span class="lnt">298
</span><span class="lnt">299
</span><span class="lnt">300
</span><span class="lnt">301
</span><span class="lnt">302
</span><span class="lnt">303
</span><span class="lnt">304
</span><span class="lnt">305
</span><span class="lnt">306
</span><span class="lnt">307
</span><span class="lnt">308
</span><span class="lnt">309
</span><span class="lnt">310
</span><span class="lnt">311
</span><span class="lnt">312
</span><span class="lnt">313
</span><span class="lnt">314
</span><span class="lnt">315
</span><span class="lnt">316
</span><span class="lnt">317
</span><span class="lnt">318
</span><span class="lnt">319
</span><span class="lnt">320
</span><span class="lnt">321
</span><span class="lnt">322
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">java.util.concurrent.locks</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.TimeUnit</span><span class="o">;</span>

<span class="cm">/**
</span><span class="cm"> * {@code Lock} implementations provide more extensive locking
</span><span class="cm"> * operations than can be obtained using {@code synchronized} methods
</span><span class="cm"> * and statements.  They allow more flexible structuring, may have
</span><span class="cm"> * quite different properties, and may support multiple associated
</span><span class="cm"> * {@link Condition} objects.
</span><span class="cm"> *
</span><span class="cm"> * &lt;p&gt;A lock is a tool for controlling access to a shared resource by
</span><span class="cm"> * multiple threads. Commonly, a lock provides exclusive access to a
</span><span class="cm"> * shared resource: only one thread at a time can acquire the lock and
</span><span class="cm"> * all access to the shared resource requires that the lock be
</span><span class="cm"> * acquired first. However, some locks may allow concurrent access to
</span><span class="cm"> * a shared resource, such as the read lock of a {@link ReadWriteLock}.
</span><span class="cm"> *
</span><span class="cm"> * &lt;p&gt;The use of {@code synchronized} methods or statements provides
</span><span class="cm"> * access to the implicit monitor lock associated with every object, but
</span><span class="cm"> * forces all lock acquisition and release to occur in a block-structured way:
</span><span class="cm"> * when multiple locks are acquired they must be released in the opposite
</span><span class="cm"> * order, and all locks must be released in the same lexical scope in which
</span><span class="cm"> * they were acquired.
</span><span class="cm"> *
</span><span class="cm"> * &lt;p&gt;While the scoping mechanism for {@code synchronized} methods
</span><span class="cm"> * and statements makes it much easier to program with monitor locks,
</span><span class="cm"> * and helps avoid many common programming errors involving locks,
</span><span class="cm"> * there are occasions where you need to work with locks in a more
</span><span class="cm"> * flexible way. For example, some algorithms for traversing
</span><span class="cm"> * concurrently accessed data structures require the use of
</span><span class="cm"> * &amp;quot;hand-over-hand&amp;quot; or &amp;quot;chain locking&amp;quot;: you
</span><span class="cm"> * acquire the lock of node A, then node B, then release A and acquire
</span><span class="cm"> * C, then release B and acquire D and so on.  Implementations of the
</span><span class="cm"> * {@code Lock} interface enable the use of such techniques by
</span><span class="cm"> * allowing a lock to be acquired and released in different scopes,
</span><span class="cm"> * and allowing multiple locks to be acquired and released in any
</span><span class="cm"> * order.
</span><span class="cm"> *
</span><span class="cm"> * &lt;p&gt;With this increased flexibility comes additional
</span><span class="cm"> * responsibility. The absence of block-structured locking removes the
</span><span class="cm"> * automatic release of locks that occurs with {@code synchronized}
</span><span class="cm"> * methods and statements. In most cases, the following idiom
</span><span class="cm"> * should be used:
</span><span class="cm"> *
</span><span class="cm"> *  &lt;pre&gt; {@code
</span><span class="cm"> * Lock l = ...;
</span><span class="cm"> * l.lock();
</span><span class="cm"> * try {
</span><span class="cm"> *   // access the resource protected by this lock
</span><span class="cm"> * } finally {
</span><span class="cm"> *   l.unlock();
</span><span class="cm"> * }}&lt;/pre&gt;
</span><span class="cm"> *
</span><span class="cm"> * When locking and unlocking occur in different scopes, care must be
</span><span class="cm"> * taken to ensure that all code that is executed while the lock is
</span><span class="cm"> * held is protected by try-finally or try-catch to ensure that the
</span><span class="cm"> * lock is released when necessary.
</span><span class="cm"> *
</span><span class="cm"> * &lt;p&gt;{@code Lock} implementations provide additional functionality
</span><span class="cm"> * over the use of {@code synchronized} methods and statements by
</span><span class="cm"> * providing a non-blocking attempt to acquire a lock ({@link
</span><span class="cm"> * #tryLock()}), an attempt to acquire the lock that can be
</span><span class="cm"> * interrupted ({@link #lockInterruptibly}, and an attempt to acquire
</span><span class="cm"> * the lock that can timeout ({@link #tryLock(long, TimeUnit)}).
</span><span class="cm"> *
</span><span class="cm"> * &lt;p&gt;A {@code Lock} class can also provide behavior and semantics
</span><span class="cm"> * that is quite different from that of the implicit monitor lock,
</span><span class="cm"> * such as guaranteed ordering, non-reentrant usage, or deadlock
</span><span class="cm"> * detection. If an implementation provides such specialized semantics
</span><span class="cm"> * then the implementation must document those semantics.
</span><span class="cm"> *
</span><span class="cm"> * &lt;p&gt;Note that {@code Lock} instances are just normal objects and can
</span><span class="cm"> * themselves be used as the target in a {@code synchronized} statement.
</span><span class="cm"> * Acquiring the
</span><span class="cm"> * monitor lock of a {@code Lock} instance has no specified relationship
</span><span class="cm"> * with invoking any of the {@link #lock} methods of that instance.
</span><span class="cm"> * It is recommended that to avoid confusion you never use {@code Lock}
</span><span class="cm"> * instances in this way, except within their own implementation.
</span><span class="cm"> *
</span><span class="cm"> * &lt;p&gt;Except where noted, passing a {@code null} value for any
</span><span class="cm"> * parameter will result in a {@link NullPointerException} being
</span><span class="cm"> * thrown.
</span><span class="cm"> *
</span><span class="cm"> * &lt;h3&gt;Memory Synchronization&lt;/h3&gt;
</span><span class="cm"> *
</span><span class="cm"> * &lt;p&gt;All {@code Lock} implementations &lt;em&gt;must&lt;/em&gt; enforce the same
</span><span class="cm"> * memory synchronization semantics as provided by the built-in monitor
</span><span class="cm"> * lock, as described in
</span><span class="cm"> * &lt;a href=&#34;https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4&#34;&gt;
</span><span class="cm"> * The Java Language Specification (17.4 Memory Model)&lt;/a&gt;:
</span><span class="cm"> * &lt;ul&gt;
</span><span class="cm"> * &lt;li&gt;A successful {@code lock} operation has the same memory
</span><span class="cm"> * synchronization effects as a successful &lt;em&gt;Lock&lt;/em&gt; action.
</span><span class="cm"> * &lt;li&gt;A successful {@code unlock} operation has the same
</span><span class="cm"> * memory synchronization effects as a successful &lt;em&gt;Unlock&lt;/em&gt; action.
</span><span class="cm"> * &lt;/ul&gt;
</span><span class="cm"> *
</span><span class="cm"> * Unsuccessful locking and unlocking operations, and reentrant
</span><span class="cm"> * locking/unlocking operations, do not require any memory
</span><span class="cm"> * synchronization effects.
</span><span class="cm"> *
</span><span class="cm"> * &lt;h3&gt;Implementation Considerations&lt;/h3&gt;
</span><span class="cm"> *
</span><span class="cm"> * &lt;p&gt;The three forms of lock acquisition (interruptible,
</span><span class="cm"> * non-interruptible, and timed) may differ in their performance
</span><span class="cm"> * characteristics, ordering guarantees, or other implementation
</span><span class="cm"> * qualities.  Further, the ability to interrupt the &lt;em&gt;ongoing&lt;/em&gt;
</span><span class="cm"> * acquisition of a lock may not be available in a given {@code Lock}
</span><span class="cm"> * class.  Consequently, an implementation is not required to define
</span><span class="cm"> * exactly the same guarantees or semantics for all three forms of
</span><span class="cm"> * lock acquisition, nor is it required to support interruption of an
</span><span class="cm"> * ongoing lock acquisition.  An implementation is required to clearly
</span><span class="cm"> * document the semantics and guarantees provided by each of the
</span><span class="cm"> * locking methods. It must also obey the interruption semantics as
</span><span class="cm"> * defined in this interface, to the extent that interruption of lock
</span><span class="cm"> * acquisition is supported: which is either totally, or only on
</span><span class="cm"> * method entry.
</span><span class="cm"> *
</span><span class="cm"> * &lt;p&gt;As interruption generally implies cancellation, and checks for
</span><span class="cm"> * interruption are often infrequent, an implementation can favor responding
</span><span class="cm"> * to an interrupt over normal method return. This is true even if it can be
</span><span class="cm"> * shown that the interrupt occurred after another action may have unblocked
</span><span class="cm"> * the thread. An implementation should document this behavior.
</span><span class="cm"> *
</span><span class="cm"> * @see ReentrantLock
</span><span class="cm"> * @see Condition
</span><span class="cm"> * @see ReadWriteLock
</span><span class="cm"> *
</span><span class="cm"> * @since 1.5
</span><span class="cm"> * @author Doug Lea
</span><span class="cm"> */</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Lock</span> <span class="o">{</span>

    <span class="cm">/**
</span><span class="cm">     * Acquires the lock.
</span><span class="cm">     *
</span><span class="cm">     * &lt;p&gt;If the lock is not available then the current thread becomes
</span><span class="cm">     * disabled for thread scheduling purposes and lies dormant until the
</span><span class="cm">     * lock has been acquired.
</span><span class="cm">     *
</span><span class="cm">     * &lt;p&gt;&lt;b&gt;Implementation Considerations&lt;/b&gt;
</span><span class="cm">     *
</span><span class="cm">     * &lt;p&gt;A {@code Lock} implementation may be able to detect erroneous use
</span><span class="cm">     * of the lock, such as an invocation that would cause deadlock, and
</span><span class="cm">     * may throw an (unchecked) exception in such circumstances.  The
</span><span class="cm">     * circumstances and the exception type must be documented by that
</span><span class="cm">     * {@code Lock} implementation.
</span><span class="cm">     */</span>
    <span class="kt">void</span> <span class="nf">lock</span><span class="o">();</span>

    <span class="cm">/**
</span><span class="cm">     * Acquires the lock unless the current thread is
</span><span class="cm">     * {@linkplain Thread#interrupt interrupted}.
</span><span class="cm">     *
</span><span class="cm">     * &lt;p&gt;Acquires the lock if it is available and returns immediately.
</span><span class="cm">     *
</span><span class="cm">     * &lt;p&gt;If the lock is not available then the current thread becomes
</span><span class="cm">     * disabled for thread scheduling purposes and lies dormant until
</span><span class="cm">     * one of two things happens:
</span><span class="cm">     *
</span><span class="cm">     * &lt;ul&gt;
</span><span class="cm">     * &lt;li&gt;The lock is acquired by the current thread; or
</span><span class="cm">     * &lt;li&gt;Some other thread {@linkplain Thread#interrupt interrupts} the
</span><span class="cm">     * current thread, and interruption of lock acquisition is supported.
</span><span class="cm">     * &lt;/ul&gt;
</span><span class="cm">     *
</span><span class="cm">     * &lt;p&gt;If the current thread:
</span><span class="cm">     * &lt;ul&gt;
</span><span class="cm">     * &lt;li&gt;has its interrupted status set on entry to this method; or
</span><span class="cm">     * &lt;li&gt;is {@linkplain Thread#interrupt interrupted} while acquiring the
</span><span class="cm">     * lock, and interruption of lock acquisition is supported,
</span><span class="cm">     * &lt;/ul&gt;
</span><span class="cm">     * then {@link InterruptedException} is thrown and the current thread&#39;s
</span><span class="cm">     * interrupted status is cleared.
</span><span class="cm">     *
</span><span class="cm">     * &lt;p&gt;&lt;b&gt;Implementation Considerations&lt;/b&gt;
</span><span class="cm">     *
</span><span class="cm">     * &lt;p&gt;The ability to interrupt a lock acquisition in some
</span><span class="cm">     * implementations may not be possible, and if possible may be an
</span><span class="cm">     * expensive operation.  The programmer should be aware that this
</span><span class="cm">     * may be the case. An implementation should document when this is
</span><span class="cm">     * the case.
</span><span class="cm">     *
</span><span class="cm">     * &lt;p&gt;An implementation can favor responding to an interrupt over
</span><span class="cm">     * normal method return.
</span><span class="cm">     *
</span><span class="cm">     * &lt;p&gt;A {@code Lock} implementation may be able to detect
</span><span class="cm">     * erroneous use of the lock, such as an invocation that would
</span><span class="cm">     * cause deadlock, and may throw an (unchecked) exception in such
</span><span class="cm">     * circumstances.  The circumstances and the exception type must
</span><span class="cm">     * be documented by that {@code Lock} implementation.
</span><span class="cm">     *
</span><span class="cm">     * @throws InterruptedException if the current thread is
</span><span class="cm">     *         interrupted while acquiring the lock (and interruption
</span><span class="cm">     *         of lock acquisition is supported)
</span><span class="cm">     */</span>
    <span class="kt">void</span> <span class="nf">lockInterruptibly</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">InterruptedException</span><span class="o">;</span>

    <span class="cm">/**
</span><span class="cm">     * Acquires the lock only if it is free at the time of invocation.
</span><span class="cm">     *
</span><span class="cm">     * &lt;p&gt;Acquires the lock if it is available and returns immediately
</span><span class="cm">     * with the value {@code true}.
</span><span class="cm">     * If the lock is not available then this method will return
</span><span class="cm">     * immediately with the value {@code false}.
</span><span class="cm">     *
</span><span class="cm">     * &lt;p&gt;A typical usage idiom for this method would be:
</span><span class="cm">     *  &lt;pre&gt; {@code
</span><span class="cm">     * Lock lock = ...;
</span><span class="cm">     * if (lock.tryLock()) {
</span><span class="cm">     *   try {
</span><span class="cm">     *     // manipulate protected state
</span><span class="cm">     *   } finally {
</span><span class="cm">     *     lock.unlock();
</span><span class="cm">     *   }
</span><span class="cm">     * } else {
</span><span class="cm">     *   // perform alternative actions
</span><span class="cm">     * }}&lt;/pre&gt;
</span><span class="cm">     *
</span><span class="cm">     * This usage ensures that the lock is unlocked if it was acquired, and
</span><span class="cm">     * doesn&#39;t try to unlock if the lock was not acquired.
</span><span class="cm">     *
</span><span class="cm">     * @return {@code true} if the lock was acquired and
</span><span class="cm">     *         {@code false} otherwise
</span><span class="cm">     */</span>
    <span class="kt">boolean</span> <span class="nf">tryLock</span><span class="o">();</span>

    <span class="cm">/**
</span><span class="cm">     * Acquires the lock if it is free within the given waiting time and the
</span><span class="cm">     * current thread has not been {@linkplain Thread#interrupt interrupted}.
</span><span class="cm">     *
</span><span class="cm">     * &lt;p&gt;If the lock is available this method returns immediately
</span><span class="cm">     * with the value {@code true}.
</span><span class="cm">     * If the lock is not available then
</span><span class="cm">     * the current thread becomes disabled for thread scheduling
</span><span class="cm">     * purposes and lies dormant until one of three things happens:
</span><span class="cm">     * &lt;ul&gt;
</span><span class="cm">     * &lt;li&gt;The lock is acquired by the current thread; or
</span><span class="cm">     * &lt;li&gt;Some other thread {@linkplain Thread#interrupt interrupts} the
</span><span class="cm">     * current thread, and interruption of lock acquisition is supported; or
</span><span class="cm">     * &lt;li&gt;The specified waiting time elapses
</span><span class="cm">     * &lt;/ul&gt;
</span><span class="cm">     *
</span><span class="cm">     * &lt;p&gt;If the lock is acquired then the value {@code true} is returned.
</span><span class="cm">     *
</span><span class="cm">     * &lt;p&gt;If the current thread:
</span><span class="cm">     * &lt;ul&gt;
</span><span class="cm">     * &lt;li&gt;has its interrupted status set on entry to this method; or
</span><span class="cm">     * &lt;li&gt;is {@linkplain Thread#interrupt interrupted} while acquiring
</span><span class="cm">     * the lock, and interruption of lock acquisition is supported,
</span><span class="cm">     * &lt;/ul&gt;
</span><span class="cm">     * then {@link InterruptedException} is thrown and the current thread&#39;s
</span><span class="cm">     * interrupted status is cleared.
</span><span class="cm">     *
</span><span class="cm">     * &lt;p&gt;If the specified waiting time elapses then the value {@code false}
</span><span class="cm">     * is returned.
</span><span class="cm">     * If the time is
</span><span class="cm">     * less than or equal to zero, the method will not wait at all.
</span><span class="cm">     *
</span><span class="cm">     * &lt;p&gt;&lt;b&gt;Implementation Considerations&lt;/b&gt;
</span><span class="cm">     *
</span><span class="cm">     * &lt;p&gt;The ability to interrupt a lock acquisition in some implementations
</span><span class="cm">     * may not be possible, and if possible may
</span><span class="cm">     * be an expensive operation.
</span><span class="cm">     * The programmer should be aware that this may be the case. An
</span><span class="cm">     * implementation should document when this is the case.
</span><span class="cm">     *
</span><span class="cm">     * &lt;p&gt;An implementation can favor responding to an interrupt over normal
</span><span class="cm">     * method return, or reporting a timeout.
</span><span class="cm">     *
</span><span class="cm">     * &lt;p&gt;A {@code Lock} implementation may be able to detect
</span><span class="cm">     * erroneous use of the lock, such as an invocation that would cause
</span><span class="cm">     * deadlock, and may throw an (unchecked) exception in such circumstances.
</span><span class="cm">     * The circumstances and the exception type must be documented by that
</span><span class="cm">     * {@code Lock} implementation.
</span><span class="cm">     *
</span><span class="cm">     * @param time the maximum time to wait for the lock
</span><span class="cm">     * @param unit the time unit of the {@code time} argument
</span><span class="cm">     * @return {@code true} if the lock was acquired and {@code false}
</span><span class="cm">     *         if the waiting time elapsed before the lock was acquired
</span><span class="cm">     *
</span><span class="cm">     * @throws InterruptedException if the current thread is interrupted
</span><span class="cm">     *         while acquiring the lock (and interruption of lock
</span><span class="cm">     *         acquisition is supported)
</span><span class="cm">     */</span>
    <span class="kt">boolean</span> <span class="nf">tryLock</span><span class="o">(</span><span class="kt">long</span> <span class="n">time</span><span class="o">,</span> <span class="n">TimeUnit</span> <span class="n">unit</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span><span class="o">;</span>

    <span class="cm">/**
</span><span class="cm">     * Releases the lock.
</span><span class="cm">     *
</span><span class="cm">     * &lt;p&gt;&lt;b&gt;Implementation Considerations&lt;/b&gt;
</span><span class="cm">     *
</span><span class="cm">     * &lt;p&gt;A {@code Lock} implementation will usually impose
</span><span class="cm">     * restrictions on which thread can release a lock (typically only the
</span><span class="cm">     * holder of the lock can release it) and may throw
</span><span class="cm">     * an (unchecked) exception if the restriction is violated.
</span><span class="cm">     * Any restrictions and the exception
</span><span class="cm">     * type must be documented by that {@code Lock} implementation.
</span><span class="cm">     */</span>
    <span class="kt">void</span> <span class="nf">unlock</span><span class="o">();</span>

    <span class="cm">/**
</span><span class="cm">     * Returns a new {@link Condition} instance that is bound to this
</span><span class="cm">     * {@code Lock} instance.
</span><span class="cm">     *
</span><span class="cm">     * &lt;p&gt;Before waiting on the condition the lock must be held by the
</span><span class="cm">     * current thread.
</span><span class="cm">     * A call to {@link Condition#await()} will atomically release the lock
</span><span class="cm">     * before waiting and re-acquire the lock before the wait returns.
</span><span class="cm">     *
</span><span class="cm">     * &lt;p&gt;&lt;b&gt;Implementation Considerations&lt;/b&gt;
</span><span class="cm">     *
</span><span class="cm">     * &lt;p&gt;The exact operation of the {@link Condition} instance depends on
</span><span class="cm">     * the {@code Lock} implementation and must be documented by that
</span><span class="cm">     * implementation.
</span><span class="cm">     *
</span><span class="cm">     * @return A new {@link Condition} instance for this {@code Lock} instance
</span><span class="cm">     * @throws UnsupportedOperationException if this {@code Lock}
</span><span class="cm">     *         implementation does not support conditions
</span><span class="cm">     */</span>
    <span class="n">Condition</span> <span class="nf">newCondition</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Lock 接口使用示例</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Lock</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ReentrantLock</span><span class="o">();</span> <span class="c1">//可以使用自己实现的Lock接口实现类，也可以使用 jdk 提供的同步组件
</span><span class="c1"></span><span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span> <span class="c1">//不要将锁的获取放在 try 语句块中，因为如果放在try中，若获取锁时发生异常，会执行finally中的释放锁操作，此时没有锁，就会抛出异常
</span><span class="c1"></span>
<span class="k">try</span><span class="o">{</span>

<span class="o">}</span><span class="k">finally</span> <span class="o">{</span>
    <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Lock 接口方法</p>
<ul>
<li><code>lock()</code> : 获取锁</li>
<li><code>lockInterruptibly() throws InterruptedException</code>: 若该线程未被中断，则获取锁。Acquires the lock unless the current thread is interrupted.</li>
<li><code>tryLock()</code>：Acquires the lock only if it is free at the time of invocation.</li>
<li><code>tryLock(long time, TimeUnit unit) throws InterruptedException</code> : 超时地获取锁</li>
<li><code>unlock()</code>：释放锁</li>
<li><code>newCondition()</code>: Returns a new Condition instance that is bound to this Lock instance.</li>
</ul>
<p>Lock接口与synchronized对比，优点如下</p>
<ul>
<li>可以尝试非阻塞地获取锁 tryLock(): 当前线程尝试获取锁，如果该时刻锁没有被其他线程获取到，就能成功获取并持有锁</li>
<li>能被中断地获取锁 lockInterruptibly()：获取到锁的线程能够响应中断，当获取到锁的线程被中断的时候，会抛出中断异常同时释放持有的锁</li>
<li>超时地获取锁 tryLock(long time, TimeUnit unit): 在指定时间获取锁，如果没有获取到则返回false</li>
</ul>
<h4 id="condition">Condition</h4>
<blockquote>
<p>参考：https://www.cnblogs.com/gemine/p/9039012.html</p>
</blockquote>
<p>在使用 Lock 之前，我们使用的最多的同步方式应该是 synchronized 关键字来实现同步，配合 Object 的 wait() 、 notify() 系列方法可以实现等待/通知模式。</p>
<p>Condition 接口也提供了类似 Object 的监视器方法，与 Lock 配合可以实现等待/通知模式，但是这两者在使用方式以及功能特性上还是有差别的。</p>
<p>Object 和 Condition 接口的一些对比（摘自 Java并发编程的艺术）</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/images/20210223-Object%e4%b8%8eCondition%e5%af%b9%e6%af%94.png"
        data-srcset="/images/20210223-Object%e4%b8%8eCondition%e5%af%b9%e6%af%94.png, /images/20210223-Object%e4%b8%8eCondition%e5%af%b9%e6%af%94.png 1.5x, /images/20210223-Object%e4%b8%8eCondition%e5%af%b9%e6%af%94.png 2x"
        data-sizes="auto"
        alt="/images/20210223-Object与Condition对比.png"
        title="Object与Condition对比" /></p>
<h5 id="condition接口介绍">Condition接口介绍</h5>
<p>Condition 对象是依赖于 Lock 对象的，即 Condition 对象需要通过 Lock 对象创建出来（调用 Lock 对象的 newCondition() 方法）。</p>
<p>Condition 对象的使用非常简单，但是需要注意在调用方法前获取锁</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="n">Lock</span> <span class="n">lock2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ReentrantLock</span><span class="o">();</span>
<span class="kd">public</span> <span class="n">Condition</span> <span class="n">condition</span> <span class="o">=</span> <span class="n">lock2</span><span class="o">.</span><span class="na">newCondition</span><span class="o">();</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">MultiThreadTest</span> <span class="n">multiThreadTest</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MultiThreadTest</span><span class="o">();</span>
    <span class="n">ExecutorService</span> <span class="n">executorService</span> <span class="o">=</span> <span class="n">Executors</span><span class="o">.</span><span class="na">newFixedThreadPool</span><span class="o">(</span><span class="n">2</span><span class="o">);</span>
    <span class="n">executorService</span><span class="o">.</span><span class="na">execute</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="n">multiThreadTest</span><span class="o">.</span><span class="na">conditionWait</span><span class="o">();</span>
    <span class="o">});</span>
    <span class="n">executorService</span><span class="o">.</span><span class="na">execute</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="n">multiThreadTest</span><span class="o">.</span><span class="na">conditionSignal</span><span class="o">();</span>
    <span class="o">});</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">void</span> <span class="nf">conditionWait</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">lock2</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">&#34;拿到了锁&#34;</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">&#34;等待信号&#34;</span><span class="o">);</span>
        <span class="n">condition</span><span class="o">.</span><span class="na">await</span><span class="o">();</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">&#34;拿到了信号&#34;</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="n">lock2</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">void</span> <span class="nf">conditionSignal</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">lock2</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="n">5000</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">&#34;拿到了锁&#34;</span><span class="o">);</span>
        <span class="n">condition</span><span class="o">.</span><span class="na">signal</span><span class="o">();</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">&#34;发出了信号&#34;</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="n">lock2</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>运行结果</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">pool-1-thread-1拿到了锁
pool-1-thread-1等待信号
pool-1-thread-2拿到了锁
pool-1-thread-2发出了信号
pool-1-thread-1拿到了信号
</code></pre></td></tr></table>
</div>
</div><p>一般会将 Condition 对象作为成员变量，当调用 await() 方法后，当前线程会释放锁并在此等待，而其他线程调用 Condition 对象的 signal() 方法，通知当前线程后，当前线程才从 await() 方法返回，并且在返回前已经获取了锁。</p>
<h5 id="condition接口常用方法">Condition接口常用方法</h5>
<p>Condition 可以通俗地理解为条件队列，当一个线程在调用了 await() 方法后，直到线程等待的某个条件为真的时候才会被唤醒。这种方式为线程提供了更加简单的等待/通知模式。</p>
<p>Condition 必须配合锁一起使用，因为对共享状态变量的访问发生在多线程环境下，一个 Condition 的实例必须与一个 Lock 实例绑定，因此 Condition 一般都是作为 Lock 的内部实现。</p>
<ul>
<li><code>void await() throws InterruptedException</code>: 造成当前线程在接收到信号或者被中断之前一直处于等待状态</li>
<li><code>boolean await(long time, TimeUnit unit) throws InterruptedException</code>：造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态</li>
<li><code>long awaitNanos(long nanosTimeout) throws InterruptedException</code>：造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。返回值表示剩余时间，如果在nanosTimesout之前唤醒，那么返回值 = nanosTimeout - 消耗时间，如果返回值 &lt;= 0 ,则可以认定它已经超时了。</li>
<li><code>void awaitUninterruptibly()</code>: 造成当前线程在接到信号之前一直处于等待状态。【注意：该方法对中断不敏感】。</li>
<li><code>boolean awaitUntil(Date deadline) throws InterruptedException</code>: 造成当前线程在接到信号、被中断或到达指定最后期限之前一直处于等待状态。如果没有到指定时间就被通知，则返回true，否则表示到了指定时间，返回返回false。</li>
<li><code>void signal()</code>: 唤醒一个等待线程。该线程从等待方法返回前必须获得与Condition相关的锁。</li>
<li><code>void signalAll()</code>: 唤醒所有等待线程。能够从等待方法返回的线程必须获得与Condition相关的锁。</li>
</ul>
<h5 id="condition接口原理解析">Condition接口原理解析</h5>
<p>ConditionObject 实现了 Condition 接口， 是 AQS (java.util.concurrent.locks.AbstractQueuedSynchronizer) 的内部类。每个 Condition 对象都包含了一个队列（等待队列）。等待队列是一个FIFO的队列，在队列中的每个节点都包含了一个线程引用，该线程就是在Condition对象上等待的线程，如果一个线程调用了Condition.await()方法，那么该线程将会释放锁、构造成节点加入等待队列并进入等待状态。</p>
<p>等待队列的基本结构如下所示。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/images/20210223-Condition%e7%ad%89%e5%be%85%e9%98%9f%e5%88%97.png"
        data-srcset="/images/20210223-Condition%e7%ad%89%e5%be%85%e9%98%9f%e5%88%97.png, /images/20210223-Condition%e7%ad%89%e5%be%85%e9%98%9f%e5%88%97.png 1.5x, /images/20210223-Condition%e7%ad%89%e5%be%85%e9%98%9f%e5%88%97.png 2x"
        data-sizes="auto"
        alt="/images/20210223-Condition等待队列.png"
        title="Condition等待队列" /></p>
<p>等待分为首节点和尾节点。当一个线程调用Condition.await()方法，将会以当前线程构造节点，并将节点从尾部加入等待队列。新增节点就是将尾部节点指向新增的节点。节点引用更新本来就是在获取锁以后的操作，所以不需要CAS保证。同时也是线程安全的操作。</p>
<p><strong>等待</strong></p>
<p>当线程调用了await方法以后。线程就作为队列中的一个节点被加入到等待队列中去了。同时会释放锁的拥有。当从await方法返回的时候。一定会获取condition相关联的锁。当等待队列中的节点被唤醒的时候，则唤醒节点的线程开始尝试获取同步状态。如果不是通过 其他线程调用Condition.signal()方法唤醒，而是对等待线程进行中断，则会抛出InterruptedException异常信息。</p>
<p><strong>通知</strong></p>
<p>调用Condition的signal()方法，将会唤醒在等待队列中等待最长时间的节点（条件队列里的首节点），在唤醒节点前，会将节点移到同步队列中。当前线程加入到等待队列中如图所示：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/images/20210223-%e5%bd%93%e5%89%8d%e7%ba%bf%e7%a8%8b%e5%8a%a0%e5%85%a5%e7%ad%89%e5%be%85%e9%98%9f%e5%88%97.png"
        data-srcset="/images/20210223-%e5%bd%93%e5%89%8d%e7%ba%bf%e7%a8%8b%e5%8a%a0%e5%85%a5%e7%ad%89%e5%be%85%e9%98%9f%e5%88%97.png, /images/20210223-%e5%bd%93%e5%89%8d%e7%ba%bf%e7%a8%8b%e5%8a%a0%e5%85%a5%e7%ad%89%e5%be%85%e9%98%9f%e5%88%97.png 1.5x, /images/20210223-%e5%bd%93%e5%89%8d%e7%ba%bf%e7%a8%8b%e5%8a%a0%e5%85%a5%e7%ad%89%e5%be%85%e9%98%9f%e5%88%97.png 2x"
        data-sizes="auto"
        alt="/images/20210223-当前线程加入等待队列.png"
        title="当前线程加入等待队列" /></p>
<p>在调用signal()方法之前必须先判断是否获取到了锁。接着获取等待队列的首节点，将其移动到同步队列并且利用LockSupport唤醒节点中的线程。节点从等待队列移动到同步队列如下图所示</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/images/20210223-%e8%8a%82%e7%82%b9%e4%bb%8e%e7%ad%89%e5%be%85%e9%98%9f%e5%88%97%e7%a7%bb%e5%88%b0%e5%90%8c%e6%ad%a5%e9%98%9f%e5%88%97.png"
        data-srcset="/images/20210223-%e8%8a%82%e7%82%b9%e4%bb%8e%e7%ad%89%e5%be%85%e9%98%9f%e5%88%97%e7%a7%bb%e5%88%b0%e5%90%8c%e6%ad%a5%e9%98%9f%e5%88%97.png, /images/20210223-%e8%8a%82%e7%82%b9%e4%bb%8e%e7%ad%89%e5%be%85%e9%98%9f%e5%88%97%e7%a7%bb%e5%88%b0%e5%90%8c%e6%ad%a5%e9%98%9f%e5%88%97.png 1.5x, /images/20210223-%e8%8a%82%e7%82%b9%e4%bb%8e%e7%ad%89%e5%be%85%e9%98%9f%e5%88%97%e7%a7%bb%e5%88%b0%e5%90%8c%e6%ad%a5%e9%98%9f%e5%88%97.png 2x"
        data-sizes="auto"
        alt="/images/20210223-节点从等待队列移到同步队列.png"
        title="节点从等待队列移到同步队列" /></p>
<p>被唤醒的线程将从await方法中的while循环中退出。随后加入到同步状态的竞争当中去。成功获取到竞争的线程则会返回到await方法之前的状态。</p>
<p><strong>总结</strong></p>
<p>调用await方法后，将当前线程加入Condition等待队列中。当前线程释放锁。否则别的线程就无法拿到锁而发生死锁。自旋(while)挂起，不断检测节点是否在同步队列中了，如果是则尝试获取锁，否则挂起。当线程被signal方法唤醒，被唤醒的线程将从await()方法中的while循环中退出来，然后调用acquireQueued()方法竞争同步状态。</p>
<p><strong>利用Condition实现生产者消费者模式</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kn">import</span> <span class="nn">java.util.LinkedList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.locks.Condition</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.locks.Lock</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.locks.ReentrantLock</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BoundedQueue</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">buffer</span><span class="o">;</span>    <span class="c1">//生产者容器
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">maxSize</span> <span class="o">;</span>           <span class="c1">//容器最大值是多少
</span><span class="c1"></span>    <span class="kd">private</span> <span class="n">Lock</span> <span class="n">lock</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">Condition</span> <span class="n">fullCondition</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">Condition</span> <span class="n">notFullCondition</span><span class="o">;</span>
    <span class="n">BoundedQueue</span><span class="o">(</span><span class="kt">int</span> <span class="n">maxSize</span><span class="o">){</span>
        <span class="k">this</span><span class="o">.</span><span class="na">maxSize</span> <span class="o">=</span> <span class="n">maxSize</span><span class="o">;</span>
        <span class="n">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;();</span>
        <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ReentrantLock</span><span class="o">();</span>
        <span class="n">fullCondition</span> <span class="o">=</span> <span class="n">lock</span><span class="o">.</span><span class="na">newCondition</span><span class="o">();</span>
        <span class="n">notFullCondition</span> <span class="o">=</span> <span class="n">lock</span><span class="o">.</span><span class="na">newCondition</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="cm">/**
</span><span class="cm">     * 生产者
</span><span class="cm">     * @param obj
</span><span class="cm">     * @throws InterruptedException
</span><span class="cm">     */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="n">Object</span> <span class="n">obj</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
        <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>    <span class="c1">//获取锁
</span><span class="c1"></span>        <span class="k">try</span> <span class="o">{</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">maxSize</span> <span class="o">==</span> <span class="n">buffer</span><span class="o">.</span><span class="na">size</span><span class="o">()){</span>
                <span class="n">notFullCondition</span><span class="o">.</span><span class="na">await</span><span class="o">();</span>       <span class="c1">//满了，添加的线程进入等待状态
</span><span class="c1"></span>            <span class="o">}</span>
            <span class="n">buffer</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>
            <span class="n">fullCondition</span><span class="o">.</span><span class="na">signal</span><span class="o">();</span> <span class="c1">//通知
</span><span class="c1"></span>        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/**
</span><span class="cm">     * 消费者
</span><span class="cm">     * @return
</span><span class="cm">     * @throws InterruptedException
</span><span class="cm">     */</span>
    <span class="kd">public</span> <span class="n">Object</span> <span class="nf">get</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
        <span class="n">Object</span> <span class="n">obj</span><span class="o">;</span>
        <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">buffer</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="n">0</span><span class="o">){</span> <span class="c1">//队列中没有数据了 线程进入等待状态
</span><span class="c1"></span>                <span class="n">fullCondition</span><span class="o">.</span><span class="na">await</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="n">notFullCondition</span><span class="o">.</span><span class="na">signal</span><span class="o">();</span> <span class="c1">//通知
</span><span class="c1"></span>        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">obj</span><span class="o">;</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="reentrantlock">ReentrantLock</h4>
<p>可重入锁：当某个线程请求一个被其他线程所持有的锁的时候，该线程会被阻塞（读写锁先不考虑），但是像 synchronized 这样的内置锁是可重入的，即一个线程试图获取一个已被该线程持有的锁，这个请求会成功。</p>
<p>synchronized 锁 和 ReentrantLock 两者都是可重入锁。</p>
<p>重入指的是锁的操作粒度是线程级别而不是调用级别。</p>
<p>ReentrantLock 也是可重入锁，除了支持可重入外，也支持公平和非公平的选择。</p>
<p>ReentrantLock 是 Lock 接口的实现类</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ReentrantLock</span> <span class="kd">implements</span> <span class="n">Lock</span><span class="o">,</span> <span class="n">java</span><span class="o">.</span><span class="na">io</span><span class="o">.</span><span class="na">Serializable</span>
</code></pre></td></tr></table>
</div>
</div><h5 id="reentrantlock-实现的可重入性">ReentrantLock 实现的可重入性</h5>
<p>对于锁的可重入性，需要解决如下两个问题</p>
<ul>
<li>线程再次获取锁的识别问题（锁需要识别出当前要获取锁的线程是否为当前持有锁的线程）</li>
<li>锁的释放（同一个线程多次获取同一把锁，那么锁的记录也会不同。一般来说，当同一个线程重复 n 次获取锁之后，只有在之后的释放 n 次锁之后，其他线程才能去竞争这把锁）</li>
</ul>
<p>ReentrantLock 锁的可重入测试示例</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kn">import</span> <span class="nn">java.util.concurrent.TimeUnit</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.locks.Lock</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.locks.ReentrantLock</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>

    <span class="n">Lock</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ReentrantLock</span><span class="o">();</span>

    <span class="kt">void</span> <span class="nf">m1</span><span class="o">(){</span>
        <span class="k">try</span><span class="o">{</span>
            <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span> <span class="c1">//加锁
</span><span class="c1"></span>            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">5</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="n">1</span><span class="o">);</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;m1 method &#34;</span> <span class="o">+</span> <span class="n">i</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="n">m2</span><span class="o">();</span> <span class="c1">//在释放锁之前，调用m2方法
</span><span class="c1"></span>        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span><span class="k">finally</span> <span class="o">{</span>
            <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span> <span class="c1">//释放锁
</span><span class="c1"></span>        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">m2</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;m2 method&#34;</span><span class="o">);</span>
        <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="n">Test</span> <span class="n">test</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Test</span><span class="o">();</span>
        <span class="k">new</span> <span class="n">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">test</span><span class="o">.</span><span class="na">m1</span><span class="o">()).</span><span class="na">start</span><span class="o">();</span>
        <span class="k">new</span> <span class="n">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">test</span><span class="o">.</span><span class="na">m2</span><span class="o">()).</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>ReentrantLock 具有公平锁（FairSync）和非公平锁（NonfairSync）的实现，默认是非公平锁</p>
<p>公平锁：每一次 tryAcquire 都会检查 CLH 队列中是否仍有前驱元素，如果有就继续等待，通过这种方式保证先来先服务（FIFO）的原则</p>
<p>非公平锁：先检查并设置锁的状态，这种方式会出现即使队列中有等待的线程，新的线程仍然会与排队的线程中的对头线程竞争（排队的线程是先来先服务的），所以新的线程可能会在已经在排队的线程前抢到锁，也可能抢不到锁</p>
<ul>
<li>公平锁能保证：老线程和新线程都排队使用锁</li>
<li>非公平锁能保证：老的线程排队使用锁，但是无法保证新的线程一定能在排队的线程前抢到锁（新的线程与队列队首的线程公平地抢占锁）。</li>
</ul>
<p>源码如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java">
<span class="cm">/**
</span><span class="cm"> * Base of synchronization control for this lock. Subclassed
</span><span class="cm"> * into fair and nonfair versions below. Uses AQS state to
</span><span class="cm"> * represent the number of holds on the lock.
</span><span class="cm"> */</span>
<span class="kd">abstract</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Sync</span> <span class="kd">extends</span> <span class="n">AbstractQueuedSynchronizer</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">serialVersionUID</span> <span class="o">=</span> <span class="o">-</span><span class="n">5179523762034025860L</span><span class="o">;</span>

    <span class="cm">/**
</span><span class="cm">     * Performs {@link Lock#lock}. The main reason for subclassing
</span><span class="cm">     * is to allow fast path for nonfair version.
</span><span class="cm">     */</span>
    <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">lock</span><span class="o">();</span>

    <span class="cm">/**
</span><span class="cm">     * Performs non-fair tryLock.  tryAcquire is implemented in
</span><span class="cm">     * subclasses, but both need nonfair try for trylock method.
</span><span class="cm">     */</span>
    <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">nonfairTryAcquire</span><span class="o">(</span><span class="kt">int</span> <span class="n">acquires</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="n">Thread</span> <span class="n">current</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">getState</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">compareAndSetState</span><span class="o">(</span><span class="n">0</span><span class="o">,</span> <span class="n">acquires</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">setExclusiveOwnerThread</span><span class="o">(</span><span class="n">current</span><span class="o">);</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">current</span> <span class="o">==</span> <span class="n">getExclusiveOwnerThread</span><span class="o">())</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">nextc</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="n">acquires</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nextc</span> <span class="o">&lt;</span> <span class="n">0</span><span class="o">)</span> <span class="c1">// overflow
</span><span class="c1"></span>                <span class="k">throw</span> <span class="k">new</span> <span class="n">Error</span><span class="o">(</span><span class="s">&#34;Maximum lock count exceeded&#34;</span><span class="o">);</span>
            <span class="n">setState</span><span class="o">(</span><span class="n">nextc</span><span class="o">);</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">protected</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">tryRelease</span><span class="o">(</span><span class="kt">int</span> <span class="n">releases</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">getState</span><span class="o">()</span> <span class="o">-</span> <span class="n">releases</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">()</span> <span class="o">!=</span> <span class="n">getExclusiveOwnerThread</span><span class="o">())</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalMonitorStateException</span><span class="o">();</span>
        <span class="kt">boolean</span> <span class="n">free</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">free</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="n">setExclusiveOwnerThread</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">setState</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">free</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">protected</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">isHeldExclusively</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// While we must in general read state before owner,
</span><span class="c1"></span>        <span class="c1">// we don&#39;t need to do so to check if current thread is owner
</span><span class="c1"></span>        <span class="k">return</span> <span class="n">getExclusiveOwnerThread</span><span class="o">()</span> <span class="o">==</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">final</span> <span class="n">ConditionObject</span> <span class="nf">newCondition</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">ConditionObject</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="c1">// Methods relayed from outer class
</span><span class="c1"></span>
    <span class="kd">final</span> <span class="n">Thread</span> <span class="nf">getOwner</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">getState</span><span class="o">()</span> <span class="o">==</span> <span class="n">0</span> <span class="o">?</span> <span class="kc">null</span> <span class="o">:</span> <span class="n">getExclusiveOwnerThread</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">final</span> <span class="kt">int</span> <span class="nf">getHoldCount</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">isHeldExclusively</span><span class="o">()</span> <span class="o">?</span> <span class="n">getState</span><span class="o">()</span> <span class="o">:</span> <span class="n">0</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">isLocked</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">getState</span><span class="o">()</span> <span class="o">!=</span> <span class="n">0</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
</span><span class="cm">     * Reconstitutes the instance from a stream (that is, deserializes it).
</span><span class="cm">     */</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">readObject</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="na">io</span><span class="o">.</span><span class="na">ObjectInputStream</span> <span class="n">s</span><span class="o">)</span>
        <span class="kd">throws</span> <span class="n">java</span><span class="o">.</span><span class="na">io</span><span class="o">.</span><span class="na">IOException</span><span class="o">,</span> <span class="n">ClassNotFoundException</span> <span class="o">{</span>
        <span class="n">s</span><span class="o">.</span><span class="na">defaultReadObject</span><span class="o">();</span>
        <span class="n">setState</span><span class="o">(</span><span class="n">0</span><span class="o">);</span> <span class="c1">// reset to unlocked state
</span><span class="c1"></span>    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/**
</span><span class="cm"> * Sync object for non-fair locks
</span><span class="cm"> */</span>
<span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">NonfairSync</span> <span class="kd">extends</span> <span class="n">Sync</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">serialVersionUID</span> <span class="o">=</span> <span class="n">7316153563782823691L</span><span class="o">;</span>

    <span class="cm">/**
</span><span class="cm">     * Performs lock.  Try immediate barge, backing up to normal
</span><span class="cm">     * acquire on failure.
</span><span class="cm">     */</span>
    <span class="kd">final</span> <span class="kt">void</span> <span class="nf">lock</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">compareAndSetState</span><span class="o">(</span><span class="n">0</span><span class="o">,</span> <span class="n">1</span><span class="o">))</span>
            <span class="n">setExclusiveOwnerThread</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">());</span>
        <span class="k">else</span>
            <span class="n">acquire</span><span class="o">(</span><span class="n">1</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">protected</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">tryAcquire</span><span class="o">(</span><span class="kt">int</span> <span class="n">acquires</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">nonfairTryAcquire</span><span class="o">(</span><span class="n">acquires</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/**
</span><span class="cm"> * Sync object for fair locks
</span><span class="cm"> */</span>
<span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">FairSync</span> <span class="kd">extends</span> <span class="n">Sync</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">serialVersionUID</span> <span class="o">=</span> <span class="o">-</span><span class="n">3000897897090466540L</span><span class="o">;</span>

    <span class="kd">final</span> <span class="kt">void</span> <span class="nf">lock</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">acquire</span><span class="o">(</span><span class="n">1</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/**
</span><span class="cm">     * Fair version of tryAcquire.  Don&#39;t grant access unless
</span><span class="cm">     * recursive call or no waiters or is first.
</span><span class="cm">     */</span>
    <span class="kd">protected</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">tryAcquire</span><span class="o">(</span><span class="kt">int</span> <span class="n">acquires</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="n">Thread</span> <span class="n">current</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">getState</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">hasQueuedPredecessors</span><span class="o">()</span> <span class="o">&amp;&amp;</span>
                <span class="n">compareAndSetState</span><span class="o">(</span><span class="n">0</span><span class="o">,</span> <span class="n">acquires</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">setExclusiveOwnerThread</span><span class="o">(</span><span class="n">current</span><span class="o">);</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">current</span> <span class="o">==</span> <span class="n">getExclusiveOwnerThread</span><span class="o">())</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">nextc</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="n">acquires</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nextc</span> <span class="o">&lt;</span> <span class="n">0</span><span class="o">)</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="n">Error</span><span class="o">(</span><span class="s">&#34;Maximum lock count exceeded&#34;</span><span class="o">);</span>
            <span class="n">setState</span><span class="o">(</span><span class="n">nextc</span><span class="o">);</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/**
</span><span class="cm"> * Creates an instance of {@code ReentrantLock}.
</span><span class="cm"> * This is equivalent to using {@code ReentrantLock(false)}.
</span><span class="cm"> */</span>
<span class="kd">public</span> <span class="nf">ReentrantLock</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">sync</span> <span class="o">=</span> <span class="k">new</span> <span class="n">NonfairSync</span><span class="o">();</span>
<span class="o">}</span>

<span class="cm">/**
</span><span class="cm"> * Creates an instance of {@code ReentrantLock} with the
</span><span class="cm"> * given fairness policy.
</span><span class="cm"> *
</span><span class="cm"> * @param fair {@code true} if this lock should use a fair ordering policy
</span><span class="cm"> */</span>
<span class="kd">public</span> <span class="nf">ReentrantLock</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">fair</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">sync</span> <span class="o">=</span> <span class="n">fair</span> <span class="o">?</span> <span class="k">new</span> <span class="n">FairSync</span><span class="o">()</span> <span class="o">:</span> <span class="k">new</span> <span class="n">NonfairSync</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="线程通信">线程通信</h2>
<h3 id="wait--notify">wait &amp; notify</h3>
<p>线程间通信可以通过<code>共享变量 + wait() &amp; notify()</code> 来实现</p>
<p>wait() 将线程进入阻塞状态</p>
<p>notify() 将线程唤醒</p>
<p>当多线程竞争访问对象的同步方法时，锁对象会关联一个底层的 Monitor 对象（重量级锁的实现）</p>
<p>如下图</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/images/20210222-Monitor%e5%af%b9%e8%b1%a1.png"
        data-srcset="/images/20210222-Monitor%e5%af%b9%e8%b1%a1.png, /images/20210222-Monitor%e5%af%b9%e8%b1%a1.png 1.5x, /images/20210222-Monitor%e5%af%b9%e8%b1%a1.png 2x"
        data-sizes="auto"
        alt="/images/20210222-Monitor对象.png"
        title="Monitor对象" /></p>
<ul>
<li>Thread-0 先获取到对象的锁，关联到 monitor 的 owner ，同步代码块内调用了锁对象的 wait() 方法，调用后会进入 waitSet 等待。Thread-1 同样如此，此时 Thread-0 的状态为 Waiting</li>
<li>Thread-2、Thread-3、Thread-4、Thread-5 同时竞争，Thread-2 获取到锁后，关联了 monitor 的 owner，Thread-3、Thread-4、Thread-5 只能进入 EntryList 中等待，此时 Thread-2 线程状态为 Runnable ， Thread-3、Thread-4、Thread-5 的状态为 Blocked</li>
<li>Thread-2 执行完后，唤醒 EntryList 中的线程，Thread-3、Thread-4、Thread-5 进行竞争锁，获取到锁的线程会关联 monitor 的 owner</li>
<li>Thread-3、Thread-4、Thread-5 线程在执行过程中，调用了锁对象的 notify() 或 notifyAll() 时，会唤醒 waitSet 的线程，唤醒的线程进入 EntryList 等待重新竞争锁</li>
</ul>
<p>注意：</p>
<ul>
<li>Blocked 状态和 Waiting 状态都是阻塞状态</li>
<li>Blocked 状态的线程会在 owner 线程释放锁时被唤醒</li>
<li>wait 和 notify 使用场景必须要有同步，且必须获得对象的锁后才能调用，否则会抛出异常</li>
<li>wait() 会释放锁，进入 waitSet，wait()方法可指定时间，如果指定时间内未被唤醒，则自动唤醒</li>
<li>notify() 会随机唤醒一个 waitSet 中的线程</li>
<li>notifyAll() 会唤醒 waitSet 中所有的线程</li>
</ul>
<p>示例</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">static</span> <span class="kd">final</span> <span class="n">Object</span> <span class="n">lock1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Object</span><span class="o">();</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

    <span class="k">new</span> <span class="n">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="kd">synchronized</span> <span class="o">(</span><span class="n">lock1</span><span class="o">){</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;t1开始执行&#34;</span><span class="o">);</span>
            <span class="k">try</span><span class="o">{</span>
                <span class="n">lock1</span><span class="o">.</span><span class="na">wait</span><span class="o">();</span> <span class="c1">//同步代码块内部才可以调用
</span><span class="c1"></span>            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;t1继续执行核心逻辑&#34;</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">},</span><span class="s">&#34;t1&#34;</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>

    <span class="k">new</span> <span class="n">Thread</span><span class="o">(()-&gt;{</span>
        <span class="kd">synchronized</span> <span class="o">(</span><span class="n">lock1</span><span class="o">){</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;t2开始执行&#34;</span><span class="o">);</span>
            <span class="k">try</span><span class="o">{</span>
                <span class="n">lock1</span><span class="o">.</span><span class="na">wait</span><span class="o">();</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;t2继续执行核心逻辑&#34;</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">},</span> <span class="s">&#34;t2&#34;</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>

    <span class="k">try</span> <span class="o">{</span>
        <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="n">2000</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;开始唤醒&#34;</span><span class="o">);</span>

    <span class="kd">synchronized</span> <span class="o">(</span><span class="n">lock1</span><span class="o">){</span>
        <span class="n">lock1</span><span class="o">.</span><span class="na">notifyAll</span><span class="o">();</span> <span class="c1">//同步代码块内才能调用
</span><span class="c1"></span>    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>wait 和 sleep 的区别？</p>
<ul>
<li>相同点：两者都会让线程进入阻塞状态</li>
<li>不同点：
<ul>
<li>wait 是 Object 的方法， sleep 是 Thread 的方法</li>
<li>wait 会立即释放锁， sleep 不会释放锁</li>
<li>wait 后线程的状态是 Waiting， sleep 后线程的状态是 Time_Waiting</li>
</ul>
</li>
</ul>
<p>实例：一个线程输出 a ，一个线程输出 b ，一个线程输出 c ， abc按照顺序输出，连续输出5次</p>
<p>这里考的是线程的通信，利用 wait()/notify() 和控制变量可以实现，此处使用 ReentrantLock 实现该功能。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">AwaitSignal</span> <span class="n">awaitSignal</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AwaitSignal</span><span class="o">(</span><span class="n">5</span><span class="o">);</span>
    <span class="c1">//构造三个条件变量
</span><span class="c1"></span>    <span class="n">Condition</span> <span class="n">a</span> <span class="o">=</span> <span class="n">awaitSignal</span><span class="o">.</span><span class="na">newCondition</span><span class="o">();</span>
    <span class="n">Condition</span> <span class="n">b</span> <span class="o">=</span> <span class="n">awaitSignal</span><span class="o">.</span><span class="na">newCondition</span><span class="o">();</span>
    <span class="n">Condition</span> <span class="n">c</span> <span class="o">=</span> <span class="n">awaitSignal</span><span class="o">.</span><span class="na">newCondition</span><span class="o">();</span>
    <span class="c1">//开启三个线程
</span><span class="c1"></span>    <span class="k">new</span> <span class="n">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="n">awaitSignal</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">&#34;a&#34;</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">);</span>
    <span class="o">}).</span><span class="na">start</span><span class="o">();</span>
    <span class="k">new</span> <span class="n">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="n">awaitSignal</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">&#34;b&#34;</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">);</span>
    <span class="o">}).</span><span class="na">start</span><span class="o">();</span>
    <span class="k">new</span> <span class="n">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="n">awaitSignal</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">&#34;c&#34;</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">a</span><span class="o">);</span>
    <span class="o">}).</span><span class="na">start</span><span class="o">();</span>

    <span class="k">try</span> <span class="o">{</span>
        <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="n">1000</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="n">awaitSignal</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>

    <span class="k">try</span> <span class="o">{</span>
        <span class="n">a</span><span class="o">.</span><span class="na">signal</span><span class="o">();</span>
    <span class="o">}</span><span class="k">finally</span> <span class="o">{</span>
        <span class="n">awaitSignal</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
    <span class="o">}</span>

<span class="o">}</span>

<span class="kd">static</span> <span class="kd">class</span> <span class="nc">AwaitSignal</span> <span class="kd">extends</span> <span class="n">ReentrantLock</span> <span class="o">{</span>
    <span class="c1">//循环次数
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">loopNumber</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">AwaitSignal</span><span class="o">(</span><span class="kt">int</span> <span class="n">loopNumber</span><span class="o">){</span>
        <span class="k">this</span><span class="o">.</span><span class="na">loopNumber</span> <span class="o">=</span> <span class="n">loopNumber</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
</span><span class="cm">     *
</span><span class="cm">     * @param print 输出的字符
</span><span class="cm">     * @param current 当前条件变量
</span><span class="cm">     * @param next 下一个条件变量
</span><span class="cm">     */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">(</span><span class="n">String</span> <span class="n">print</span><span class="o">,</span> <span class="n">Condition</span> <span class="n">current</span><span class="o">,</span> <span class="n">Condition</span> <span class="n">next</span><span class="o">){</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">loopNumber</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">lock</span><span class="o">();</span>
            <span class="k">try</span><span class="o">{</span>
                <span class="n">current</span><span class="o">.</span><span class="na">await</span><span class="o">();</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">print</span><span class="o">);</span>

                <span class="n">next</span><span class="o">.</span><span class="na">signal</span><span class="o">();</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="o">}</span><span class="k">finally</span> <span class="o">{</span>
                <span class="n">unlock</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="park--unpark">park &amp; unpark</h3>
<p>LockSupport 是 java.util.concurrent 下的工具类，提供了 park 和 unpark 方法，可以实现线程通信</p>
<p>与wait&amp;notify相比，不同点</p>
<ul>
<li>wait 和 notify 需要获取对象锁（配合 Object Monitor 使用），而 park 和 unpark 不需要</li>
<li>unpark 可以指定唤醒线程， notify 是随机唤醒某个线程，notifyAll 是唤醒所有等待的线程</li>
<li>park 和 unpark 的顺序可以先 unpark ，wait 和 notify 的顺序不能颠倒，必须先 wait</li>
</ul>
<p>源码定义</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="cm">/**
</span><span class="cm"> * Disables the current thread for thread scheduling purposes unless the
</span><span class="cm"> * permit is available.
</span><span class="cm"> *
</span><span class="cm"> * &lt;p&gt;If the permit is available then it is consumed and the call
</span><span class="cm"> * returns immediately; otherwise the current thread becomes disabled
</span><span class="cm"> * for thread scheduling purposes and lies dormant until one of three
</span><span class="cm"> * things happens:
</span><span class="cm"> *
</span><span class="cm"> * &lt;ul&gt;
</span><span class="cm"> *
</span><span class="cm"> * &lt;li&gt;Some other thread invokes {@link #unpark unpark} with the
</span><span class="cm"> * current thread as the target; or
</span><span class="cm"> *
</span><span class="cm"> * &lt;li&gt;Some other thread {@linkplain Thread#interrupt interrupts}
</span><span class="cm"> * the current thread; or
</span><span class="cm"> *
</span><span class="cm"> * &lt;li&gt;The call spuriously (that is, for no reason) returns.
</span><span class="cm"> * &lt;/ul&gt;
</span><span class="cm"> *
</span><span class="cm"> * &lt;p&gt;This method does &lt;em&gt;not&lt;/em&gt; report which of these caused the
</span><span class="cm"> * method to return. Callers should re-check the conditions which caused
</span><span class="cm"> * the thread to park in the first place. Callers may also determine,
</span><span class="cm"> * for example, the interrupt status of the thread upon return.
</span><span class="cm"> */</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">park</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">UNSAFE</span><span class="o">.</span><span class="na">park</span><span class="o">(</span><span class="kc">false</span><span class="o">,</span> <span class="n">0L</span><span class="o">);</span>
<span class="o">}</span>


<span class="cm">/**
</span><span class="cm"> * Makes available the permit for the given thread, if it
</span><span class="cm"> * was not already available.  If the thread was blocked on
</span><span class="cm"> * {@code park} then it will unblock.  Otherwise, its next call
</span><span class="cm"> * to {@code park} is guaranteed not to block. This operation
</span><span class="cm"> * is not guaranteed to have any effect at all if the given
</span><span class="cm"> * thread has not been started.
</span><span class="cm"> *
</span><span class="cm"> * @param thread the thread to unpark, or {@code null}, in which case
</span><span class="cm"> *        this operation has no effect
</span><span class="cm"> */</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">unpark</span><span class="o">(</span><span class="n">Thread</span> <span class="n">thread</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">thread</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
        <span class="n">UNSAFE</span><span class="o">.</span><span class="na">unpark</span><span class="o">(</span><span class="n">thread</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>参考：https://blog.csdn.net/e891377/article/details/104551335</p>
</blockquote>
<p>park() 将线程挂起</p>
<p>unpark(Thread thread) 恢复某个线程运行</p>
<p>先 park 再 unpark ，代码示例</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Thread</span> <span class="n">t1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(()-&gt;{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;t1 start&#34;</span><span class="o">);</span>

        <span class="k">try</span> <span class="o">{</span>
            <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="n">1000</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;t1 park&#34;</span><span class="o">);</span>
        <span class="n">LockSupport</span><span class="o">.</span><span class="na">park</span><span class="o">();</span> <span class="c1">//t1线程1s后挂起
</span><span class="c1"></span>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;t1 resume&#34;</span><span class="o">);</span>
    <span class="o">},</span> <span class="s">&#34;t1&#34;</span><span class="o">);</span>
    <span class="n">t1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>

    <span class="k">try</span> <span class="o">{</span>
        <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="n">2000</span><span class="o">);</span> <span class="c1">//主线程睡眠2s
</span><span class="c1"></span>    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;unpark&#34;</span><span class="o">);</span>
    <span class="n">LockSupport</span><span class="o">.</span><span class="na">unpark</span><span class="o">(</span><span class="n">t1</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>先 unpark 再 park 代码示例</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Thread</span> <span class="n">t1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(()-&gt;{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;t1 start&#34;</span><span class="o">);</span>

        <span class="k">try</span> <span class="o">{</span>
            <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="n">2000</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;t1 park&#34;</span><span class="o">);</span>
        <span class="n">LockSupport</span><span class="o">.</span><span class="na">park</span><span class="o">();</span> <span class="c1">//t1线程1s后挂起
</span><span class="c1"></span>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;t1 resume&#34;</span><span class="o">);</span>
    <span class="o">},</span> <span class="s">&#34;t1&#34;</span><span class="o">);</span>
    <span class="n">t1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>

    <span class="k">try</span> <span class="o">{</span>
        <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="n">1000</span><span class="o">);</span> <span class="c1">//主线程睡眠2s
</span><span class="c1"></span>    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;unpark&#34;</span><span class="o">);</span>
    <span class="n">LockSupport</span><span class="o">.</span><span class="na">unpark</span><span class="o">(</span><span class="n">t1</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="生产者消费者模型">生产者消费者模型</h3>
<p><strong>生产者消费者模型</strong>指的是有生产者来生产数据，消费者来消费数据，生产者生产满了就不生产了，通知消费者取，等消费了再进行生产。消费者消费不到了就不消费了，通知生产者生产，生产到了再继续消费。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/images/20210223-%e7%94%9f%e4%ba%a7%e8%80%85%e6%b6%88%e8%b4%b9%e8%80%85%e6%a8%a1%e5%9e%8b.png"
        data-srcset="/images/20210223-%e7%94%9f%e4%ba%a7%e8%80%85%e6%b6%88%e8%b4%b9%e8%80%85%e6%a8%a1%e5%9e%8b.png, /images/20210223-%e7%94%9f%e4%ba%a7%e8%80%85%e6%b6%88%e8%b4%b9%e8%80%85%e6%a8%a1%e5%9e%8b.png 1.5x, /images/20210223-%e7%94%9f%e4%ba%a7%e8%80%85%e6%b6%88%e8%b4%b9%e8%80%85%e6%a8%a1%e5%9e%8b.png 2x"
        data-sizes="auto"
        alt="/images/20210223-生产者消费者模型.png"
        title="生产者消费者模型" /></p>
<p>生产者消费者代码示例</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span><span class="lnt">93
</span><span class="lnt">94
</span><span class="lnt">95
</span><span class="lnt">96
</span><span class="lnt">97
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">MessageQueue</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MessageQueue</span><span class="o">(</span><span class="n">2</span><span class="o">);</span>

    <span class="c1">//三个生产者想队列里存值
</span><span class="c1"></span>    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">3</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
        <span class="k">new</span> <span class="n">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="n">queue</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="k">new</span> <span class="n">Message</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="s">&#34;值：&#34;</span> <span class="o">+</span> <span class="n">id</span><span class="o">));</span>
        <span class="o">},</span> <span class="s">&#34;生产者&#34;</span> <span class="o">+</span> <span class="n">i</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="k">try</span> <span class="o">{</span>
        <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="n">1000</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="c1">//一个消费者不停从队列中取值
</span><span class="c1"></span>    <span class="k">new</span> <span class="n">Thread</span><span class="o">(()-&gt;{</span>
        <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">){</span>
            <span class="n">queue</span><span class="o">.</span><span class="na">take</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">},</span> <span class="s">&#34;消费者&#34;</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">//消息队列被生产者和消费者持有
</span><span class="c1"></span><span class="kd">static</span> <span class="kd">class</span> <span class="nc">MessageQueue</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">Message</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>

    <span class="c1">//容量
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">capacity</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">MessageQueue</span><span class="o">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">capacity</span> <span class="o">=</span> <span class="n">capacity</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
</span><span class="cm">     * 生产者生产
</span><span class="cm">     * @param message
</span><span class="cm">     */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="n">Message</span> <span class="n">message</span><span class="o">){</span>
        <span class="kd">synchronized</span> <span class="o">(</span><span class="n">list</span><span class="o">){</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="n">capacity</span><span class="o">){</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;队列已满，生产者等待&#34;</span><span class="o">);</span>
                <span class="k">try</span><span class="o">{</span>
                    <span class="n">list</span><span class="o">.</span><span class="na">wait</span><span class="o">();</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="n">list</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">&#34;生产者消息：{%s}\n&#34;</span><span class="o">,</span> <span class="n">message</span><span class="o">);</span>
            <span class="c1">//生产后通知消费者
</span><span class="c1"></span>            <span class="n">list</span><span class="o">.</span><span class="na">notifyAll</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/**
</span><span class="cm">     * 消费者消费
</span><span class="cm">     * @return
</span><span class="cm">     */</span>
    <span class="kd">public</span> <span class="n">Message</span> <span class="nf">take</span><span class="o">(){</span>
        <span class="kd">synchronized</span> <span class="o">(</span><span class="n">list</span><span class="o">){</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;队列已空，消费者等待&#34;</span><span class="o">);</span>
                <span class="k">try</span><span class="o">{</span>
                    <span class="n">list</span><span class="o">.</span><span class="na">wait</span><span class="o">();</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="n">Message</span> <span class="n">message</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">removeFirst</span><span class="o">();</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">&#34;消费消息：{%s}\n&#34;</span><span class="o">,</span><span class="n">message</span><span class="o">);</span>
            <span class="n">list</span><span class="o">.</span><span class="na">notifyAll</span><span class="o">();</span> <span class="c1">//消费后通知生产者
</span><span class="c1"></span>            <span class="k">return</span> <span class="n">message</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">static</span> <span class="kd">class</span> <span class="nc">Message</span><span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">id</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">Object</span> <span class="n">value</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Message</span><span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">,</span> <span class="n">Object</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">id</span> <span class="o">=</span> <span class="n">id</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">&#34;Message{&#34;</span> <span class="o">+</span>
                <span class="s">&#34;id=&#34;</span> <span class="o">+</span> <span class="n">id</span> <span class="o">+</span>
                <span class="s">&#34;, value=&#34;</span> <span class="o">+</span> <span class="n">value</span> <span class="o">+</span>
                <span class="sc">&#39;}&#39;</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="死锁">死锁</h2>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/images/20210223-%e6%ad%bb%e9%94%81%e5%9b%be%e8%a7%a3.png"
        data-srcset="/images/20210223-%e6%ad%bb%e9%94%81%e5%9b%be%e8%a7%a3.png, /images/20210223-%e6%ad%bb%e9%94%81%e5%9b%be%e8%a7%a3.png 1.5x, /images/20210223-%e6%ad%bb%e9%94%81%e5%9b%be%e8%a7%a3.png 2x"
        data-sizes="auto"
        alt="/images/20210223-死锁图解.png"
        title="死锁图解" /></p>
<p>死锁的代码示例</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">static</span> <span class="kd">class</span> <span class="nc">Beer</span><span class="o">{}</span>
<span class="kd">static</span> <span class="kd">class</span> <span class="nc">Story</span><span class="o">{}</span>
<span class="kd">static</span> <span class="n">Beer</span> <span class="n">beer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Beer</span><span class="o">();</span>
<span class="kd">static</span> <span class="n">Story</span> <span class="n">story</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Story</span><span class="o">();</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">new</span> <span class="n">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="kd">synchronized</span> <span class="o">(</span><span class="n">beer</span><span class="o">){</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;我有酒，给我故事&#34;</span><span class="o">);</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="n">1000</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="kd">synchronized</span> <span class="o">(</span><span class="n">story</span><span class="o">){</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;小王开始喝酒讲故事&#34;</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">},</span><span class="s">&#34;小王&#34;</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>

    <span class="k">new</span> <span class="n">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="kd">synchronized</span> <span class="o">(</span><span class="n">story</span><span class="o">){</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;我有故事，给我酒&#34;</span><span class="o">);</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="n">1000</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="kd">synchronized</span> <span class="o">(</span><span class="n">beer</span><span class="o">){</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;老王开始喝酒讲故事&#34;</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">},</span><span class="s">&#34;老王&#34;</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>死锁导致程序无法正常运行</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">我有酒，给我故事
我有故事，给我酒
</code></pre></td></tr></table>
</div>
</div><p>可以使用 jdk/bin/jvisualvm.exe 检测死锁原因</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/images/20210223-%e6%ad%bb%e9%94%81dump%e4%bf%a1%e6%81%af.png"
        data-srcset="/images/20210223-%e6%ad%bb%e9%94%81dump%e4%bf%a1%e6%81%af.png, /images/20210223-%e6%ad%bb%e9%94%81dump%e4%bf%a1%e6%81%af.png 1.5x, /images/20210223-%e6%ad%bb%e9%94%81dump%e4%bf%a1%e6%81%af.png 2x"
        data-sizes="auto"
        alt="/images/20210223-死锁dump信息.png"
        title="死锁dump信息" /></p>
<h2 id="java内存模型jmm">Java内存模型（JMM）</h2>
<blockquote>
<p>参考:<br>
<a href="https://www.cnblogs.com/xidongyu/articles/12240022.html">https://www.cnblogs.com/xidongyu/articles/12240022.html</a><br>
<a href="https://zhuanlan.zhihu.com/p/29881777">https://zhuanlan.zhihu.com/p/29881777</a></p>
</blockquote>
<h3 id="什么是-java-内存模型jmm">什么是 Java 内存模型（JMM）</h3>
<p><code>JVM 内存模式</code>指的是 <code>JVM 的内存分区</code>，而 <code>Java内存模型</code>是一种虚拟机规范</p>
<p>Java虚拟机规范中定义了 Java内存模型（Java Memory Model, JMM），用于屏蔽掉各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的并发效果，JMM 规范了 Java 虚拟机与计算机内存是如何协同工作的：规定了一个线程如何及何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步地访问共享变量。</p>
<p>原始的Java内存模型存在一些不足，因此Java内存模型在Java1.5时被重新修订。这个版本的Java内存模型在Java8中仍然在使用。</p>
<p>jmm 体现在以下三个方面</p>
<ul>
<li>原子性 保证指令不会受到上下文切换的影响</li>
<li>可见性 保证指令不会受到cpu缓存的影响</li>
<li>有序性 保证指令不会受并行优化的影响</li>
</ul>
<h3 id="java内存模型和深度剖析volatile">Java内存模型和深度剖析volatile</h3>
<blockquote>
<p>参考：https://www.cnblogs.com/dolphin0520/p/3920373.html</p>
</blockquote>
<h4 id="内存模型的相关概念">内存模型的相关概念</h4>
<p>大家都知道，计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。</p>
<p>也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。举个简单的例子，比如下面的这段代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">1</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><p>当线程执行这个语句时，会先从主存当中读取i的值，然后复制一份到高速缓存当中，然后CPU执行指令对i进行加1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存当中。</p>
<p>这个代码在单线程中运行是没有任何问题的，但是在多线程中运行就会有问题了。在多核CPU中，每条线程可能运行于不同的CPU中，因此每个线程运行时有自己的高速缓存（对单核CPU来说，其实也会出现这种问题，只不过是以线程调度的形式来分别执行的）。本文我们以多核CPU为例。</p>
<p>比如同时有2个线程执行这段代码，假如初始时i的值为0，那么我们希望两个线程执行完之后i的值变为2。但是事实会是这样吗？</p>
<p>可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程1进行加1操作，然后把i的最新值1写入到内存。此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。</p>
<p>最终结果i的值是1，而不是2。这就是著名的<strong>缓存一致性问题</strong>。</p>
<p>通常称这种被多个线程访问的变量为<strong>共享变量</strong>。</p>
<p>也就是说，如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。</p>
<p>为了解决缓存不一致性问题，通常来说有以下2种解决方法：</p>
<ul>
<li>通过在总线加LOCK#锁的方式</li>
<li>通过缓存一致性协议</li>
</ul>
<p>这2种方式都是硬件层面上提供的方式。</p>
<p>在早期的CPU当中，是通过在总线上加LOCK#锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK#锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中 如果一个线程在执行 <code>i = i + 1</code>，如果在执行这段代码的过程中，在总线上发出了LCOK#锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i所在的内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。</p>
<p>但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。</p>
<p>所以就出现了<strong>缓存一致性协议</strong>。最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/images/20210223-%e7%bc%93%e5%ad%98%e4%b8%80%e8%87%b4%e6%80%a7%e5%9b%be%e8%a7%a3.png"
        data-srcset="/images/20210223-%e7%bc%93%e5%ad%98%e4%b8%80%e8%87%b4%e6%80%a7%e5%9b%be%e8%a7%a3.png, /images/20210223-%e7%bc%93%e5%ad%98%e4%b8%80%e8%87%b4%e6%80%a7%e5%9b%be%e8%a7%a3.png 1.5x, /images/20210223-%e7%bc%93%e5%ad%98%e4%b8%80%e8%87%b4%e6%80%a7%e5%9b%be%e8%a7%a3.png 2x"
        data-sizes="auto"
        alt="/images/20210223-缓存一致性图解.png"
        title="缓存一致性图解" /></p>
<h4 id="并发编程中的三个概念">并发编程中的三个概念</h4>
<p>在并发编程中，我们通常会遇到以下三个问题：原子性问题，可见性问题，有序性问题。我们先看具体看一下这三个概念：</p>
<h5 id="原子性">原子性</h5>
<p><strong>原子性</strong>：即一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p>
<p>一个很经典的例子就是银行账户转账问题：</p>
<p>比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。</p>
<p>试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。然后又从B取出了500元，取出500元之后，再执行 往账户B加上1000元 的操作。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。</p>
<p>所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。</p>
<p>同样地反映到并发编程中会出现什么结果呢？</p>
<p>举个最简单的例子，大家想一下假如为一个32位的变量赋值过程不具备原子性的话，会发生什么后果？</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">i</span> <span class="o">=</span> <span class="n">9</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><p>假若一个线程执行到这个语句时，我暂且假设为一个32位的变量赋值包括两个过程：为低16位赋值，为高16位赋值。</p>
<p>那么就可能发生一种情况：当将低16位数值写入之后，突然被中断，而此时又有一个线程去读取i的值，那么读取到的就是错误的数据。</p>
<h5 id="可见性">可见性</h5>
<p><strong>可见性</strong>：指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p>
<p>举个简单的例子，看下面这段代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">//线程1执行的代码
</span><span class="c1"></span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
<span class="n">i</span> <span class="o">=</span> <span class="n">10</span><span class="o">;</span>
 
<span class="c1">//线程2执行的代码
</span><span class="c1"></span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><p>假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。</p>
<p>此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.</p>
<p>这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。</p>
<h5 id="有序性">有序性</h5>
<p><strong>有序性</strong>：即程序执行的顺序按照代码的先后顺序执行。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>              
<span class="kt">boolean</span> <span class="n">flag</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
<span class="n">i</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span>                <span class="c1">//语句1  
</span><span class="c1"></span><span class="n">flag</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>          <span class="c1">//语句2
</span></code></pre></td></tr></table>
</div>
</div><p>上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生<strong>指令重排序（Instruction Reorder）</strong>。</p>
<p>下面解释一下什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。</p>
<p>比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。</p>
<p>但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">10</span><span class="o">;</span>    <span class="c1">//语句1
</span><span class="c1"></span><span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">2</span><span class="o">;</span>    <span class="c1">//语句2
</span><span class="c1"></span><span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">3</span><span class="o">;</span>    <span class="c1">//语句3
</span><span class="c1"></span><span class="n">r</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">a</span><span class="o">;</span>     <span class="c1">//语句4
</span></code></pre></td></tr></table>
</div>
</div><p>这段代码有4个语句，那么可能的一个执行顺序是：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/images/20210223-%e8%af%ad%e5%8f%a5%e6%89%a7%e8%a1%8c%e9%a1%ba%e5%ba%8f.png"
        data-srcset="/images/20210223-%e8%af%ad%e5%8f%a5%e6%89%a7%e8%a1%8c%e9%a1%ba%e5%ba%8f.png, /images/20210223-%e8%af%ad%e5%8f%a5%e6%89%a7%e8%a1%8c%e9%a1%ba%e5%ba%8f.png 1.5x, /images/20210223-%e8%af%ad%e5%8f%a5%e6%89%a7%e8%a1%8c%e9%a1%ba%e5%ba%8f.png 2x"
        data-sizes="auto"
        alt="/images/20210223-语句执行顺序.png"
        title="语句执行顺序" /></p>
<p>那么可不可能是这个执行顺序呢： 语句2   语句1    语句4   语句3</p>
<p>不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。</p>
<p>虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面看一个例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">//线程1:
</span><span class="c1"></span><span class="n">context</span> <span class="o">=</span> <span class="n">loadContext</span><span class="o">();</span>   <span class="c1">//语句1
</span><span class="c1"></span><span class="n">inited</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>             <span class="c1">//语句2
</span><span class="c1"></span> 
<span class="c1">//线程2:
</span><span class="c1"></span><span class="k">while</span><span class="o">(!</span><span class="n">inited</span> <span class="o">){</span>
  <span class="n">sleep</span><span class="o">()</span>
<span class="o">}</span>
<span class="n">doSomethingwithconfig</span><span class="o">(</span><span class="n">context</span><span class="o">);</span>
</code></pre></td></tr></table>
</div>
</div><p>上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。</p>
<p>从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。</p>
<p>也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。</p>
<h4 id="java-内存模型">Java 内存模型</h4>
<p>在前面谈到了一些关于内存模型以及并发编程中可能会出现的一些问题。下面我们来看一下Java内存模型，研究一下Java内存模型为我们提供了哪些保证以及在java中提供了哪些方法和机制来让我们在进行多线程编程时能够保证程序执行的正确性。</p>
<p>在<strong>Java虚拟机规范</strong>中试图定义一种**Java内存模型（Java Memory Model，JMM）**来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。那么Java内存模型规定了哪些东西呢，它定义了程序中变量的访问规则，往大一点说是定义了程序执行的次序。注意，为了获得较好的执行性能，Java内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，<strong>在java内存模型中，也会存在缓存一致性问题和指令重排序的问题。</strong></p>
<p>Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。</p>
<p>举个简单的例子：在java中，执行下面这个语句：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">i</span> <span class="o">=</span> <span class="n">10</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><p>执行线程必须先在自己的工作线程中对变量i所在的缓存行进行赋值操作，然后再写入主存当中。而不是直接将数值10写入主存当中。</p>
<p>那么Java语言 本身对 原子性、可见性以及有序性提供了哪些保证呢？</p>
<h5 id="原子性-1">原子性</h5>
<p>在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。</p>
<p>上面一句话虽然看起来简单，但是理解起来并不是那么容易。看下面一个例子i：</p>
<p>请分析以下哪些操作是原子性操作：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">x</span> <span class="o">=</span> <span class="n">10</span><span class="o">;</span>         <span class="c1">//语句1
</span><span class="c1"></span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>         <span class="c1">//语句2
</span><span class="c1"></span><span class="n">x</span><span class="o">++;</span>           <span class="c1">//语句3
</span><span class="c1"></span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">1</span><span class="o">;</span>     <span class="c1">//语句4
</span></code></pre></td></tr></table>
</div>
</div><p>咋一看，有些朋友可能会说上面的4个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。</p>
<p>语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。</p>
<p>语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。</p>
<p>同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。</p>
<p>所以上面4个语句只有语句1的操作具备原子性。</p>
<p>也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。</p>
<p>不过这里有一点需要注意：在32位平台下，对64位数据的读取和赋值是需要通过两个操作来完成的，不能保证其原子性。但是好像在最新的JDK中，JVM已经保证对64位数据的读取和赋值也是原子性操作了。</p>
<p>从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</p>
<h5 id="可见性-1">可见性</h5>
<p>对于可见性，Java提供了volatile关键字来保证可见性。</p>
<p>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p>
<p>而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</p>
<p>另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p>
<h5 id="有序性-1">有序性</h5>
<p>在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p>
<p>在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。</p>
<p>另外，<strong>Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序</strong>。</p>
<p>下面就来具体介绍下happens-before原则（先行发生原则）：</p>
<ul>
<li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作</li>
<li>锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作</li>
<li>volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作</li>
<li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</li>
<li>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作</li>
<li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</li>
<li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行</li>
<li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始
　　
这8条原则摘自《深入理解Java虚拟机》。</li>
</ul>
<p>这8条规则中，前4条规则是比较重要的，后4条规则都是显而易见的。</p>
<p>下面我们来解释一下前4条规则：</p>
<p>对于程序次序规则来说，我的理解就是一段程序代码的执行在单个线程中看起来是有序的。注意，虽然这条规则中提到“书写在前面的操作先行发生于书写在后面的操作”，这个应该是程序看起来执行的顺序是按照代码顺序执行的，因为虚拟机可能会对程序代码进行指令重排序。虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，它只会对不存在数据依赖性的指令进行重排序。因此，在单个线程中，程序执行看起来是有序执行的，这一点要注意理解。事实上，这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。</p>
<p>第二条规则也比较容易理解，也就是说无论在单线程中还是多线程中，同一个锁如果出于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行lock操作。</p>
<p>第三条规则是一条比较重要的规则，也是后文将要重点讲述的内容。直观地解释就是，如果一个线程先去写一个volatile变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。</p>
<p>第四条规则实际上就是体现happens-before原则具备传递性。</p>
<h4 id="深入剖析volatile关键字">深入剖析volatile关键字</h4>
<p>在前面讲述了很多东西，其实都是为讲述volatile关键字作铺垫，那么接下来我们就进入主题。</p>
<h5 id="volatile关键字的两层语义">volatile关键字的两层语义</h5>
<p>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</p>
<ul>
<li>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</li>
<li>禁止进行指令重排序。</li>
</ul>
<p>先看一段代码，假如线程1先执行，线程2后执行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">//线程1
</span><span class="c1"></span><span class="kt">boolean</span> <span class="n">stop</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
<span class="k">while</span><span class="o">(!</span><span class="n">stop</span><span class="o">){</span>
    <span class="n">doSomething</span><span class="o">();</span>
<span class="o">}</span>
 
<span class="c1">//线程2
</span><span class="c1"></span><span class="n">stop</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><p>这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。</p>
<p>下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。</p>
<p>那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。</p>
<p>但是用volatile修饰之后就变得不一样了：</p>
<ul>
<li>使用volatile关键字会强制将修改的值立即写入主存；</li>
<li>使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；</li>
<li>由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。</li>
</ul>
<p>那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。</p>
<p>那么线程1读取到的就是最新的正确的值。</p>
<h5 id="volatile保证原子性吗">volatile保证原子性吗？</h5>
<p>从上面知道volatile关键字保证了操作的可见性，但是volatile能保证对变量的操作是原子性吗？</p>
<p>下面看一个例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">volatile</span> <span class="kt">int</span> <span class="n">inc</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
     
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">increase</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">inc</span><span class="o">++;</span>
    <span class="o">}</span>
     
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="n">Test</span> <span class="n">test</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Test</span><span class="o">();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">10</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="k">new</span> <span class="n">Thread</span><span class="o">(){</span>
                <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
                    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">0</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">1000</span><span class="o">;</span><span class="n">j</span><span class="o">++)</span>
                        <span class="n">test</span><span class="o">.</span><span class="na">increase</span><span class="o">();</span>
                <span class="o">};</span>
            <span class="o">}.</span><span class="na">start</span><span class="o">();</span>
        <span class="o">}</span>
         
        <span class="k">while</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">activeCount</span><span class="o">()&gt;</span><span class="n">1</span><span class="o">)</span>  <span class="c1">//保证前面的线程都执行完
</span><span class="c1"></span>            <span class="n">Thread</span><span class="o">.</span><span class="na">yield</span><span class="o">();</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">test</span><span class="o">.</span><span class="na">inc</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>大家想一下这段程序的输出结果是多少？也许有些朋友认为是10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字。</p>
<p>可能有的朋友就会有疑问，不对啊，上面是对变量inc进行自增操作，由于volatile保证了可见性，那么在每个线程中对inc自增完之后，在其他线程中都能看到修改后的值啊，所以有10个线程分别进行了1000次操作，那么最终inc的值应该是1000*10=10000。</p>
<p>这里面就有一个误区了，volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。</p>
<p>在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现：</p>
<p>假如某个时刻变量inc的值为10，</p>
<p>线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了；</p>
<p>然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。</p>
<p>然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。</p>
<p>那么两个线程分别进行了一次自增操作后，inc只增加了1。</p>
<p>解释到这里，可能有朋友会有疑问，不对啊，前面不是保证一个变量在修改volatile变量时，会让缓存行无效吗？然后其他线程去读就会读到新的值，对，这个没错。这个就是上面的happens-before规则中的volatile变量规则，但是要注意，线程1对变量进行读取操作之后，被阻塞了的话，并没有对inc值进行修改。然后虽然volatile能保证线程2对变量inc的值读取是从内存中读取的，但是线程1没有进行修改，所以线程2根本就不会看到修改的值。</p>
<p>根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。</p>
<p>把上面的代码改成以下任何一种都可以达到效果：</p>
<p><strong>采用synchronized：</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
    <span class="kd">public</span>  <span class="kt">int</span> <span class="n">inc</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">increase</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">inc</span><span class="o">++;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="n">Test</span> <span class="n">test</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Test</span><span class="o">();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">10</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="k">new</span> <span class="n">Thread</span><span class="o">(){</span>
                <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
                    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">0</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">1000</span><span class="o">;</span><span class="n">j</span><span class="o">++)</span>
                        <span class="n">test</span><span class="o">.</span><span class="na">increase</span><span class="o">();</span>
                <span class="o">};</span>
            <span class="o">}.</span><span class="na">start</span><span class="o">();</span>
        <span class="o">}</span>
        
        <span class="k">while</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">activeCount</span><span class="o">()&gt;</span><span class="n">1</span><span class="o">)</span>  <span class="c1">//保证前面的线程都执行完
</span><span class="c1"></span>            <span class="n">Thread</span><span class="o">.</span><span class="na">yield</span><span class="o">();</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">test</span><span class="o">.</span><span class="na">inc</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>采用Lock：</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
    <span class="kd">public</span>  <span class="kt">int</span> <span class="n">inc</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
    <span class="n">Lock</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ReentrantLock</span><span class="o">();</span>
    
    <span class="kd">public</span>  <span class="kt">void</span> <span class="nf">increase</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">inc</span><span class="o">++;</span>
        <span class="o">}</span> <span class="k">finally</span><span class="o">{</span>
            <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="n">Test</span> <span class="n">test</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Test</span><span class="o">();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">10</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="k">new</span> <span class="n">Thread</span><span class="o">(){</span>
                <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
                    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">0</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">1000</span><span class="o">;</span><span class="n">j</span><span class="o">++)</span>
                        <span class="n">test</span><span class="o">.</span><span class="na">increase</span><span class="o">();</span>
                <span class="o">};</span>
            <span class="o">}.</span><span class="na">start</span><span class="o">();</span>
        <span class="o">}</span>
        
        <span class="k">while</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">activeCount</span><span class="o">()&gt;</span><span class="n">1</span><span class="o">)</span>  <span class="c1">//保证前面的线程都执行完
</span><span class="c1"></span>            <span class="n">Thread</span><span class="o">.</span><span class="na">yield</span><span class="o">();</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">test</span><span class="o">.</span><span class="na">inc</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>采用AtomicInteger：</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
    <span class="kd">public</span>  <span class="n">AtomicInteger</span> <span class="n">inc</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AtomicInteger</span><span class="o">();</span>
     
    <span class="kd">public</span>  <span class="kt">void</span> <span class="nf">increase</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">inc</span><span class="o">.</span><span class="na">getAndIncrement</span><span class="o">();</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="n">Test</span> <span class="n">test</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Test</span><span class="o">();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">10</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="k">new</span> <span class="n">Thread</span><span class="o">(){</span>
                <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
                    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">0</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">1000</span><span class="o">;</span><span class="n">j</span><span class="o">++)</span>
                        <span class="n">test</span><span class="o">.</span><span class="na">increase</span><span class="o">();</span>
                <span class="o">};</span>
            <span class="o">}.</span><span class="na">start</span><span class="o">();</span>
        <span class="o">}</span>
        
        <span class="k">while</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">activeCount</span><span class="o">()&gt;</span><span class="n">1</span><span class="o">)</span>  <span class="c1">//保证前面的线程都执行完
</span><span class="c1"></span>            <span class="n">Thread</span><span class="o">.</span><span class="na">yield</span><span class="o">();</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">test</span><span class="o">.</span><span class="na">inc</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在java 1.5的java.util.concurrent.atomic包下提供了一些原子操作类，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。atomic是利用CAS来实现原子性操作的（Compare And Swap），CAS实际上是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作。</p>
<h5 id="volatile-能保证有序性吗">volatile 能保证有序性吗？</h5>
<p>在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。</p>
<p>volatile关键字禁止指令重排序有两层意思：</p>
<ul>
<li>当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；</li>
<li>在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。</li>
</ul>
<p>可能上面说的比较绕，举个简单的例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">//x、y为非volatile变量
</span><span class="c1">//flag为volatile变量
</span><span class="c1"></span> 
<span class="n">x</span> <span class="o">=</span> <span class="n">2</span><span class="o">;</span>        <span class="c1">//语句1
</span><span class="c1"></span><span class="n">y</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>        <span class="c1">//语句2
</span><span class="c1"></span><span class="n">flag</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>  <span class="c1">//语句3
</span><span class="c1"></span><span class="n">x</span> <span class="o">=</span> <span class="n">4</span><span class="o">;</span>         <span class="c1">//语句4
</span><span class="c1"></span><span class="n">y</span> <span class="o">=</span> <span class="o">-</span><span class="n">1</span><span class="o">;</span>       <span class="c1">//语句5
</span></code></pre></td></tr></table>
</div>
</div><p>由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。</p>
<p>并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。</p>
<p>那么我们回到前面举的一个例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">//线程1:
</span><span class="c1"></span><span class="n">context</span> <span class="o">=</span> <span class="n">loadContext</span><span class="o">();</span>   <span class="c1">//语句1
</span><span class="c1"></span><span class="n">inited</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>             <span class="c1">//语句2
</span><span class="c1"></span> 
<span class="c1">//线程2:
</span><span class="c1"></span><span class="k">while</span><span class="o">(!</span><span class="n">inited</span> <span class="o">){</span>
  <span class="n">sleep</span><span class="o">()</span>
<span class="o">}</span>
<span class="n">doSomethingwithconfig</span><span class="o">(</span><span class="n">context</span><span class="o">);</span>
</code></pre></td></tr></table>
</div>
</div><p>前面举这个例子的时候，提到有可能语句2会在语句1之前执行，那么久可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。</p>
<p>这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。</p>
<h5 id="volatile的原理和实现机制">volatile的原理和实现机制</h5>
<p>前面讲述了volatile关键字的一些使用，下面我们来探讨一下volatile到底如何保证可见性和禁止指令重排序的。</p>
<p>下面这段话摘自《深入理解Java虚拟机》：</p>
<p>“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个<strong>lock前缀指令</strong>”</p>
<p>lock前缀指令实际上相当于一个<strong>内存屏障</strong>（也成<strong>内存栅栏</strong>），内存屏障会提供3个功能：</p>
<ol>
<li>
<p>它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</p>
</li>
<li>
<p>它会强制将对缓存的修改操作立即写入主存；</p>
</li>
<li>
<p>如果是写操作，它会导致其他CPU中对应的缓存行无效。</p>
</li>
</ol>
<h5 id="使用volatile关键字的场景">使用volatile关键字的场景</h5>
<p>synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件：</p>
<ol>
<li>
<p>对变量的写操作不依赖于当前值</p>
</li>
<li>
<p>该变量没有包含在具有其他变量的不变式中</p>
</li>
</ol>
<p>实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。</p>
<p>事实上，我的理解就是上面的2个条件需要保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。</p>
<p>下面列举几个Java中使用volatile的几个场景。</p>
<p><strong>状态标记量</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">volatile</span> <span class="kt">boolean</span> <span class="n">flag</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
 
<span class="k">while</span><span class="o">(!</span><span class="n">flag</span><span class="o">){</span>
    <span class="n">doSomething</span><span class="o">();</span>
<span class="o">}</span>
 
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">setFlag</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">flag</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">volatile</span> <span class="kt">boolean</span> <span class="n">inited</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
<span class="c1">//线程1:
</span><span class="c1"></span><span class="n">context</span> <span class="o">=</span> <span class="n">loadContext</span><span class="o">();</span>  
<span class="n">inited</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
 
<span class="c1">//线程2:
</span><span class="c1"></span><span class="k">while</span><span class="o">(!</span><span class="n">inited</span> <span class="o">){</span>
  <span class="n">sleep</span><span class="o">()</span>
<span class="o">}</span>
<span class="n">doSomethingwithconfig</span><span class="o">(</span><span class="n">context</span><span class="o">);</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>double check</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Singleton</span><span class="o">{</span>
    <span class="kd">private</span> <span class="kd">volatile</span> <span class="kd">static</span> <span class="n">Singleton</span> <span class="n">instance</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
     
    <span class="kd">private</span> <span class="nf">Singleton</span><span class="o">()</span> <span class="o">{</span>
         
    <span class="o">}</span>
     
    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Singleton</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">instance</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="kd">synchronized</span> <span class="o">(</span><span class="n">Singleton</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span><span class="o">(</span><span class="n">instance</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span>
                    <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Singleton</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>至于为何需要这么写请参考：</p>
<ul>
<li>Java 中的双重检查（Double-Check）: <a href="http://blog.csdn.net/dl88250/article/details/5439024">http://blog.csdn.net/dl88250/article/details/5439024</a></li>
<li><a href="http://www.iteye.com/topic/652440">http://www.iteye.com/topic/652440</a></li>
</ul>
<h3 id="java中的可见性问题">Java中的可见性问题</h3>
<blockquote>
<p>参考：<br>
<a href="https://www.cnblogs.com/xidongyu/articles/12240022.html">https://www.cnblogs.com/xidongyu/articles/12240022.html</a></p>
</blockquote>
<h4 id="什么是java内存模型">什么是Java内存模型</h4>
<p>你已经知道，<strong>导致可见性的原因是缓存，导致有序性的原因是编译优化</strong>，那解决可见性、有序性最直接的办法就是<strong>禁用缓存和编译优化</strong>，但是这样问题虽然解决了，我们程序的性能可就堪忧了。</p>
<p>合理的方案应该是<strong>按需禁用缓存以及编译优化</strong>。那么，如何做到“按需禁用”呢？对于并发程序，何时禁用缓存以及编译优化只有程序员知道，那所谓“按需禁用”其实就是指按照程序员的要求来禁用。所以，为了解决可见性和有序性问题，只需要提供给程序员按需禁用缓存和编译优化的方法即可。</p>
<p><strong>Java 内存模型</strong>是个很复杂的规范，可以从不同的视角来解读，站在我们这些程序员的视角，本质上可以理解为，**Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。**具体来说，这些方法包括 <code>volatile</code>、<code>synchronized</code> 和 <code>final</code> 三个关键字，以及六项<code>Happens-Before 规则</code>，这也正是本期的重点内容。掌握这些方法，我们就可以按需地禁用缓存和编译优化了，也就掌握了Java内存模型最核心的东西。</p>
<h4 id="程序的顺序性">程序的顺序性</h4>
<p>在分析Happens-Before规则之前，一定要搞懂程序的顺序性。程序的顺序性指在编译器以及CPU优化情况下(<strong>编译器&amp;CPU优化会破坏程序执行顺序</strong>)，保证程序以单线程方式执行时，其结果的不变性。</p>
<p>举个例子，在单线中，下面的程序不论重复多少次(先执行writer后执行reader)，最后始终会输出42。这只对单线程程序而言，多线程程序(一个线程执行writer，另一个线程执行reader)中可能会输出0。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Example</span> <span class="o">{</span>

  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
  <span class="kt">boolean</span> <span class="n">v</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
  
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">writer</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">x</span> <span class="o">=</span> <span class="n">42</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">v</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">reader</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">v</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">print</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
        <span class="k">return</span><span class="o">;</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>程序的顺序性在任何CPU，任何编程语言中都需遵守的基本规则，因此Java语言或者说Java内存模型天然支持的。因此，Happens-Before规则其实应用于多线程场景，我们在编写多线程程序时一定要考虑到Happens-Before规则的使用。</p>
<h4 id="happens-before-规则">Happens-Before 规则</h4>
<p>如何理解 Happens-Before 呢？如果望文生义（很多网文也都爱按字面意思翻译成“先行发生”），那就南辕北辙了，Happens-Before 并不是说前面一个操作发生在后续操作的前面，它真正要表达的是：<strong>前面一个操作的结果对后续操作是可见的</strong>。</p>
<p>就像有心灵感应的两个人，虽然远隔千里，一个人心之所想，另一个人都看得到。Happens-Before 规则就是要保证线程之间的这种“心灵感应”。所以比较正式的说法是：Happens-Before 约束了编译器的优化行为，虽允许编译器优化，但是要求编译器优化后一定遵守 Happens-Before 规则。</p>
<p>Happens-Before 规则应该是 Java 内存模型里面最晦涩的内容了，和程序员相关的规则一共有如下七项，都是关于<strong>可见性</strong>的。</p>
<h5 id="volatile-变量规则">volatile 变量规则</h5>
<p>这条规则是指对一个 <code>volatile</code> 变量的写操作， Happens-Before 于后续对这个 volatile 变量的读操作，即<strong>被volatile修饰的变量写对读是可见的</strong>，确保线程在执行读操作时始终拿到的是新值。同时<strong>volatile禁止重排序功能</strong>，被volatile修饰的变量在进行读写时，这些变量是不能重排序；<strong>volatile变量前后的读写操作不能重排序</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">volatile</span> <span class="kt">int</span> <span class="n">a</span><span class="o">;</span>
<span class="kd">volatile</span> <span class="kt">int</span> <span class="n">b</span><span class="o">;</span>
<span class="kd">volatile</span> <span class="kt">int</span> <span class="n">c</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">d</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">e</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">f</span><span class="o">;</span>

<span class="c1">//(1)(2)(3)不能重排序
</span><span class="c1"></span><span class="n">a</span><span class="o">=</span><span class="n">10</span><span class="o">;</span>     <span class="o">(</span><span class="n">1</span><span class="o">)</span>
<span class="n">b</span><span class="o">=</span><span class="n">20</span><span class="o">;</span>     <span class="o">(</span><span class="n">2</span><span class="o">)</span>
<span class="n">c</span><span class="o">=</span><span class="n">30</span><span class="o">;</span>     <span class="o">(</span><span class="n">3</span><span class="o">)</span>

<span class="c1">//将(5)看成一堵障碍，其前后的操作不能跨越障碍
</span><span class="c1">//因此(4)不能滞后于(5)执行，(6)(7)不能先于(5执行)，但(6)(7)可以重排序执行
</span><span class="c1"></span><span class="n">d</span><span class="o">=</span><span class="n">40</span><span class="o">;</span>     <span class="o">(</span><span class="n">4</span><span class="o">)</span>
<span class="n">b</span><span class="o">=</span><span class="n">50</span><span class="o">;</span>     <span class="o">(</span><span class="n">5</span><span class="o">)</span>
<span class="n">e</span><span class="o">=</span><span class="n">60</span><span class="o">;</span>     <span class="o">(</span><span class="n">6</span><span class="o">)</span>
<span class="n">f</span><span class="o">=</span><span class="n">70</span><span class="o">;</span>     <span class="o">(</span><span class="n">7</span><span class="o">)</span>
</code></pre></td></tr></table>
</div>
</div><h5 id="传递性规则">传递性规则</h5>
<p>这条规则是指如果 A Happens-Before B，且 B Happens-Before C，那么 A Happens-Before C。</p>
<p>在解释传递性规则之前先修改开始出现的那段代码，用volatile修饰v变量</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Example</span> <span class="o">{</span>

  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
  <span class="kd">volatile</span> <span class="kt">boolean</span> <span class="n">v</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
  
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">writer</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">x</span> <span class="o">=</span> <span class="n">42</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">v</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">reader</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">v</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">print</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
        <span class="k">return</span><span class="o">;</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>示例代码中的传递性规则</p>
<p>从图中，我们可以看到：</p>
<p>“x=42” Happens-Before 写变量 “v=true” ，这是volatile规则的内容；</p>
<p>写变量“v=true” Happens-Before 读变量 “v=true”，这是volatile规则的内容 。</p>
<p>再根据这个传递性规则，我们得到结果：“x=42” Happens-Before 读变量“v=true”。这意味着什么呢？</p>
<p>如果线程 B 读到了“v=true”，那么线程 A 设置的“x=42”对线程 B 是可见的。也就是说，线程 B 能看到 “x == 42”</p>
<h5 id="管程中锁的规则">管程中锁的规则</h5>
<p>这条规则是指对一个锁的解锁 Happens-Before 于后续对这个锁的加锁，且被锁保护的共享资源在进行写操作时对其他线程可见。</p>
<p>要理解这个规则，就首先要了解“管程指的是什么”。<strong>管程</strong>是一种通用的同步原语，在 Java 中指的就是 synchronized，<strong>synchronized 是 Java 里对管程的实现</strong>。</p>
<p>管程中的锁在 Java 里是隐式实现的，例如下面的代码，在进入同步块之前，会自动加锁，而在代码块执行完会自动释放锁，加锁以及释放锁都是编译器帮我们实现的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span> <span class="c1">//此处自动加锁
</span><span class="c1"></span>  <span class="c1">// x是共享变量,初始值=10
</span><span class="c1"></span>  <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">x</span> <span class="o">&lt;</span> <span class="n">12</span><span class="o">)</span> <span class="o">{</span>
  	<span class="k">this</span><span class="o">.</span><span class="na">x</span> <span class="o">=</span> <span class="n">12</span><span class="o">;</span> 
  <span class="o">}</span>  
<span class="o">}</span> <span class="c1">//此处自动解锁
</span></code></pre></td></tr></table>
</div>
</div><p>所以结合规则 4 &mdash; 管程中锁的规则，可以这样理解：假设 x 的初始值是 10，线程 A 执行完代码块后 x 的值会变成 12（执行完自动释放锁），线程 B 进入代码块时，能够看到线程 A 对 x 的写操作，也就是线程 B 能够看到 x==12。</p>
<h5 id="线程-start-规则">线程 start() 规则</h5>
<p>这条是关于线程启动的。它是指主线程 A 启动子线程 B 后，子线程 B 能够看到主线程在启动子线程 B 前的操作。</p>
<p>换句话说就是，如果线程 A 调用线程 B 的 start() 方法（即在线程 A 中启动线程 B），那么该 start() 操作 Happens-Before 于线程 B 中的任意操作。具体可参考下面示例代码。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Thread</span> <span class="n">B</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(()-&gt;{</span>
  <span class="c1">// 主线程调用B.start()之前
</span><span class="c1"></span>  <span class="c1">// 所有对共享变量的修改，此处皆可见
</span><span class="c1"></span>  <span class="c1">// 此例中，var==77
</span><span class="c1"></span>
<span class="o">});</span>

<span class="c1">// 此处对共享变量var修改
</span><span class="c1"></span><span class="n">var</span> <span class="o">=</span> <span class="n">77</span><span class="o">;</span>

<span class="c1">// 主线程启动子线程
</span><span class="c1"></span><span class="n">B</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
</code></pre></td></tr></table>
</div>
</div><h5 id="线程-join-规则">线程 join() 规则</h5>
<p>这条是关于线程等待的。它是指主线程 A 等待子线程 B 完成（主线程 A 通过调用子线程 B 的 join() 方法实现），当子线程 B 完成后（主线程 A 中 join() 方法返回），主线程能够看到子线程的操作。当然所谓的“看到”，指的是对共享变量的操作。</p>
<p>换句话说就是，如果在线程 A 中，调用线程 B 的 join() 并成功返回，那么线程 B 中的任意操作 Happens-Before 于该 join() 操作的返回。具体可参考下面示例代码。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Thread</span> <span class="n">B</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(()-&gt;{</span>

  <span class="c1">// 此处对共享变量var修改
</span><span class="c1"></span>  <span class="n">var</span> <span class="o">=</span> <span class="n">66</span><span class="o">;</span>

<span class="o">});</span>

<span class="c1">// 例如此处对共享变量修改，
</span><span class="c1">// 则这个修改结果对线程B可见
</span><span class="c1">// 主线程启动子线程
</span><span class="c1"></span>
<span class="n">B</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>

<span class="n">B</span><span class="o">.</span><span class="na">join</span><span class="o">()</span>

<span class="c1">// 子线程所有对共享变量的修改
</span><span class="c1">// 在主线程调用B.join()之后皆可见
</span><span class="c1">// 此例中，var==66
</span></code></pre></td></tr></table>
</div>
</div><h5 id="线程中断规则">线程中断规则</h5>
<p>对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">//线程A此处对共享变量var修改
</span><span class="c1"></span><span class="n">var</span> <span class="o">=</span> <span class="n">66</span>

<span class="c1">//中断线程B
</span><span class="c1"></span><span class="n">B</span><span class="o">.</span><span class="na">interrupt</span><span class="o">()</span>
</code></pre></td></tr></table>
</div>
</div><p>线程B被中断后，线程B看到共享变量var的值应为66</p>
<h5 id="final-规则">final 规则</h5>
<p>前面我们讲 volatile 为的是禁用缓存以及编译优化，我们再从另外一个方面来看，有没有办法告诉编译器优化得更好一点呢？这个可以有，就是 final 关键字。</p>
<p>final 修饰变量时，初衷是告诉编译器：这个变量生而不变，可以可劲儿优化。Java 编译器在 1.5 以前的版本的确优化得很努力，以至于都优化错了。但是final使用不当会导致对象“逸出”。</p>
<p>“逸出”有点抽象，我们还是举个例子吧，在下面例子中，在构造函数里面将 this 赋值给了全局变量 global.obj，这就是“逸出”，线程通过 global.obj 读取 x 是有可能读到 0 的。因此我们一定要避免“逸出”。</p>
<p>因此在编程时最好不要在构造函数中把this赋值给一个全局变量。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">final</span> <span class="kt">int</span> <span class="n">x</span><span class="o">;</span>

<span class="c1">// 错误的构造函数
</span><span class="c1"></span><span class="kd">public</span> <span class="nf">FinalFieldExample</span><span class="o">()</span> <span class="o">{</span> 
  <span class="n">x</span> <span class="o">=</span> <span class="n">3</span><span class="o">;</span>
  <span class="n">y</span> <span class="o">=</span> <span class="n">4</span><span class="o">;</span>
  <span class="c1">// 此处就是讲this逸出，
</span><span class="c1"></span>  <span class="n">global</span><span class="o">.</span><span class="na">obj</span> <span class="o">=</span> <span class="k">this</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h5 id="总结">总结</h5>
<p>Java 的内存模型是并发编程领域的一次重要创新，之后 C++、C#、Golang 等高级语言都开始支持内存模型。Java 内存模型里面，最晦涩的部分就是 Happens-Before 规则了，Happens-Before 规则最初是在一篇叫做 Time, Clocks, and the Ordering of Events in a Distributed System 的论文中提出来的，在这篇论文中，Happens-Before 的语义是一种因果关系。在现实世界里，如果 A 事件是导致 B 事件的起因，那么 A 事件一定是先于（Happens-Before）B 事件发生的，这个就是 Happens-Before 语义的现实理解。</p>
<p>在 Java 语言里面，Happens-Before 的语义本质上是一种可见性，A Happens-Before B 意味着 A 事件对 B 事件来说是可见的，无论 A 事件和 B 事件是否发生在同一个线程里。例如 A 事件发生在线程 1 上，B 事件发生在线程 2 上，Happens-Before 规则保证线程 2 上也能看到 A 事件的发生。</p>
<p>Java 内存模型主要分为两部分，一部分面向你我这种编写并发程序的应用开发人员，另一部分是面向 JVM 的实现人员的，我们可以重点关注前者，也就是和编写并发程序相关的部分，这部分内容的核心就是 Happens-Before 规则。相信经过本章的介绍，你应该对这部分内容已经有了深入的认识。</p>
<blockquote>
<p>参考：<br>
<a href="https://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf">https://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf</a><br>
<a href="http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html#finalWrong">http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html#finalWrong</a></p>
</blockquote>
<h2 id="cas">CAS</h2>
<blockquote>
<p>参考：<br>
<a href="https://cloud.tencent.com/developer/article/1462258">https://cloud.tencent.com/developer/article/1462258</a></p>
</blockquote>
<p>在JDK 5之前Java语言是靠synchronized关键字保证同步的，这会导致有锁</p>
<p>锁机制存在以下问题：</p>
<ul>
<li>在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题。</li>
<li>一个线程持有锁会导致其它所有需要此锁的线程挂起。</li>
<li>如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险。</li>
</ul>
<p>volatile是不错的机制，但是volatile不能保证原子性。因此对于同步最终还是要回到锁机制上来。</p>
<p><strong>独占锁</strong>是一种<strong>悲观锁</strong>，<code>synchronized</code> 就是一种独占锁，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。而另一个更加有效的锁就是<strong>乐观锁</strong>。所谓乐观锁就是，<strong>每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止</strong>。乐观锁用到的机制就是<strong>CAS</strong>，Compare and Swap。</p>
<p>CAS, compare and swap的缩写，中文翻译成<strong>比较并交换</strong>。</p>
<p>在计算机科学中，比较和交换（Conmpare And Swap）是用于实现多线程同步的<strong>原子指令</strong>。它将内存位置的内容与给定值进行比较，只有在相同的情况下，将该内存位置的内容修改为新的给定值。这是作为单个<strong>原子操作</strong>完成的。</p>
<p>原子性保证新值基于最新信息计算; 如果该值在同一时间被另一个线程更新，则写入将失败。操作结果必须说明是否进行替换; 这可以通过一个简单的布尔响应（这个变体通常称为比较和设置），或通过返回从内存位置读取的值来完成。</p>
<p>CAS 操作包含三个操作数： <strong>内存位置（V）</strong>、<strong>预期原值（A）<strong>和</strong>新值(B)</strong>。 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。</p>
<p>操作步骤如下：</p>
<ul>
<li>比较 A 与 V 是否相等。（比较）</li>
<li>如果比较相等，将 B 写入 V。（交换）</li>
<li>返回操作是否成功。</li>
<li>当多个线程同时对某个资源进行CAS操作，只能有一个线程操作成功，但是并不会阻塞其他线程,其他线程只会收到操作失败的信号。可见 <strong>CAS 其实是一个乐观锁</strong>。</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/images/20210223-CAS%e5%9b%be%e8%a7%a3.png"
        data-srcset="/images/20210223-CAS%e5%9b%be%e8%a7%a3.png, /images/20210223-CAS%e5%9b%be%e8%a7%a3.png 1.5x, /images/20210223-CAS%e5%9b%be%e8%a7%a3.png 2x"
        data-sizes="auto"
        alt="/images/20210223-CAS图解.png"
        title="CAS图解" /></p>
<p>如上图中，主存中保存V值，线程中要使用V值要先从主存中读取V值到线程的工作内存A中，然后计算后变成B值，最后再把B值写回到内存V值中。多个线程共用V值都是如此操作。CAS的核心是在将B值写入到V之前要比较A值和V值是否相同，如果不相同证明此时V值已经被其他线程改变，重新将V值赋给A，并重新计算得到B，如果相同，则将B值赋给V。</p>
<p><strong>如果不使用CAS机制，看看存在什么问题:</strong></p>
<p>假如V=1，现在Thread1要对V进行加1，Thread2也要对V进行加1，首先Thread1读取V=1到自己工作内存A中此时A=1，假设Thread2此时也读取V=1到自己的工作内存A中，分别进行加1操作后，两个线程中B的值都为2，此时写回到V中时发现V的值为2，但是两个线程分别对V进行加处理结果却只加了1有问题。</p>
<h3 id="cas-实现">CAS 实现</h3>
<p>本文将对 java.util.concurrent.atomic 包下的原子类 AtomicInteger 中的 compareAndSet 方法进行分析，就能发现最终调用的是 sum.misc.Unsafe 这个类。</p>
<p>看名称 Unsafe 就是一个不安全的类，这个类是利用了 Java 的类和包在可见性的的规则中的一个恰到好处的漏洞。Unsafe 这个类为了速度，在Java的安全标准上做出了一定的妥协。</p>
<p>再往下寻找我们发现 Unsafe的compareAndSwapInt 是 Native 的方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">final</span> <span class="kd">native</span> <span class="kt">boolean</span> <span class="nf">compareAndSwapInt</span><span class="o">(</span><span class="n">Object</span> <span class="n">var1</span><span class="o">,</span> <span class="kt">long</span> <span class="n">var2</span><span class="o">,</span> <span class="kt">int</span> <span class="n">var4</span><span class="o">,</span> <span class="kt">int</span> <span class="n">var5</span><span class="o">);</span>
</code></pre></td></tr></table>
</div>
</div><p>也就是说，这几个 CAS 的方法应该是使用了本地的方法。所以这几个方法的具体实现需要我们自己去 jdk 的源码中搜索。</p>
<p>最终到搜索 <code>cmpxchg</code> 函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kr">inline</span> <span class="n">jint</span> <span class="n">Atomic</span><span class="o">::</span><span class="n">cmpxchg</span> <span class="p">(</span><span class="n">jint</span> <span class="n">exchange_value</span><span class="p">,</span> <span class="k">volatile</span> <span class="n">jint</span><span class="o">*</span> <span class="n">dest</span><span class="p">,</span> <span class="n">jint</span> <span class="n">compare_value</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 判断是否是多核 CPU
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">mp</span> <span class="o">=</span> <span class="n">os</span><span class="o">::</span><span class="n">is_MP</span><span class="p">();</span>
  <span class="kr">__asm</span> <span class="p">{</span>    <span class="c1">// 将参数值放入寄存器中
</span><span class="c1"></span>    <span class="n">mov</span> <span class="n">edx</span><span class="p">,</span> <span class="n">dest</span>    <span class="c1">// 注意: dest 是指针类型，这里是把内存地址存入 edx 寄存器中
</span><span class="c1"></span>    <span class="n">mov</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">exchange_value</span>
    <span class="n">mov</span> <span class="n">eax</span><span class="p">,</span> <span class="n">compare_value</span>    
    <span class="c1">// LOCK_IF_MP
</span><span class="c1"></span>    <span class="n">cmp</span> <span class="n">mp</span><span class="p">,</span> <span class="mi">0</span>
    <span class="cm">/*
</span><span class="cm">     * 如果 mp = 0，表明是线程运行在单核 CPU 环境下。此时 je 会跳转到 L0 标记处，
</span><span class="cm">     * 也就是越过 _emit 0xF0 指令，直接执行 cmpxchg 指令。也就是不在下面的 cmpxchg 指令
</span><span class="cm">     * 前加 lock 前缀。
</span><span class="cm">     */</span>
    <span class="n">je</span> <span class="n">L0</span>    <span class="cm">/*
</span><span class="cm">     * 0xF0 是 lock 前缀的机器码，这里没有使用 lock，而是直接使用了机器码的形式。至于这样做的
</span><span class="cm">     * 原因可以参考知乎的一个回答：
</span><span class="cm">     *     https://www.zhihu.com/question/50878124/answer/123099923
</span><span class="cm">     */</span> 
    <span class="n">_emit</span> <span class="mh">0xF0L</span><span class="mi">0</span><span class="o">:</span>    <span class="cm">/*
</span><span class="cm">     * 比较并交换。简单解释一下下面这条指令，熟悉汇编的朋友可以略过下面的解释:
</span><span class="cm">     *   cmpxchg: 即“比较并交换”指令
</span><span class="cm">     *   dword: 全称是 double word，在 x86/x64 体系中，一个 
</span><span class="cm">     *          word = 2 byte，dword = 4 byte = 32 bit
</span><span class="cm">     *   ptr: 全称是 pointer，与前面的 dword 连起来使用，表明访问的内存单元是一个双字单元
</span><span class="cm">     *   [edx]: [...] 表示一个内存单元，edx 是寄存器，dest 指针值存放在 edx 中。
</span><span class="cm">     *          那么 [edx] 表示内存地址为 dest 的内存单元
</span><span class="cm">     *          
</span><span class="cm">     * 这一条指令的意思就是，将 eax 寄存器中的值（compare_value）与 [edx] 双字内存单元中的值
</span><span class="cm">     * 进行对比，如果相同，则将 ecx 寄存器中的值（exchange_value）存入 [edx] 内存单元中。
</span><span class="cm">     */</span>
    <span class="n">cmpxchg</span> <span class="n">dword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">edx</span><span class="p">],</span> <span class="n">ecx</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>总结一下 JAVA 的 cas 是怎么实现的：</p>
<ul>
<li>java 的 cas 利用的的是 unsafe 这个类提供的 cas 操作。</li>
<li>unsafe 的cas 依赖了的是 jvm 针对不同的操作系统实现的 Atomic::cmpxchg</li>
<li>Atomic::cmpxchg 的实现使用了汇编的 cas 操作，并使用 cpu 硬件提供的 lock信号保证其原子性</li>
</ul>
<h3 id="aba问题">ABA问题</h3>
<p>CAS 由三个步骤组成，分别是“读取-&gt;比较-&gt;写回”。</p>
<p>考虑这样一种情况，线程1和线程2同时执行 CAS 逻辑，两个线程的执行顺序如下：</p>
<ul>
<li>时刻1：线程1执行读取操作，获取原值 A，然后线程被切换走</li>
<li>时刻2：线程2执行完成 CAS 操作将原值由 A 修改为 B</li>
<li>时刻3：线程2再次执行 CAS 操作，并将原值由 B 修改为 A</li>
<li>时刻4：线程1恢复运行，将比较值（compareValue）与原值（oldValue）进行比较，发现两个值相等。</li>
<li>然后用新值（newValue）写入内存中，完成 CAS 操作</li>
</ul>
<p>如上流程，线程1并不知道原值已经被修改过了，在它看来并没什么变化，所以它会继续往下执行流程。</p>
<p>对于 ABA 问题，通常的处理措施是对每一次 CAS 操作设置版本号。java.util.concurrent.atomic 包下提供了一个可处理 ABA 问题的原子类 AtomicStampedReference，具体的实现这里就不分析了，有兴趣的朋友可以自己去看看。</p>
<p>ABA问题的解决办法</p>
<ul>
<li>在变量前面追加版本号：每次变量更新就把版本号加1，则A-B-A就变成1A-2B-3A。</li>
<li>atomic包下的AtomicStampedReference类：其compareAndSet方法首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用的该标志的值设置为给定的更新值。</li>
</ul>
<h3 id="其他问题">其他问题</h3>
<p>CAS除了ABA问题，仍然存在循环时间长开销大和只能保证一个共享变量的原子操作</p>
<ol>
<li>
<p>循环时间长开销大</p>
<p>自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。</p>
<p>如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。</p>
</li>
<li>
<p>只能保证一个共享变量的原子操作</p>
<p>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。</p>
<p>比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。</p>
</li>
</ol>
<h3 id="cas-的应用">CAS 的应用</h3>
<ul>
<li>Java的concurrent包下就有很多类似的实现类，如Atomic开头那些。</li>
<li>自旋锁</li>
<li>令牌桶限流器</li>
</ul>
<p><strong>令牌桶限流器</strong>：就是系统以恒定的速度向桶内增加令牌。每次请求前从令牌桶里面获取令牌。如果获取到令牌就才可以进行访问。当令牌桶内没有令牌的时候，拒绝提供服务。我们来看看 eureka 的限流器是如何使用 CAS 来维护多线程环境下对 token 的增加和分发的。</p>
<h2 id="线程池">线程池</h2>
<p>线程池是java并发最重要的一个知识点，也是难点，是实际应用最广泛的。</p>
<p>线程的资源很宝贵，不可能无限的创建，必须要有管理线程的工具，线程池就是一种管理线程的工具，java开发中经常有池化的思想，如 数据库连接池、Redis连接池等。</p>
<p>预先创建好一些线程，任务提交时直接执行，既可以节约创建线程的时间，又可以控制线程的数量。</p>
<p><strong>线程池的好处</strong></p>
<ul>
<li>降低资源消耗，通过池化思想，减少创建线程和销毁线程的消耗，控制资源</li>
<li>提高响应速度，任务到达时，无需创建线程即可运行</li>
<li>提供更多更强大的功能，可扩展性高</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/images/20210223-%e7%ba%bf%e7%a8%8b%e6%b1%a0%e7%b1%bb%e5%9b%be.png"
        data-srcset="/images/20210223-%e7%ba%bf%e7%a8%8b%e6%b1%a0%e7%b1%bb%e5%9b%be.png, /images/20210223-%e7%ba%bf%e7%a8%8b%e6%b1%a0%e7%b1%bb%e5%9b%be.png 1.5x, /images/20210223-%e7%ba%bf%e7%a8%8b%e6%b1%a0%e7%b1%bb%e5%9b%be.png 2x"
        data-sizes="auto"
        alt="/images/20210223-线程池类图.png"
        title="线程池类图" /></p>
<h3 id="线程池的构造方法">线程池的构造方法</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="nf">ThreadPoolExecutor</span><span class="o">(</span><span class="kt">int</span> <span class="n">corePoolSize</span><span class="o">,</span>
                          <span class="kt">int</span> <span class="n">maximumPoolSize</span><span class="o">,</span>
                          <span class="kt">long</span> <span class="n">keepAliveTime</span><span class="o">,</span>
                          <span class="n">TimeUnit</span> <span class="n">unit</span><span class="o">,</span>
                          <span class="n">BlockingQueue</span><span class="o">&lt;</span><span class="n">Runnable</span><span class="o">&gt;</span> <span class="n">workQueue</span><span class="o">,</span>
                          <span class="n">ThreadFactory</span> <span class="n">threadFactory</span><span class="o">,</span>
                          <span class="n">RejectedExecutionHandler</span> <span class="n">handler</span><span class="o">)</span> <span class="o">{</span>
 
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>corePoolSize: 核心线程数</li>
<li>maximumPoolSize: 最大线程数</li>
<li>keepAliveTime: 救急线程的空闲时间</li>
<li>unit: 救急线程的空闲时间单位</li>
<li>workQueue: 阻塞队列</li>
<li>threadFactory: 创建线程的工厂，主要定义线程名</li>
<li>handler: 拒绝策略</li>
</ul>
<h3 id="线程池案例">线程池案例</h3>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/images/20210223-%e7%ba%bf%e7%a8%8b%e6%b1%a0%e6%a1%88%e4%be%8b.png"
        data-srcset="/images/20210223-%e7%ba%bf%e7%a8%8b%e6%b1%a0%e6%a1%88%e4%be%8b.png, /images/20210223-%e7%ba%bf%e7%a8%8b%e6%b1%a0%e6%a1%88%e4%be%8b.png 1.5x, /images/20210223-%e7%ba%bf%e7%a8%8b%e6%b1%a0%e6%a1%88%e4%be%8b.png 2x"
        data-sizes="auto"
        alt="/images/20210223-线程池案例.png"
        title="线程池案例" /></p>
<p>如上图 银行办理业务。</p>
<ul>
<li>客户到银行时，开启柜台进行办理，柜台相当于线程，客户相当于任务，有两个是常开的柜台，三个是临时柜台。2就是核心线程数，5是最大线程数。即有两个核心线程</li>
<li>当柜台开到第二个后，都还在处理业务。客户再来就到排队大厅排队。排队大厅只有三个座位。</li>
<li>排队大厅坐满时，再来客户就继续开柜台处理，目前最大有三个临时柜台，也就是三个救急线程</li>
<li>此时再来客户，就无法正常为其 提供业务，采用拒绝策略来处理它们</li>
<li>当柜台处理完业务，就会从排队大厅取任务，当柜台隔一段空闲时间都取不到任务时，如果当前线程数大于核心线程数时，就会回收线程。即撤销该柜台。</li>
</ul>
<h3 id="线程池的状态">线程池的状态</h3>
<p>线程池通过一个int变量的高3位来表示线程池的状态，低29位来存储线程池的数量</p>
<p>状态名称 | 高三位 | 接收新任务 | 处理阻塞队列任务 | 说明
Running | 111 | Y | Y | 正常接收任务，正常处理任务
Shutdown | 000 | N | Y | 不会接收任务,会执行完正在执行的任务,也会处理阻塞队列里的任务
Stop | 001 | N | N | 不会接收任务，会中断正在执行的任务,会放弃处理阻塞队列里的任务
Tidying | 010 | N | N | 任务全部执行完毕，当前活动线程是0，即将进入终结
Termitted | 011 | N | N | 终结状态</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// runState is stored in the high-order bits
</span><span class="c1"></span><span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">RUNNING</span>    <span class="o">=</span> <span class="o">-</span><span class="n">1</span> <span class="o">&lt;&lt;</span> <span class="n">COUNT_BITS</span><span class="o">;</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">SHUTDOWN</span>   <span class="o">=</span>  <span class="n">0</span> <span class="o">&lt;&lt;</span> <span class="n">COUNT_BITS</span><span class="o">;</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">STOP</span>       <span class="o">=</span>  <span class="n">1</span> <span class="o">&lt;&lt;</span> <span class="n">COUNT_BITS</span><span class="o">;</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">TIDYING</span>    <span class="o">=</span>  <span class="n">2</span> <span class="o">&lt;&lt;</span> <span class="n">COUNT_BITS</span><span class="o">;</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">TERMINATED</span> <span class="o">=</span>  <span class="n">3</span> <span class="o">&lt;&lt;</span> <span class="n">COUNT_BITS</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="线程池的主要流程">线程池的主要流程</h3>
<p><strong>线程池创建、接收任务、执行任务、回收线程的步骤</strong></p>
<ul>
<li>创建线程池后，线程池的状态是Running，该状态下才能有下面的步骤</li>
<li>提交任务时，线程池会创建线程去处理任务</li>
<li>当线程池的工作线程数达到corePoolSize时，继续提交任务会进入阻塞队列</li>
<li>当阻塞队列装满时，继续提交任务，会创建救急线程来处理</li>
<li>当线程池中的工作线程数达到maximumPoolSize时，会执行拒绝策略</li>
<li>当线程取任务的时间达到keepAliveTime还没有取到任务，工作线程数大于corePoolSize时，会回收该线程</li>
</ul>
<p>注意： 不是刚创建的线程是核心线程，后面创建的线程是非核心线程，线程是没有核心非核心的概念的，这是我长期以来的误解。</p>
<p><strong>拒绝策略</strong></p>
<ul>
<li>调用者抛出RejectedExecutionException (默认策略)</li>
<li>让调用者运行任务</li>
<li>丢弃此次任务</li>
<li>丢弃阻塞队列中最早的任务，加入该任务</li>
</ul>
<p><strong>提交任务的方法</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 执行Runnable
</span><span class="c1"></span><span class="kd">public</span> <span class="kt">void</span> <span class="nf">execute</span><span class="o">(</span><span class="n">Runnable</span> <span class="n">command</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">command</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">NullPointerException</span><span class="o">();</span>
    <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">workerCountOf</span><span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">corePoolSize</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">addWorker</span><span class="o">(</span><span class="n">command</span><span class="o">,</span> <span class="kc">true</span><span class="o">))</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">isRunning</span><span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">workQueue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">command</span><span class="o">))</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">recheck</span> <span class="o">=</span> <span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(!</span> <span class="n">isRunning</span><span class="o">(</span><span class="n">recheck</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">remove</span><span class="o">(</span><span class="n">command</span><span class="o">))</span>
            <span class="n">reject</span><span class="o">(</span><span class="n">command</span><span class="o">);</span>
        <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">workerCountOf</span><span class="o">(</span><span class="n">recheck</span><span class="o">)</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span>
            <span class="n">addWorker</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="o">(!</span><span class="n">addWorker</span><span class="o">(</span><span class="n">command</span><span class="o">,</span> <span class="kc">false</span><span class="o">))</span>
        <span class="n">reject</span><span class="o">(</span><span class="n">command</span><span class="o">);</span>
<span class="o">}</span>
<span class="c1">// 提交Callable
</span><span class="c1"></span><span class="kd">public</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Future</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">submit</span><span class="o">(</span><span class="n">Callable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">task</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">task</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">NullPointerException</span><span class="o">();</span>
   <span class="c1">// 内部构建FutureTask
</span><span class="c1"></span>  <span class="n">RunnableFuture</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">ftask</span> <span class="o">=</span> <span class="n">newTaskFor</span><span class="o">(</span><span class="n">task</span><span class="o">);</span>
  <span class="n">execute</span><span class="o">(</span><span class="n">ftask</span><span class="o">);</span>
  <span class="k">return</span> <span class="n">ftask</span><span class="o">;</span>
<span class="o">}</span>
<span class="c1">// 提交Runnable,指定返回值
</span><span class="c1"></span><span class="kd">public</span> <span class="n">Future</span><span class="o">&lt;?&gt;</span> <span class="n">submit</span><span class="o">(</span><span class="n">Runnable</span> <span class="n">task</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">task</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">NullPointerException</span><span class="o">();</span>
  <span class="c1">// 内部构建FutureTask
</span><span class="c1"></span>  <span class="n">RunnableFuture</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">&gt;</span> <span class="n">ftask</span> <span class="o">=</span> <span class="n">newTaskFor</span><span class="o">(</span><span class="n">task</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
  <span class="n">execute</span><span class="o">(</span><span class="n">ftask</span><span class="o">);</span>
  <span class="k">return</span> <span class="n">ftask</span><span class="o">;</span>
<span class="o">}</span> 
<span class="c1">//  提交Runnable,指定返回值
</span><span class="c1"></span><span class="kd">public</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Future</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">submit</span><span class="o">(</span><span class="n">Runnable</span> <span class="n">task</span><span class="o">,</span> <span class="n">T</span> <span class="n">result</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">task</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">NullPointerException</span><span class="o">();</span>
   <span class="c1">// 内部构建FutureTask
</span><span class="c1"></span>  <span class="n">RunnableFuture</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">ftask</span> <span class="o">=</span> <span class="n">newTaskFor</span><span class="o">(</span><span class="n">task</span><span class="o">,</span> <span class="n">result</span><span class="o">);</span>
  <span class="n">execute</span><span class="o">(</span><span class="n">ftask</span><span class="o">);</span>
  <span class="k">return</span> <span class="n">ftask</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">protected</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">RunnableFuture</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">newTaskFor</span><span class="o">(</span><span class="n">Runnable</span> <span class="n">runnable</span><span class="o">,</span> <span class="n">T</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">FutureTask</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;(</span><span class="n">runnable</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="execetors创建线程池">Execetors创建线程池</h3>
<p>注意： 下面几种方式都不推荐使用</p>
<ol>
<li>
<p>newFixedThreadPool</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="n">ExecutorService</span> <span class="nf">newFixedThreadPool</span><span class="o">(</span><span class="kt">int</span> <span class="n">nThreads</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">ThreadPoolExecutor</span><span class="o">(</span><span class="n">nThreads</span><span class="o">,</span> <span class="n">nThreads</span><span class="o">,</span>
                                  <span class="n">0L</span><span class="o">,</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">,</span>
                                  <span class="k">new</span> <span class="n">LinkedBlockingQueue</span><span class="o">&lt;</span><span class="n">Runnable</span><span class="o">&gt;());</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>核心线程数 = 最大线程数 （没有救急线程）</li>
<li>阻塞队列无界 可能导致oom</li>
</ul>
</li>
<li>
<p>newCachedThreadPool</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="n">ExecutorService</span> <span class="nf">newCachedThreadPool</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">ThreadPoolExecutor</span><span class="o">(</span><span class="n">0</span><span class="o">,</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">,</span>
                                  <span class="n">60L</span><span class="o">,</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">,</span>
                                  <span class="k">new</span> <span class="n">SynchronousQueue</span><span class="o">&lt;</span><span class="n">Runnable</span><span class="o">&gt;());</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>核心线程数是0，最大线程数无限制 ，救急线程60秒回收</li>
<li>队列采用 SynchronousQueue 实现 没有容量，即放入队列后没有线程来取就放不进去</li>
<li>可能导致线程数过多，cpu负担太大</li>
</ul>
</li>
<li>
<p>newSingleThreadExecutor</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="n">ExecutorService</span> <span class="nf">newSingleThreadExecutor</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">FinalizableDelegatedExecutorService</span>
        <span class="o">(</span><span class="k">new</span> <span class="n">ThreadPoolExecutor</span><span class="o">(</span><span class="n">1</span><span class="o">,</span> <span class="n">1</span><span class="o">,</span>
                                <span class="n">0L</span><span class="o">,</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">,</span>
                                <span class="k">new</span> <span class="n">LinkedBlockingQueue</span><span class="o">&lt;</span><span class="n">Runnable</span><span class="o">&gt;()));</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>核心线程数和最大线程数都是1，没有救急线程，无界队列 可以不停的接收任务</li>
<li>将任务串行化 一个个执行， 使用包装类是为了屏蔽修改线程池的一些参数 比如 corePoolSize</li>
<li>如果某线程抛出异常了，会重新创建一个线程继续执行</li>
<li>可能造成oom</li>
</ul>
</li>
<li>
<p>newScheduledThreadPool</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="n">ScheduledExecutorService</span> <span class="nf">newScheduledThreadPool</span><span class="o">(</span><span class="kt">int</span> <span class="n">corePoolSize</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">ScheduledThreadPoolExecutor</span><span class="o">(</span><span class="n">corePoolSize</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>任务调度的线程池 可以指定延迟时间调用，可以指定隔一段时间调用</li>
</ul>
</li>
</ol>
<h3 id="线程池的关闭">线程池的关闭</h3>
<p><strong>shutdown()</strong>：会让线程池状态为shutdown，不能接收任务，但是会将工作线程和阻塞队列里的任务执行完 相当于优雅关闭</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">shutdown</span><span class="o">()</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="n">ReentrantLock</span> <span class="n">mainLock</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">mainLock</span><span class="o">;</span>
    <span class="n">mainLock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="n">checkShutdownAccess</span><span class="o">();</span>
        <span class="n">advanceRunState</span><span class="o">(</span><span class="n">SHUTDOWN</span><span class="o">);</span>
        <span class="n">interruptIdleWorkers</span><span class="o">();</span>
        <span class="n">onShutdown</span><span class="o">();</span> <span class="c1">// hook for ScheduledThreadPoolExecutor
</span><span class="c1"></span>    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="n">mainLock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="n">tryTerminate</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>shutdownNow()</strong>：会让线程池状态为stop， 不能接收任务，会立即中断执行中的工作线程，并且不会执行阻塞队列里的任务， 会返回阻塞队列的任务列表</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Runnable</span><span class="o">&gt;</span> <span class="nf">shutdownNow</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">Runnable</span><span class="o">&gt;</span> <span class="n">tasks</span><span class="o">;</span>
    <span class="kd">final</span> <span class="n">ReentrantLock</span> <span class="n">mainLock</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">mainLock</span><span class="o">;</span>
    <span class="n">mainLock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="n">checkShutdownAccess</span><span class="o">();</span>
        <span class="n">advanceRunState</span><span class="o">(</span><span class="n">STOP</span><span class="o">);</span>
        <span class="n">interruptWorkers</span><span class="o">();</span>
        <span class="n">tasks</span> <span class="o">=</span> <span class="n">drainQueue</span><span class="o">();</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="n">mainLock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="n">tryTerminate</span><span class="o">();</span>
    <span class="k">return</span> <span class="n">tasks</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="线程池使用的正确姿势">线程池使用的正确姿势</h3>
<p>线程池难就难在参数的配置，有一套理论配置参数</p>
<p>cpu密集型 : 指的是程序主要发生cpu的运算</p>
<ul>
<li>核心线程数： CPU核心数+1</li>
</ul>
<p>IO密集型: 远程调用RPC，操作数据库等，不需要使用cpu进行大量的运算。 大多数应用的场景</p>
<ul>
<li>核心线程数=核数*cpu期望利用率 *总时间/cpu运算时间</li>
</ul>
<p>但是基于以上理论还是很难去配置，因为cpu运算时间不好估算</p>
<p>实际配置大小可参考下表</p>
<table>
<thead>
<tr>
<th>~</th>
<th>cpu密集型</th>
<th>io密集型</th>
</tr>
</thead>
<tbody>
<tr>
<td>线程数数量</td>
<td>核数&lt;=x&lt;=核数*2</td>
<td>核心数*50&lt;=x&lt;=核心数 *100</td>
</tr>
<tr>
<td>队列长度</td>
<td>y&gt;=100</td>
<td>1&lt;=y&lt;=10</td>
</tr>
</tbody>
</table>
<ol>
<li>
<p>线程池参数通过分布式配置（比如apollo, nacos），修改配置无需重启应用</p>
<p>线程池参数是根据线上的请求数变化而变化的，最好的方式是 核心线程数、最大线程数 队列大小都是可配置的</p>
<p>主要配置 corePoolSize maxPoolSize queueSize</p>
<p>java提供了可方法覆盖参数，线程池内部会处理好参数 进行平滑的修改</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">setCorePoolSize</span><span class="o">(</span><span class="kt">int</span> <span class="n">corePoolSize</span><span class="o">)</span> <span class="o">{</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/images/20210223-%e7%ba%bf%e7%a8%8b%e6%b1%a0%e9%85%8d%e7%bd%ae%e6%b5%81%e7%a8%8b%e5%9b%be.png"
        data-srcset="/images/20210223-%e7%ba%bf%e7%a8%8b%e6%b1%a0%e9%85%8d%e7%bd%ae%e6%b5%81%e7%a8%8b%e5%9b%be.png, /images/20210223-%e7%ba%bf%e7%a8%8b%e6%b1%a0%e9%85%8d%e7%bd%ae%e6%b5%81%e7%a8%8b%e5%9b%be.png 1.5x, /images/20210223-%e7%ba%bf%e7%a8%8b%e6%b1%a0%e9%85%8d%e7%bd%ae%e6%b5%81%e7%a8%8b%e5%9b%be.png 2x"
        data-sizes="auto"
        alt="/images/20210223-线程池配置流程图.png"
        title="线程池配置流程图" /></p>
</li>
<li>
<p>增加线程池的监控</p>
</li>
<li>
<p>io密集型可调整为先新增任务到最大线程数后再将任务放到阻塞队列</p>
<p>代码 主要可重写阻塞队列 加入任务的方法</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">offer</span><span class="o">(</span><span class="n">Runnable</span> <span class="n">runnable</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">executor</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">RejectedExecutionException</span><span class="o">(</span><span class="s">&#34;The task queue does not have executor!&#34;</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">final</span> <span class="n">ReentrantLock</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">lock</span><span class="o">;</span>
    <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">currentPoolThreadSize</span> <span class="o">=</span> <span class="n">executor</span><span class="o">.</span><span class="na">getPoolSize</span><span class="o">();</span>
          
        <span class="c1">// 如果提交任务数小于当前创建的线程数, 说明还有空闲线程,
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">executor</span><span class="o">.</span><span class="na">getTaskCount</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">currentPoolThreadSize</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 将任务放入队列中，让线程去处理任务
</span><span class="c1"></span>            <span class="k">return</span> <span class="kd">super</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">runnable</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="c1">// 核心改动
</span><span class="c1"></span>        <span class="c1">// 如果当前线程数小于最大线程数，则返回 false ，让线程池去创建新的线程
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">currentPoolThreadSize</span> <span class="o">&lt;</span> <span class="n">executor</span><span class="o">.</span><span class="na">getMaximumPoolSize</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// 否则，就将任务放入队列中
</span><span class="c1"></span>        <span class="k">return</span> <span class="kd">super</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">runnable</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>拒绝策略 建议使用tomcat的拒绝策略(给一次机会)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// tomcat的源码
</span><span class="c1"></span><span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">execute</span><span class="o">(</span><span class="n">Runnable</span> <span class="n">command</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span> <span class="n">executor</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">executor</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="n">command</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">RejectedExecutionException</span> <span class="n">rx</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 捕获到异常后 在从队列获取，相当于重试1取不到任务 在执行拒绝任务
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span> <span class="o">!(</span> <span class="o">(</span><span class="n">TaskQueue</span><span class="o">)</span> <span class="n">executor</span><span class="o">.</span><span class="na">getQueue</span><span class="o">()).</span><span class="na">force</span><span class="o">(</span><span class="n">command</span><span class="o">)</span> <span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">RejectedExecutionException</span><span class="o">(</span><span class="s">&#34;Work queue full.&#34;</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span> <span class="k">else</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalStateException</span><span class="o">(</span><span class="s">&#34;StandardThreadPool not started.&#34;</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>建议修改从队列取任务的方式： 增加超时时间，超时1分钟取不到在进行返回</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">offer</span><span class="o">(</span><span class="n">E</span> <span class="n">e</span><span class="o">,</span> <span class="kt">long</span> <span class="n">timeout</span><span class="o">,</span> <span class="n">TimeUnit</span> <span class="n">unit</span><span class="o">){}</span>
</code></pre></td></tr></table>
</div>
</div></li>
</ol>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2021-02-20</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"><span>
                            <a class="link-to-markdown" href="/posts/java/%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/%E4%B8%87%E5%AD%97%E5%9B%BE%E8%A7%A3java%E5%A4%9A%E7%BA%BF%E7%A8%8B/index.md" target="_blank">阅读原始文档</a>
                        </span></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="分享到 Twitter" data-sharer="twitter" data-url="https://msdemt.github.io/posts/java/%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/%E4%B8%87%E5%AD%97%E5%9B%BE%E8%A7%A3java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" data-title="万字图解Java多线程"><i class="fab fa-twitter fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Facebook" data-sharer="facebook" data-url="https://msdemt.github.io/posts/java/%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/%E4%B8%87%E5%AD%97%E5%9B%BE%E8%A7%A3java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><i class="fab fa-facebook-square fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Hacker News" data-sharer="hackernews" data-url="https://msdemt.github.io/posts/java/%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/%E4%B8%87%E5%AD%97%E5%9B%BE%E8%A7%A3java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" data-title="万字图解Java多线程"><i class="fab fa-hacker-news fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Line" data-sharer="line" data-url="https://msdemt.github.io/posts/java/%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/%E4%B8%87%E5%AD%97%E5%9B%BE%E8%A7%A3java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" data-title="万字图解Java多线程"><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@2.14.0/icons/line.svg"></i></a><a href="javascript:void(0);" title="分享到 微博" data-sharer="weibo" data-url="https://msdemt.github.io/posts/java/%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/%E4%B8%87%E5%AD%97%E5%9B%BE%E8%A7%A3java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" data-title="万字图解Java多线程" data-ralateuid="xxxx"><i class="fab fa-weibo fa-fw"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/posts/java/%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/java%E7%BA%BF%E7%A8%8Bapi/" class="prev" rel="prev" title="Java线程API"><i class="fas fa-angle-left fa-fw"></i>Java线程API</a>
            <a href="/posts/java/%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/%E6%A2%B3%E7%90%86javaio%E6%B5%81/" class="next" rel="next" title="梳理Java IO流">梳理Java IO流<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
</article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.80.0">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2019 - 2021</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/" target="_blank">hekai</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/smooth-scroll@16.1.3/dist/smooth-scroll.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/autocomplete.js@0.37.1/dist/autocomplete.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/algoliasearch@4.2.0/dist/algoliasearch-lite.umd.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.2.2/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/sharer.js@0.4.0/sharer.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":10},"comment":{},"search":{"algoliaAppID":"PASDMWALPK","algoliaIndex":"index.zh-cn","algoliaSearchKey":"b42948e51daaa93df92381c8e2ac0f93","highlightTag":"em","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"algolia"}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
