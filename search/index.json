[{"content":"工作中使用到了 mariadb 5.5.60 版本，使用 docker 部署下。\n参考：\nhttps://hub.docker.com/_/mariadb\ndocker-compose 如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 hekai@thinkpad-l14:~/doc/docker-mariadb$ cat docker-compose.yml # Use root/example as user/password credentials version: \u0026#39;3.1\u0026#39; services: db: image: mariadb:5.5.60 restart: always environment: MYSQL_ROOT_PASSWORD: root MYSQL_ROOT_HOST: \u0026#34;%\u0026#34; TZ: Asia/Shanghai ports: - 3306:3306 volumes: - ./data:/var/lib/mysql - ./conf:/etc/mysql/conf.d adminer: image: adminer restart: always environment: TZ: Asia/Shanghai ports: - 18080:8080 docker-compose 参数\nrestart: always : 重启 docker 后，配置该参数的docker容器在docker重启时自动启动 TZ: Asia/Shanghai: environment 参数，指定中国时区，默认是格林尼治时间（GMT） mariadb 环境变量\nMYSQL_ROOT_PASSWORD: 指定 mariadb root 用户密码 MYSQL_ROOT_HOST: 指定 root 用户可访问的来源， % 表示所有来源的 root 用户都可以访问 docker-compose 中使用到了 adminer 开源数据库管理工具，访问方式为：http://127.0.0.1:18080\n","date":"2023-08-10T00:00:00Z","permalink":"https://msdemt.github.io/p/docker-mariadb-5.5.60/","title":"docker 部署 mariadb-5.5.60"},{"content":"在 wsl 上 git clone 失败，错误如下\n1 2 3 hekai@thinkpad-l14:~$ git clone https://github.com/msdemt/docker-centos7-slurm-cluster.git Cloning into \u0026#39;docker-centos7-slurm-cluster\u0026#39;... fatal: unable to access \u0026#39;https://github.com/msdemt/docker-centos7-slurm-cluster.git/\u0026#39;: GnuTLS recv error (-110): The TLS connection was non-properly terminated. 参考：\nhttps://zhuanlan.zhihu.com/p/624555732\n重新安装下 git\n1 2 3 sudo add-apt-repository ppa:git-core/ppa sudo apt update sudo apt install git 之后可以 git clone 成功了，但是过一段时间，又 git clone 出现了相同的问题\n最终解决：配置 git 代理\n1 git config --global http.proxy socks5://127.0.0.1:7890 git clone 失败，原因 linux 子系统无法使用 127.0.0.1 访问 windows 系统上的服务\n参考：\nhttps://learn.microsoft.com/zh-cn/windows/wsl/networking\n在 linux 子系统 ubuntu 中执行\n1 cat /etc/resolv.conf 1 2 3 4 5 hekai@thinkpad-l14:~$ cat /etc/resolv.conf # This file was automatically generated by WSL. To stop automatic generation of this file, add the following entry to /etc/wsl.conf: # [network] # generateResolvConf = false nameserver 172.22.192.1 复制 nameserver 后面的地址\n在 linux 子系统中使用该地址访问 windows 上的服务，所以 git 代理改为如下内容\n1 git config --global http.proxy socks5://172.22.192.1:7890 git clone 成功。\n","date":"2023-08-10T00:00:00Z","permalink":"https://msdemt.github.io/p/wsl-ubuntu-git-fail/","title":"wsl ubuntu git clone 失败"},{"content":"Set up the repository Update the apt package index and install packages to allow apt to use a repository over HTTPS:\n1 2 sudo apt-get update sudo apt-get install ca-certificates curl gnupg Add Docker’s official GPG key:\n1 2 3 sudo install -m 0755 -d /etc/apt/keyrings curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg sudo chmod a+r /etc/apt/keyrings/docker.gpg Use the following command to set up the repository:\n1 2 3 4 echo \\ \u0026#34;deb [arch=\u0026#34;$(dpkg --print-architecture)\u0026#34; signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \\ \u0026#34;$(. /etc/os-release \u0026amp;\u0026amp; echo \u0026#34;$VERSION_CODENAME\u0026#34;)\u0026#34; stable\u0026#34; | \\ sudo tee /etc/apt/sources.list.d/docker.list \u0026gt; /dev/null Update the apt package index:\n1 sudo apt-get update Install Docker Engine Install Docker Engine, containerd, and Docker Compose.\nTo install the latest version, run:\n1 sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin Verify that the Docker Engine installation is successful by running the hello-world image.\n1 sudo docker run hello-world 安装 docker compose To download and install the Compose CLI plugin, run:\n1 2 3 DOCKER_CONFIG=${DOCKER_CONFIG:-$HOME/.docker} mkdir -p $DOCKER_CONFIG/cli-plugins curl -SL https://github.com/docker/compose/releases/download/v2.20.2/docker-compose-linux-x86_64 -o $DOCKER_CONFIG/cli-plugins/docker-compose Apply executable permissions to the binary:\n1 chmod +x $DOCKER_CONFIG/cli-plugins/docker-compose Test the installation.\n1 docker compose version 以非 Root 用户身份执行 Docker 默认情况下，只有 root 或者 有 sudo 权限的用户可以执行 Docker 命令。\n想要以非 root 用户执行 Docker 命令，你需要将你的用户添加到 Docker 用户组，该用户组在 Docker CE 软件包安装过程中被创建。想要这么做，输入：\n1 sudo usermod -aG docker $USER $USER是一个环境变量，代表当前用户名。\n登出，并且重新登录，以便用户组信息刷新。\ndocker 开机启动 目前，在 wsl ubuntu 上安装docker后，已经支持 docker 开机启动了。\nwsl ubuntu 也支持使用 systemctl 命令了。\n开机启动\n1 systemctl enable docker 禁止开机启动\n1 systemctl disable docker 卸载 docker 在卸载 Docker 之前，移除所有的容器，镜像，卷和网络。\n运行下面的命令停止所有正在运行的容器，并且移除所有的 docker 对象：\n1 2 docker container stop $(docker container ls -aq) docker system prune -a --volumes 现在可以使用apt像卸载其他软件包一样来卸载 Docker：\n1 2 sudo apt purge docker-ce sudo apt autoremove 修改docker数据存储路径 wsl ubuntu 默认安装在 c 盘，希望将 docker 的数据存储路径（默认为 /var/lib/docker ）修改到 d 盘。\n添加 /etc/docker/daemon.json 文件，内容如下\n1 2 3 4 5 6 { \u0026#34;registry-mirrors\u0026#34;: [\u0026#34;https://registry.docker-cn.com\u0026#34;], \u0026#34;data-root\u0026#34;: \u0026#34;/mnt/d/data/docker\u0026#34;, \u0026#34;log-driver\u0026#34;:\u0026#34;json-file\u0026#34;, \u0026#34;log-opts\u0026#34;: {\u0026#34;max-size\u0026#34;:\u0026#34;100m\u0026#34;} } docker 启动失败。wls ubuntu docker可能不支持将文件存储到 windows 磁盘。\n将 /var/lib/docker 拷贝到 d 盘，报错，应该是 windows 磁盘不支持这些特殊文件。\n1 2 3 4 5 hekai@thinkpad-l14:~$ sudo mv /var/lib/docker /mnt/d/data/docker mv: cannot create special file \u0026#39;/mnt/d/data/docker/volumes/backingFsBlockDev\u0026#39;: Operation not supported mv: cannot create special file \u0026#39;/mnt/d/data/docker/volumes/docker-centos7-slurm-cluster_mysql/_data/mysql.sock\u0026#39;: Operation not supported mv: cannot create special file \u0026#39;/mnt/d/data/docker/overlay2/3a272b47e6ae28aa475f3eea705bdb2bdeb83dc97c6feb91cc20e6c49bbc004b-init/work/work/#23d\u0026#39;: Operation not supported mv: cannot create special file \u0026#39;/mnt/d/data/docker/overlay2/2a012b89cc6a205c6c8a148abae32a5e735695b52a54e2e3e792c2a5e88a00af-init/work/work/#23f\u0026#39;: Operation not supported wsl ubuntu docker 暂不更改存储位置了。\n参考：\nhttps://docs.docker.com/engine/install/ubuntu/\nhttps://docs.docker.com/compose/install/linux/#install-the-plugin-manually\nhttps://zhuanlan.zhihu.com/p/143156163\nhttps://blog.csdn.net/m0_58684193/article/details/127554527\n","date":"2023-08-10T00:00:00Z","permalink":"https://msdemt.github.io/p/wsl-ubuntu-docker/","title":"wsl ubuntu 安装 docker"},{"content":"介绍 wsl 全称 The Windows Subsystem for Linux ，即适用于 Linux 的 Windows 子系统，可以让开发者在 windows 系统上按原样运行 GNU/Linux 环境 - 包括大多数命令行工具、实用工具和应用程序 - 且不会产生传统虚拟机或双启动设置开销。\nWSL 2 是适用于 Linux 的 Windows 子系统体系结构的一个新版本，它支持适用于 Linux 的 Windows 子系统在 Windows 上运行 ELF64 Linux 二进制文件。 它的主要目标是提高文件系统性能，以及添加完全的系统调用兼容性。\n安装 系统： windows 11\n在管理员模式下打开 PowerShell 或 Windows 命令提示符，方法是右键单击并选择“以管理员身份运行”，输入 wsl --install 命令，然后重启计算机。\n1 wsl --install 此命令将启用运行 WSL 并安装 Linux 的 Ubuntu 发行版所需的功能。\n更改默认安装的 Linux 发行版 默认情况下，安装的 Linux 分发版为 Ubuntu。 可以使用 -d 标志进行更改。\n若要更改安装的发行版，请输入：wsl --install -d \u0026lt;Distribution Name\u0026gt;。 将 \u0026lt;Distribution Name\u0026gt; 替换为要安装的发行版的名称。\n若要查看可通过在线商店下载的可用 Linux 发行版列表，请输入：wsl --list --online 或 wsl -l -o。\n若要在初始安装后安装其他 Linux 发行版，还可使用命令：wsl --install -d \u0026lt;Distribution Name\u0026gt;。\n检查正在运行的 WSL 版本 可列出已安装的 Linux 发行版，并通过在 PowerShell 或 Windows 命令提示符中输入以下命令来检查每个发行版的 WSL 版本：wsl -l -v。\n要在安装新的 Linux 发行版时将默认版本设置为 WSL 1 或 WSL 2，请使用命令 wsl --set-default-version \u0026lt;Version#\u0026gt;，将 \u0026lt;Version#\u0026gt; 替换为 1 或 2。\n要设置与 wsl 命令一起使用的默认 Linux 发行版，请输入 wsl -s \u0026lt;DistributionName\u0026gt; 或 wsl --setdefault \u0026lt;DistributionName\u0026gt;，将 \u0026lt;DistributionName\u0026gt; 替换为要使用的 Linux 发行版的名称。 例如，从 PowerShell/CMD 输入 wsl -s Debian，将默认发行版设置为 Debian。 现在从 Powershell 运行 wsl npm init 将在 Debian 中运行 npm init 命令。\n要在 PowerShell 或 Windows 命令提示符下运行特定的 WSL 发行版而不更改默认发行版，请使用命令 wsl -d \u0026lt;DistributionName\u0026gt;，将 \u0026lt;DistributionName\u0026gt; 替换为要使用的发行版的名称。\n参考：\nhttps://learn.microsoft.com/zh-cn/windows/wsl\n","date":"2023-08-10T00:00:00Z","permalink":"https://msdemt.github.io/p/wsl-install/","title":"wsl 安装"},{"content":"介绍 在使用云主机时，某个用户登录后，可以执行如下命令直接切换到 root 用户\n1 $ sudo su - root sudo 命令需要输入当前用户的密码，su 命令需要输入 root 用户的密码。另外一个区别是其默认行为，sudo 命令只允许使用提升的权限运行单个命令，而 su 命令会启动一个新的 shell，同时允许使用 root 权限运行尽可能多的命令，直到明确退出登录。\nsudo 命令 sudo 命令，全称为 super user do，允许非root用户执行root用户才可以执行的命令。\n要想使一个用户具有使用sudo的能力，需要让root用户将其名字、可以执行的特定命令、按照哪种用户或用户组的身份执行等信息注册到/etc/sudoers文件中，即完成对该用户的授权（此时该用户称为“sudoer”）才可以。\n当一般用户执行特殊权限时，在命令前加上 sudo，此时系统会让你输入密码以确认终端机前操作的是你本人，确认后系统会将该命令的进程以超级用户的权限运行。\n在一定的时间段内，再次执行sudo的命令时不再询问密码，超出此时间段（一般为5分钟）后需要再次输入密码。\n可以配置用户执行sudo时不需输入密码\nsudo配置无密码后，用户就可以使用 sudo su - root 直接免密切换到root 用户了\n无密码 sudo 配置 centos7 配置用户无密码 sudo 修改/etc/sudoers文件，从而让普通用户hekai支持无密码sudo\n1 2 3 4 5 6 7 8 $ chmod u+w /etc/sudoers $ vim /etc/sudoers $ diff /etc/sudoers /etc/sudoers.bak 108c108 \u0026lt; hekai ALL=(ALL) NOPASSWD:ALL --- \u0026gt; $ chmod u-w /etc/sudoers 注意：hekai ALL=(ALL) NOPASSWD:ALL 需要添加到 # %wheel ALL=(ALL) NOPASSWD: ALL 下面，否则sudo还是会需要密码的。\n然后，hekai用户就可以无需密码执行sudo命令了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 [root@centos7-desktop ~]# ll /etc/sudoers -r--r-----. 1 root root 4328 9月 30 2020 /etc/sudoers [root@centos7-desktop ~]# chmod u+w /etc/sudoers [root@centos7-desktop ~]# ll /etc/sudoers -rw-r-----. 1 root root 4328 9月 30 2020 /etc/sudoers [root@centos7-desktop ~]# vim /etc/sudoers [root@centos7-desktop ~]# diff /etc/sudoers /etc/sudoers.bak 108c108 \u0026lt; hekai ALL=(ALL) NOPASSWD:ALL --- \u0026gt; [root@centos7-desktop ~]# chmod u-w /etc/sudoers [root@centos7-desktop ~]# ll /etc/sudoers -r--r-----. 1 root root 4364 12月 20 15:17 /etc/sudoers [root@centos7-desktop ~]# cat /etc/sudoers ## Next comes the main part: which users can run what software on ## which machines (the sudoers file can be shared between multiple ## systems). ## Syntax: ## ## user MACHINE=COMMANDS ## ## The COMMANDS section may have other options added to it. ## ## Allow root to run any commands anywhere root ALL=(ALL) ALL ## Allows members of the \u0026#39;sys\u0026#39; group to run networking, software, ## service management apps and more. # %sys ALL = NETWORKING, SOFTWARE, SERVICES, STORAGE, DELEGATING, PROCESSES, LOCATE, DRIVERS ## Allows people in group wheel to run all commands %wheel ALL=(ALL) ALL ## Same thing without a password # %wheel ALL=(ALL) NOPASSWD: ALL hekai ALL=(ALL) NOPASSWD:ALL 配置用户有密码 sudo 若允许用户执行sudo命令（默认sudo命令需要输入用户密码），需将用户添加到 wheel 组，使用如下命令\n1 $ usermod -a -G hekai wheel 也可以使用\n1 $ gpasswd -a hekai wheel 此时，hekai用户执行 sudo ，还需要输入密码。加入wheel用户组，只是允许普通用户能够 sudo -s 切换到 root\n使用如下命令，将用户 hekai 从 wheel 组删除\n1 $ gpasswd -d hekai wheel 执行 usermod 或 gpasswd 命令，不会改变 /etc/sudoers 文件内容\n操作记录\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 将hekai添加到wheel组 [root@centos7-desktop etc]# usermod -a -G hekai wheel # 也可以使用 gpasswd -a hekai wheel # 使用hekai用户执行sudo，还是需要输入密码 [hekai@centos7-desktop ~]$ sudo vi /etc/hosts [sudo] hekai 的密码： [hekai@centos7-desktop ~]$ [root@centos7-desktop etc]# diff /etc/sudoers /etc/sudoers.bak [root@centos7-desktop etc]# id hekai uid=1000(hekai) gid=1000(hekai) 组=1000(hekai),10(wheel) 将hekai从wheel用户组删除 [root@centos7-desktop etc]# gpasswd -d hekai wheel 正在将用户“hekai”从“wheel”组中删除 [root@centos7-desktop etc]# id hekai uid=1000(hekai) gid=1000(hekai) 组=1000(hekai) [root@centos7-desktop etc]# su 命令 su 是切换用户的命令，后面不加用户，默认切换到root，切换后不改变当前环境变量 su - 是切换用户的同时将环境变量修改为目标用户的环境变量\n使用su切换用户时，需要输入目标用户的密码\n参考：\nhttps://blog.csdn.net/chl183/article/details/108305842\nhttps://zhuanlan.zhihu.com/p/137332644\nhttps://zhuanlan.zhihu.com/p/252345791\n","date":"2023-08-09T00:00:00Z","permalink":"https://msdemt.github.io/p/sudo-su-root/","title":"sudo su - root 介绍"},{"content":"介绍 我们在 linux 上安装软件时,经常会使用如下命令\n1 2 3 ./configure make make install 这些命令是怎么工作的呢？\n这些命令有什么作用？ linux 上使用源码编译安装软件通常有如下三步\n配置软件（Configure the software） configure 脚本负责完成在指定系统上构建软件的准备工作，它确保后续的构建和安装过程中所有需要的依赖可以使用，并且找出使用这些依赖所需的任何信息。\nUnix/Linux 程序经常使用 C 语言编写，所以我们经常需要 C 编译器来构建这些程序。在这个场景下, configure 脚本会确保你的系统中确实存在一个 C 编译器，并且找到这个 C 编译器的名字和位置。\n构建软件（Build the software） 一旦 configure 命令执行完成，我们可以调用 make 命令来构建软件。这个步骤会执行定义在 Makefile 文件中的一系列任务来将软件从源码构建为最终可执行程序。\n你下载的软件源码 tar 包通常不包含最终的 Makefile 文件，而是包含名为 Makefile.in 的模板文件。然后利用 configure 脚本针对当前的系统利用 Makefile.in 文件生成的定制化的 Makefile 文件。\n安装软件（Install the software） 现在软件已经构建完成，可以运行了，相关文件可以被拷贝到它们的最终目录。 make install 命令会将构建出的可执行文件和它的依赖库、文档拷贝到正确的位置。\n这通常意味着软件的二进制文件会被拷贝到你的 PATH 路径下，软件的操作手册会被拷贝到你的 MANPATH 路径下，同时软件依赖的其他文件也会被安全地保存到相应的位置。\n因为安装步骤也是定义在 Makefile 文件中，所以软件的安装位置可以通过某个参数传递给 configure 脚本，或者由 configure 脚本利用某个系统变量来实现指定安装位置。\n根据软件的安装位置，您可能需要升级此步骤的权限，以便可以将文件复制到系统目录。 使用 sudo 通常可以达到目的。\n这些脚本是怎么产生的？ 上述步骤之所以能成功工作，是因为 configure 脚本会检查你的系统，并使用它找到的信息将 Makefile.in 模板转换为 Makefile 文件，但是 configure 脚本和 Makefile.in 模板是怎么产生的呢？\n如果你曾经打开过 configure 脚本，或者相关的 Makefile.in 文件，你会发现这些文件里包含几千行的脚本语句。有时候这些支持配置的脚本语句比要安装的程序的源代码还要长。\n即使利用已有的 configure 脚本文件开始编写，手动编写完成一个 configure 脚本也是非常艰巨的。不过不用担心：这些脚本不是手工构建的。\n以这种方式构建的软件通常使用一个叫做 autotools 的工具集进行打包。这个工具集包含 autoconf、automake 等工具，所有的这些工具使得维护软件生命周期变得很容易。最终用户不需要了解这些工具，同时让软件在不同的 Unix/Linux 系统的安装步骤变得简单。\nHello World 案例 我们以一个简单的 Hello World C 语言程序为例，来看看如何使用 autotools 工具集打包。\n下面是程序源代码，在一个名为 main.c 的文件中\n1 2 3 4 5 6 7 #include \u0026lt;stdio.h\u0026gt; int main(int argc, char* argv[]) { printf(\u0026#34;Hello World\\n\u0026#34;); return 0; } 创建 configure 脚本 不需要手动编写 configure 脚本，我们需要创建一个使用 m4sh 语言（m4 宏命令和 POSIX shell 脚本的组合）编写的 configure.ac 文件来描述 configure 脚本需要做的事情。\n我们需要第一个调用的 m4 宏为 AC_INIT，它会初始化 autoconf 并且设置一些关于打包软件的基本信息。我们的软件名为 helloworld，版本为 0.1，维护者为 george@thoughtbot.com：\n1 AC_INIT([helloworld], [0.1], [george@thoughtbot.com]) 这个项目中我们会使用 automake，所以我们需要使用 AM_INIT_AUTOMAKE 宏命令来初始化 automake\n1 AM_INIT_AUTOMAKE 下面，我们需要告诉 autoconf 让 configure 脚本需要寻找的相关依赖，在本例中， configure 脚本仅需要使用 C 编译器，我们可以使用 AC_PROG_CC 宏命令设置。\n1 AC_PROG_CC 如果有其他的依赖项，那我们可以使用其他的 m4 宏命令来设置，如使用 AC_PATH_PROG 宏表示在用户的 PATH 路径中搜索一个特定的程序。\n此时我们已经列出了使用的依赖，前面有提到，configure 脚本会根据用户系统的系统信息和 Makefile.in 模板文件生成 Makefile 文件。\n下面一行使用 AC_CONFIG_FILES 宏命令告诉 autoconf 工具 configure 脚本文件需要做这些工作：configure 脚本文件需要找到一个名为 Makefile.in 的文件，将文件内的站位符使用对应的值替换，例如将 @PACKAGE_VERSION@ 替换为 0.1，然后将结果写入到 Makefile 文件。\n1 AC_CONFIG_FILES([Makefile]) 最后，当我们告诉 autoconf 工具所有 configure 脚本需要做的工作后，可以调用 AC_OUTPUT 宏命令输出脚本内容\n1 AC_OUTPUT 下面是 configure.ac 中的所有代码，相比 4737 行的 configure 脚本文件，这些代码好多了。\n1 2 3 4 5 AC_INIT([helloworld], [0.1], [george@thoughtbot.com]) AM_INIT_AUTOMAKE AC_PROG_CC AC_CONFIG_FILES([Makefile]) AC_OUTPUT 还差一点我们就可以发布软件了，configure 脚本需要一个 Makefile.in 文件，将系统相关信息填充进去后，生成最终的 Makefile 文件。\n创建 Makefile 文件 与 configure 脚本文件相比，Makefile.in 模板文件非常长且复杂。因此，我们不是手工编写，而是编写一个较短的 Makefile.am 文件，然后利用automake 使用该文件为我们生成 Makefile.in 文件。\n首先，我们需要设置一些参数来告诉 automake 工具本项目的结构，因为这里的例子不是标准的 GNU 项目的结构，所以结构声明为 foreign 。\n1 AUTOMAKE_OPTIONS = foreign 接下来告诉 automake 我们希望 Makefile 编译的软件名为 helloworld:\n1 bin_PROGRAMS = helloworld 这行包含了很多打包信息，感谢 automake 的统一命名规则\nPROGRAMS 后缀成为 primary 主要信息，它告诉 automake 工具 helloworld 文件具有哪些属性。例如 PROGRAMS 需要被编译，相比 SCRIPTS 和 DATA 文件不需要被编译。\nbin 前缀告诉 automake 工具，这里列出的文件应该被安装到 bindir 变量指定的路径下。 autotools 工具还为我们定义了其他目录，包括 bindir , libdir , pkglibdir ，我们也可以自定义自己需要的目录。\n如果我们的程序有一部分是 Ruby 脚本，我们可以定义 rubydir 变量并且告诉 automake 安装我们的 ruby 文件到该路径。\n1 2 rubydir = $(datadir)/ruby ruby_DATA = my_script.rb my_other_script.rb 可以在安装目录之前添加其他前缀，以进一步区分 automake 的行为。\n因为我们已经定义了 RPOGRAM ，我们需要告诉 automake 在哪里可以找到它的源文件。 在这种情况下，前缀是这些源文件构建的程序的名称，而不是它们将安装的位置：\n1 helloworld_SOURCES = main.c 这是我们的 helloworld 程序的整个 Makefile.am 文件。 与 configure.ac 和 configure 脚本一样，它比它生成的 Makefile.in 要短得多：\n1 2 3 AUTOMAKE_OPTIONS = foreign bin_PROGRAMS = helloworld helloworld_SOURCES = main.c 把它们放在一起 现在我们已经编写了配置文件，我们可以运行 autotools 并生成完成的 configure 脚本和 Makefile.in 模板。\n首先，我们需要生成一个 m4 环境供 autotools 使用：\n1 aclocal 现在我们可以运行 autoconf 将 configure.ac转换为configure脚本，并运行automake将Makefile.am转换为Makefile.in`：\n1 2 autoconf automake --add-missing 分发程序 最终用户不需要查看我们的 autotools 工具的设置，因此我们可以分发 configure 脚本和 Makefile.in，而无需分发用于生成它们的所有文件。\n幸运的是，autotools 工具也将帮助我们进行分发。 Makefile 包含各种有趣的目标，包括构建项目 tarball 的目标，其中包含我们需要分发的所有文件：\n1 2 ./configure make dist 您甚至可以测试分发 tarball 是否可以在各种条件下安装：\n1 make distcheck 总览 现在我们知道编译安装命令从何而来以及它是如何运作的！\n在维护者的系统上：\n1 2 3 4 5 aclocal # Set up an m4 environment autoconf # Generate configure from configure.ac automake --add-missing # Generate Makefile.in from Makefile.am ./configure # Generate Makefile from Makefile.in make distcheck # Use Makefile to build and test a tarball to distribute 在最终用户的系统上：\n1 2 3 ./configure # Generate Makefile from Makefile.in make # Use Makefile to build the program make install # Use Makefile to install the program 参考：\nhttps://zhuanlan.zhihu.com/p/77813702\nhttps://thoughtbot.com/blog/the-magic-behind-configure-make-make-install\n","date":"2023-08-03T00:00:00Z","permalink":"https://msdemt.github.io/p/configure-make-makeinstall/","title":"configure、make、make install 如何工作?"},{"content":"介绍 本文在 centos7 系统上安装 nginx，nginx 有两种安装方式，yum 安装和源码编译安装。\nyum安装 yum 安装后会将 nginx 的文件放在系统的不同位置,可以使用 rpm -ql nginx 或 whereis nginx 查看安装路径\n卸载的话,使用yum remove nginx 命令来卸载\n安装 nginx\n1 $ sudo yum -y install nginx 卸载 nginx\n1 $ sudo yum remove nginx 使用 yum 安装 nginx 时, nginx 配置文件在 /etc/nginx 目录\n配置 nginx 服务\n1 2 3 4 5 6 7 8 9 10 # 设置开机启动 $ sudo systemctl enable nginx # 启动 nginx 服务 $ sudo service nginx start # 停止 nginx 服务 $ sudo service nginx stop # 重启 nginx 服务 $ sudo service nginx restart # 重新加载配置，一般是在修改过 nginx 配置文件时使用 $ sudo service nginx reload 此外,还有\n1 2 3 4 # 检查 nginx 配置是否正确 $ nginx -t # 重新加载配置 $ ngxin -s reload 源码编译安装 使用 rpm -qa | grep nginx 查询 nginx 安装包,然后使用 rpm -e nginx 卸载, 如果提示存在依赖无法卸载,可以使用 rpm -e --nodeps nginx 强制卸载\n安装依赖库 安装 gcc 环境\n1 2 # nginx编译时依赖 gcc 环境 $ sudo yum -y install gcc gcc-c++ 安装 pcre\n1 2 # 让 nginx 支持重写功能 $ sudo yum -y install pcre pcre-devel 安装 zlib\n1 2 # zlib 库提供了很多压缩和解压缩的方式，nginx 使用 zlib 对 http 包内容进行 gzip 压缩 $ sudo yum -y install zlib zlib-devel 安装 openssl\n1 2 # 安全套接字层密码库，用于通信加密 $ sudo yum -y install openssl openssl-devel 编译安装 下载 nginx 源码包\n1 $ sudo curl -O https://nginx.org/download/nginx-1.24.0.tar.gz 解压\n1 $ sudo tar -zxf nginx-1.24.0.tar.gz 进入解压后的目录,配置环境\n1 2 $ cd nginx-1.24.0 $ ./configure --prefix=/usr/local/nginx --prefix=/usr/local/nginx 指定 nginx 编译安装的目录,安装后会在此目录下生成 nginx 相关文件\n编译安装\n1 2 3 4 # 编译 $ make # 安装 $ make install 编译安装后的操作命令和 yum 安装的不同\n启动服务\n1 $ /usr/local/nginx/sbin/nginx 检查 nginx 配置\n1 $ /usr/local/nginx/sbin/nginx -t 重新加载服务\n1 $ /usr/local/nginx/sbin/nginx -s reload 停止服务\n1 $ /usr/local/nginx/sbin/nginx -s stop 查看 nginx 服务进程\n1 $ ps -ef|grep nginx 参考:\nhttps://juejin.cn/post/6844904134345228301\nhttps://blog.csdn.net/weixin_53187893/article/details/115090825\nhttps://segmentfault.com/a/1190000007116797\n","date":"2023-08-02T00:00:00Z","image":"https://msdemt.github.io/p/nginx-install/nginx-ar21.svg","permalink":"https://msdemt.github.io/p/nginx-install/","title":"centos7系统安装nginx"},{"content":"介绍 ssh 有三种方式可以跳转登录，分别是：ProxyJump、ProxyCommand、SSH Tunnel。\n在某些场景下，SSH无法直接访问服务器，需要通过其他服务器进行代理访问，比如外网服务器访问仅允许使用VPN或4A访问的内网服务器。在这种场景下，常用的方式是端口转发，使用端口转发建立连接，然后再做访问。如果面临更多服务器，就需要建立多个端口转发连接，比较麻烦。\nProxyJump 可以使用SSH提供的ProxyJump参数，进行代理服务跳转，简化登录流程，ProxyJump简写参数是 -J 。\n在 openssh7.3 以上的版本，开始支持 ProxyJump 。\nProxyJump可以在命令行执行，也可以写在配置文件（~/.ssh/config）中。\n命令行执行语法\n1 $ ssh -J user@proxyserver1,user@proxyserver2 user@targetserver 使用命令行时需要逐个输入代理服务器的密码。\n可以使用config配置文件和ssh密钥文件，简化登录流程，\n配置文件（~/.ssh/config）语法\n1 2 3 4 5 6 7 8 9 10 11 12 Host ProxyServer Hostname \u0026lt;jump_server ip\u0026gt; Port \u0026lt;jump_server port\u0026gt; User \u0026lt;jump_server user\u0026gt; IdentityFile \u0026lt;jump_server id_rsa\u0026gt; Host target HostName \u0026lt;target_server ip\u0026gt; Port \u0026lt;target_server port\u0026gt; User \u0026lt;target_server user\u0026gt; IdentityFile \u0026lt;target_server id_rsa\u0026gt; ProxyJump ProxyServer 配置之后，在终端执行 ssh target 即可ssh到目标服务器\nProxyCommand 若不支持ProxyJump，可以使用ProxyCommand\n-W host:port #将client过来的标准输入和输出forward到host和port指定的地方. 可以看到,这个选项直接就可以搭配上ProxyCommand的需求\nProxyCommand 命令行语法\n1 ssh username@target_server_ip -p 22 -o ProxyCommand=\u0026#39;ssh -p 22 username@jump_server_ip -W %h:%p\u0026#39; 同样可以在~/.ssh/config增加配置\n1 2 3 4 5 6 7 8 9 10 11 Host ProxyServer Hostname \u0026lt;jump_server ip\u0026gt; Port \u0026lt;jump_server port\u0026gt; User \u0026lt;jump_server user\u0026gt; IdentityFile \u0026lt;jump_server id_rsa\u0026gt; Host target HostName \u0026lt;target_server ip\u0026gt; Port \u0026lt;target_server port\u0026gt; User \u0026lt;target_server user\u0026gt; ProxyCommand ssh -p 22 -W %h:%p ProxyServer 参考：\nhttps://qusec.cn/posts/sssh/\nhttps://peirs.net/sshs-proxyjump-parameter/\nhttps://murphypei.github.io/blog/2021/12/ssh-proxyjump\nhttps://www.jianshu.com/p/199013854070\nhttps://zhuanlan.zhihu.com/p/74193910\nhttps://blog.csdn.net/wxqee/article/details/49234595\nhttps://www.jianshu.com/p/ad5aa9663d37\nhttps://juejin.cn/s/ssh%20config%20proxyjump%20windows\n","date":"2023-07-28T00:00:00Z","image":"https://msdemt.github.io/p/ssh-proxy/Linux-Symbole-2048x1158_hu6f8b26c03cc6e65572403f8d94a50599_544049_120x120_fill_box_smart1_3.png","permalink":"https://msdemt.github.io/p/ssh-proxy/","title":"SSH-ProxyJump跳转登录"},{"content":"介绍 在Linux系统上，常见的输入法有 IBus(Intelligent Input Bus)、XIM(X Input Method)、Fcitx(FlexibleInput Method Framework)。\nFcitx: 支持谷歌拼音、搜狗拼音、五笔 IBus: 支持只能拼音，五笔 XIM: 略（用的比较少） 安装 ubuntu18.04系统中，已自带IBus和XIM输入法框架\n本文在ubuntu18.04上安装fcitx输入法框架\n安装方法\n检查fcitx是否已安装 1 $ fcitx --version 安装fcitx框架 1 $ sudo apt install -y fcitx-bin 安装fcitx默认输入法，fcitx-table中包含了拼音输入法（fcitx-pinyin），可以安装fcitx-table-all，包含了五笔输入法。 1 $ sudo apt install -y fcitx-table 安装谷歌拼音输入法 1 $ sudo apt install -y fcitx-googlepinyin 配置fcitx ubuntu设置\u0026mdash;区域和语言\u0026mdash;管理已安装语言\u0026mdash;键盘输入法系统中选择fcitx 重启ubuntu系统 安装记录\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 test@00bafcjc-durwemo9n5:~$ fcitx --version Command \u0026#39;fcitx\u0026#39; not found, but can be installed with: sudo apt install fcitx-bin test@00bafcjc-durwemo9n5:~$ sudo apt install fcitx-bin ... ... test@00bafcjc-durwemo9n5:~$ sudo apt install -y fcitx-table 正在读取软件包列表... 完成 正在分析软件包的依赖关系树 正在读取状态信息... 完成 将会同时安装下列软件： fcitx-pinyin 建议安装： fcitx-table-all 下列【新】软件包将被安装： fcitx-pinyin fcitx-table 升级了 0 个软件包，新安装了 2 个软件包，要卸载 0 个软件包，有 0 个软件包未被升级。 test@00bafcjc-durwemo9n5:~$ sudo apt install -y fcitx-googlepinyin ... ... test@00bafcjc-durwemo9n5:~$ fcitx --version fcitx version: 4.2.9.6 问题 输入法图标问题 重启后，可以在ubuntu界面右上角看到fcitx的小键盘图标，如果之前配置使用过IBus输入法，此时右上角会有两个输入法图标。\n解决：ubuntu设置\u0026mdash;区域和语言\u0026mdash;输入源 中删除汉语，只保留英语(美国)，这样默认的输入法图标就消失了。\n参考：\nhttps://leimao.github.io/blog/Ubuntu-Gaming-Chinese-Input/\n中英文切换问题 fcitx使用中，无法shift切换中英文\n原因：点击右上角fcitx小键盘图标\u0026mdash;配置\u0026mdash;输入法 中只配置了 Google拼音 输入法。\nUbuntu下所谓的中英文切换就是一个输入法系统的中文输入法切换到其中的英文输入法，所以一定要保证输入法系统中既有中文输入法也要有英文输入法。 所以，添加 键盘-英语(美国) 输入法。 此外，在 全局配置\u0026mdash;快捷键 中，切换激活/非激活输入法 使用 Lshift ，额外的激活输入法快捷键 选择 左Shift\n参考：\nhttps://blog.csdn.net/yucicheung/article/details/79331529\nidea快捷键冲突问题 使用idea时，无法使用快捷键 Ctrl+Shift+F，原因该键被fcitx的简繁转换功能占用\n解决： 点击右上角fcitx小键盘图标\u0026mdash;配置\u0026mdash;附加组件，取消简繁转换\n参考：\nhttps://zhuanlan.zhihu.com/p/508797663\nhttps://zhuanlan.zhihu.com/p/529892064\nhttps://leimao.github.io/blog/Ubuntu-Gaming-Chinese-Input/\nhttps://blog.csdn.net/chen462488588/article/details/109290855\n","date":"2023-07-27T00:00:00Z","image":"https://msdemt.github.io/p/ubuntu-fcitx/ubuntu_logo_hu373a6c33440a9fb65cfc39e6a6372242_135517_120x120_fill_box_smart1_3.png","permalink":"https://msdemt.github.io/p/ubuntu-fcitx/","title":"ubuntu18.04安装fcitx输入法框架"},{"content":"介绍 工作中，生产环境的服务器是无法直接访问的，通常需要4A，访问比较麻烦，可以使用 ssh隧道 简化登录流程。\n如下图\nssh登录4A后，无法直接访问 server-2，可以通过 server-1 服务器代理访问。\n具体流程\nssh登录4A，新建隧道 使用4A的隧道作为代理，ssh访问server-1服务器,在server-1上新建隧道 使用server-1隧道代理访问server-2服务器 使用bitvise配置 安装bitvise ssh client，下载地址：https://www.bitvise.com/download-area\n新开一个bitvise页面，假设4A系统内网IP为192.168.15.45:10011，添加用户名、密码等登录信息，点击Save profile，将该配置保存。\n新开一个bitvise页面，填入server-1的IP、端口和登录信息，在 Proxy settings 中，选择第二步保存的4A配置文件，这样就可以使用4A作为代理访问server-1了。（第二步不需要登录了） 因为的目标服务器server-2还需要使用server-1代理才可以访问，所以还需要打开Services选项卡，勾选SOCKS/HTTP Proxy Forwarding，将本地空闲的端口如1079填入Listen Port；\n点击Login，登录到server-1服务器\n打开一个新的bitvise页面，填入目标服务器 server-2 的IP、端口和登录信息，Proxy Setting配置使用server-1服务器开放的1079代理端口。 为了能够访问 server-2 服务器上的网页服务，比如jenkins，还需要在Services标签页中开放代理，比如使用本地未使用的端口1080作为代理端口\n本地浏览器可以使用SwitchyOmega插件，将目标服务器上的jenkins等地址配置使用127.0.0.1:1080代理访问。 使用finalshell配置 bitvise仅支持windows系统，如果在linux（如：ubuntu）上访问目标服务器，可以使用finalshell\n建立4A SSH连接，配置隧道，类型：本地，监听端口：本地未占用的某个端口，如1078；绑定IP: 127.0.0.1，绑定本地IP；目标地址：使用该隧道访问的地址，此处为server-1服务器地址 10.246.100.5；目标端口：目标地址对应的端口，此处为 10000 建立server-1的SSH连接，主机和端口使用4A连接隧道中的绑定ip和监听端口，同时还需建立隧道，供访问server-2服务器代理。 建立目标服务器server-2的SSH连接，同理，主机和端口填入server-1隧道的绑定ip和监听端口，这样就能访问到目标服务器了（需要同时开启4A和server-1的ssh连接），为了访问目标服务器上的网页，还需要在该连接上新建socks5代理隧道 本地浏览器可以使用SwitchyOmega插件，将目标服务器上的jenkins等地址配置使用127.0.0.1:1080代理访问。 使用ProxyJump配置 在linux系统上，也可以使用ProxyJump实现访问server-2服务器，缺点：无法配置socks5代理实现访问目标服务器的网页服务。\n如果想在 Windows 上使用 ssh 的 proxyjump 功能，需要使用一个支持该功能的 ssh 客户端。推荐使用 OpenSSH 。\nWindows 安装 OpenSSH 参考：\nhttps://learn.microsoft.com/zh-cn/windows-server/administration/openssh/openssh_install_firstuse\n在 $HOME/.ssh/config 文件新增如下内容 1 2 3 4 5 6 7 8 9 10 11 12 13 Host 55.250.10.20 HostName 55.250.10.20 User test Port 10000 IdentityFile /opt/develop/ssh/id_rsa ProxyJump test@10.246.110.5:10000 Host 10.246.110.5 HostName 10.246.110.5 User test Port 10000 IdentityFile /opt/develop/ssh/id_rsa ProxyJump abc@192.168.15.45:10011 在终端输入 ssh 55.250.10.20，然后输入abc用户的密码，即可ssh连接到 server-2 服务器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 user@00bafcjc-durwemo9n5:~/.ssh$ ssh 55.250.10.20 abc@192.168.15.45\u0026#39;s password: The authenticity of host \u0026#39;[55.250.10.20]:10000 (\u0026lt;no hostip for proxy command\u0026gt;)\u0026#39; can\u0026#39;t be established. ECDSA key fingerprint is SHA256:TJctlnqugvdS+y7uP9M6DPjoiFHjBBYS9FtwBKBmHFk. Are you sure you want to continue connecting (yes/no)? yes Warning: Permanently added \u0026#39;[55.250.10.20]:10000\u0026#39; (ECDSA) to the list of known hosts. Linux host-55 5.10.0-18-amd64 #1 SMP Debian 5.10.140-1 (2022-09-02) x86_64 The programs included with the Debian GNU/Linux system are free software; the exact distribution terms for each program are described in the individual files in /usr/share/doc/*/copyright. Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent permitted by applicable law. Last login: Tue Jul 25 14:12:14 2023 from 10.63.143.23 secure@host-55:~$ ","date":"2023-07-19T00:00:00Z","image":"https://msdemt.github.io/p/ssh-tunnel/Linux-Symbole-2048x1158_hu6f8b26c03cc6e65572403f8d94a50599_544049_120x120_fill_box_smart1_3.png","permalink":"https://msdemt.github.io/p/ssh-tunnel/","title":"多级ssh访问内网服务器"},{"content":"问题 使用hugo-theme-stack主题时，将项目部署到github pages上后，发现categories图片无法显示\n解决 在静态网页项目根目录下新建名为 .nojekyll 的文件。\n或者在hugo项目中static目录下新建名为 .nojekyll 的文件。\n原因 Github Pages 默认是基于 Jekyll 构建，Jekyll 是一个将纯文本转换为静态网站的工具，它构建的网站下各种目录都是特定的以下划线开头命名的文件夹，例如 _layouts、_posts ，它会忽略掉其它的以下划线开头的文件夹和文件。\n.nojekyll 就是告诉 Github Pages 当前网站不是基于 Jekyll 构建的，不要忽略掉下划线开头的文件和文件夹。\n可见 .nojekyll 主要就是用于 Github Pages 这种有默认规则的网站部署平台，如果是部署在自己的服务器上，可以把它删掉。\n反之，如果你的网站不是 Jekyll 构建的，要部署到 Github Pages ，并且包含下划线开头的文件或文件夹，那么你就需要在根目录添加一个 .nojekyll 空文件。\n参考：\nhttps://github.com/CaiJimmy/hugo-theme-stack/issues/726\nhttps://www.cnblogs.com/babywhale/p/13560573.html\n","date":"2023-07-07T00:00:00Z","permalink":"https://msdemt.github.io/p/github-pages-image/","title":"github pages无法显示图片"},{"content":"git的4个区 工作区（Working Area） 相当于工作空间的目录，即代码的存放位置\n暂存区（Stage） 也称为 index ，用来跟踪已暂存文件，一般存在 .git 下的 index 文件，所以有时也称暂存区为索引。\n本地仓库（Local Repository）\n远程仓库（Remote Repository）\ngit文件的5种状态 未修改（Origin） 已修改（Modified） 已暂存（Staged） 已提交（Committed） 已推送（Pushed） 工作区中文件的初始状态是 未修改，当我们修改文件后，其状态变为 已修改，git diff 命令可以查看已修改但未暂存的文件。（git diff后输入 q 可以退出） 通过 git add 命令可以把已修改的文件添加到暂存区，git diff --cached 可以查看已暂存但未提交的文件。 通过 git commit 将代码提交到本地仓库，git diff [本地分支] [远程分支] 可以查看已提交本地，但未推送到远程分支的文件。 通过 git push 命令将本地分支推送到远程分支。 回退相关命令 git reset 命令 git reset 是进行回退的具体命令，参数介绍如下\n--soft: 仅仅将头指针恢复，已经 add 的暂存区及工作空间的文件修改不变。 --mixed: 将头指针恢复，已经 add 的暂存区也会恢复 ，工作空间的代码修改不变。 --hard: 头指针、暂存区和工作空间的修改都会恢复。 git log 命令 git log 命令查看git的提交记录，但无法查看已经删除的记录。\ngit reflog 命令 git reflog 命令可以查看所有分支的所有操作记录（包括commit和已被删除的commit记录）\n回退操作 回退操作命令\n将已修改或暂存但未提交的文件回退: git reset --hard 将已提交未推送的版本回退: git reset --hard origin/master 将已提交且推送的版本回退： 回退到某个版本：git reset --hard \u0026lt;版本号\u0026gt; 将回退的版本强制推送到远程仓库：git push -f --hard 可以替换为其他恢复等级，一般使用 --soft，这样修改的内容不会丢失\n版本号可以使用 git log 或 git reflog 查看，如 git reset --hard 811aesfi8\ngit reset --hard \u0026lt;版本号\u0026gt; 也可以替换为 git reset --hard HEAD\n回退到当前版本：git reset --hard HEAD 回退到上一个版本：git reset --hard HEAD^ 回退到上两个版本：git reset --hard HEAD^^ 回退到上三个版本：git reset --hard HEAD^^^ 回退到上十个版本：git reset --hard HEAD~10 git 远程覆盖本地 可以执行如下命令将远程仓库的代码直接覆盖本地仓库\ngit fetch \u0026ndash;all git reset \u0026ndash;hard origin/main git pull git fetch 是下载远程仓库的内容，不做任务的合并\ngit reset 把 HEAD 指向刚刚下载的最新版本\n参考：\nhttps://blog.csdn.net/qing040513/article/details/109150075 https://blog.csdn.net/gercke/article/details/119085963\n","date":"2023-07-07T00:00:00Z","image":"https://msdemt.github.io/p/git-rollback/1_Wjxx83j-qyiNvFBy1yOA1w_hufb4407888dbfcda01762496277a1213f_11862_120x120_fill_q75_h2_box_smart1_2.webp","permalink":"https://msdemt.github.io/p/git-rollback/","title":"git回退版本"},{"content":"添加代理 1 2 3 4 5 6 7 //http || https git config --global http.proxy http://127.0.0.1:7890 git config --global https.proxy https://127.0.0.1:7890 //sock5代理 git config --global http.proxy socks5://127.0.0.1:7891 git config --global http.proxy socks5://127.0.0.1:7891 只针对github配置代理\n1 2 3 4 5 6 7 8 #使用socks5代理（推荐） git config --global http.https://github.com.proxy socks5://127.0.0.1:7890 #使用http代理（不推荐） git config --global http.https://github.com.proxy http://127.0.0.1:7890 #取消socks5代理 git config --global --unset http.https://github.com.proxy #取消http代理 git config --global --unset http.https://github.com.proxy 查看代理 1 2 git config --global --get http.proxy git config --global --get https.proxy 取消代理 1 2 git config --global --unset http.proxy git config --global --unset https.proxy clash for windows 代理 clash for windows 的 http 和 socks5 代理使用的是同一个端口。\n参考：\nhttps://blog.csdn.net/weimeibuqieryu/article/details/106793645 https://github.com/Fndroid/clash_for_windows_pkg/issues/1244\n","date":"2023-07-07T00:00:00Z","image":"https://msdemt.github.io/p/git-proxy/1_Wjxx83j-qyiNvFBy1yOA1w_hufb4407888dbfcda01762496277a1213f_11862_120x120_fill_q75_h2_box_smart1_2.webp","permalink":"https://msdemt.github.io/p/git-proxy/","title":"git设置代理"},{"content":"添加子模块 1 git submodule add \u0026lt;url\u0026gt; \u0026lt;path\u0026gt; url为子模块git路径 path为子模块存储的目录路径\n如，将 hugo-theme-stack 项目作为子模块添加到本地项目的 themes 目录\n1 git submodule add https://github.com/CaiJimmy/hugo-theme-stack.git themes 子模块添加成功后，执行 git status 命令可以看到 .gitmodules 文件已被修改，并新增了一个子模块\n执行 git diff --cached 命令可以查看修改内容\n执行 git commit 命令可以将子模块添加到本地仓库\n添加子模块时使用 -b 参数指定分支\n1 git submodule add -b main [URL to Git repo]; 若子模块已添加，可以在 .gitmodules 中设置分支，其中 public 是主模块中安装子模块的名称， stable 是对应要设置的分支名称。\n1 git config -f .gitmodules submodule.public.branch stable 执行后，会在 .gitmodules 中的子模块添加分支（branch = main），如下\n1 2 3 4 [submodule \u0026#34;public\u0026#34;] path = public url = https://github.com/msdemt/msdemt.github.io.git branch = main 使用子模块 直接克隆包含子模块的项目时，子模块目录下没有任何文件，需要在项目的根目录下执行如下命令，完成子模块的下载\n1 2 git submodule init git submodule update 或者\n1 git submodule update --init 克隆项目的同时下载子模块\n1 git clone \u0026lt;url\u0026gt; --recursive 更新子模块 子模块的维护者更新子模块后，使用子模块的项目必须手动更新子模块才可以使用最新的子模块。\n在项目中，进入子模块目录下，执行 git pull 更新，执行 git log 可以查看子模块的更新内容。\n之后进入项目根目录，使用 git add 和 git commit 命令将子模块更新到项目中，然后使用 git push 命令将更新子模块的项目推送到远程仓库。\n如果自己要修改子模块内容，需要先在子模块根路径下执行 git checkout \u0026lt;分支名\u0026gt; ，然后才可以对该子模块进行修改和提交，否则git push提交时出现Everything up-to-date。\n将子模块修改提交后，如果希望将项目依赖的子模块更新到最新版本，需要在项目根路径下执行 git submodule update --remote，然后将项目提交到远程仓库。\n删除子模块 使用 git submodule deinit \u0026lt;子模块名称\u0026gt; 和 git rm \u0026lt;子模块名称\u0026gt; 命令卸载一个子模块。\n如果添加 \u0026ndash;force 参数，则子模块工作区内即使有本地的修改，也会被移除。\n例如，删除名为 test-submodule 子模块\n1 2 git submodule deinit test-submodule git rm test-submodule 如果完全删除子模块，还需要删除项目根路径下的 .gitmodules 文件和 .git/modules 目录下的子模块文件\n问题 子模块更新分支 添加子模块\n1 git submodule add https://github.com/msdemt/msdemt.github.io.git public 子模块更新后，在父模块中更新子模块到最新版本\n1 git submodule update --remote 更新失败，错误如下\n1 2 fatal: Needed a single revision 无法在子模组路径 \u0026#39;public\u0026#39; 中找到当前版本 origin/maste 发现父模块依赖的子模块分支为master，正确应该是main分支（子模块项目初始分支是master，后来我新增了main作为默认分支，删掉了master分支）\n参考：https://blog.csdn.net/weboof/article/details/108517187\n更新子模块的分支\n1 git config -f .gitmodules submodule.public.branch main 再执行更新子模块\n1 git submodule update --remote 参考：\nhttps://blog.csdn.net/guotianqing/article/details/82391665 https://blog.csdn.net/Lee_queenie/article/details/127386151\n","date":"2023-07-07T00:00:00Z","image":"https://msdemt.github.io/p/git-submodule/1_Wjxx83j-qyiNvFBy1yOA1w_hufb4407888dbfcda01762496277a1213f_11862_120x120_fill_q75_h2_box_smart1_2.webp","permalink":"https://msdemt.github.io/p/git-submodule/","title":"git子模块操作"},{"content":"添加字体 ubuntu上使用vscode编写代码时，字体不好看。\n在windows上，vscode的默认字体为 Consolas，将该字体安装到ubuntu中，让vscode使用该字体。\n进入windows中的C:\\Windows\\Fonts，将Consolas中的ttf字体文件拷贝到ubuntu系统中。\n在ubuntu系统中，新建consolas文件夹存放字体\n1 sudo mkdir /usr/share/fonts/opentype/consolas 将consolas字体文件移动到该文件夹中\n然后执行如下命令，刷新字体缓存\n1 2 sudo dpkg-reconfigure fontconfig sudo fc-cache -vf 配置vscode 设置-文本编辑器-字体-Font Family\n将Consolas字体添加到行首，如下\n1 \u0026#39;Consolas\u0026#39;,\u0026#39;Droid Sans Mono\u0026#39;, \u0026#39;monospace\u0026#39;, monospace 或直接在settings.json中添加\n1 \u0026#34;editor.fontFamily\u0026#34;: \u0026#34;\u0026#39;Consolas\u0026#39;,\u0026#39;Droid Sans Mono\u0026#39;, \u0026#39;monospace\u0026#39;, monospace\u0026#34;, 重启vscode\nConsolas字体\n对应settings.json中会设置如下\n1 2 \u0026#34;editor.fontSize\u0026#34;: 18, \u0026#34;editor.fontFamily\u0026#34;: \u0026#34;\u0026#39;Consolas\u0026#39;,\u0026#39;Droid Sans Mono\u0026#39;, \u0026#39;monospace\u0026#39;, monospace\u0026#34;, vscode调整桌面字体大小\n1 \u0026#34;window.zoomLevel\u0026#34;: 1, ","date":"2023-07-07T00:00:00Z","image":"https://msdemt.github.io/p/ubuntu-vscode-font/ubuntu_logo_hu373a6c33440a9fb65cfc39e6a6372242_135517_120x120_fill_box_smart1_3.png","permalink":"https://msdemt.github.io/p/ubuntu-vscode-font/","title":"ubuntu配置vscode字体"},{"content":"题 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n你可以按任意顺序返回答案。\n示例 1：\n输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。\n解 暴力枚举法 1 2 3 4 5 6 7 8 9 10 11 public static int[] twoSum(int[] nums, int target) { int n = nums.length; for(int i=0; i\u0026lt;n; ++i){ for(int j=i+1; j\u0026lt;n; ++j){ if(nums[i] + nums[j] == target){ return new int[]{i, j}; } } } return new int[0]; } 复杂度分析\n时间复杂度：O(N^2)，其中 N 是数组中的元素数量。最坏情况下数组中任意两个数都要被匹配一次。 空间复杂度：O(1) 哈希表 1 2 3 4 5 6 7 8 9 10 public static int[] twoSum1(int[] nums, int target) { Map\u0026lt;Integer, Integer\u0026gt; hashtable = new HashMap\u0026lt;Integer, Integer\u0026gt;(); for(int i=0; i\u0026lt;nums.length; ++i){ if(hashtable.containsKey(target - nums[i])){ return new int[]{hashtable.get(target - nums[i]), i}; } hashtable.put(nums[i], i); } return new int[0]; } 复杂度分析：\n时间复杂度：O(N), 其中 N 是数组中的元素数量。对于每一个元素 x，我们可以 O(1) 地寻找 target - x。 空间复杂度：O(N)，其中 N 是数组中的元素数量。主要为哈希表的开销。 作者：LeetCode-Solution 链接：https://leetcode.cn/problems/two-sum/solution/liang-shu-zhi-he-by-leetcode-solution/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n","date":"2023-07-07T00:00:00Z","image":"https://msdemt.github.io/p/two_sum/1603980178-c305fb1df5f5fb7_hu61eb5bf94bba91376f0df83c72584e6c_90324_120x120_fill_box_smart1_3.png","permalink":"https://msdemt.github.io/p/two_sum/","title":"两数之和"},{"content":"ubuntu 安装后，默认没有root用户密码，所以，无法使用su命令切换到root用户\n配置ubuntu root用户密码\n1 sudo passwd 配置后，就可以使用su命令切换到root用户了\n","date":"2022-11-23T00:00:00Z","image":"https://msdemt.github.io/p/ubuntu-root-pwd/ubuntu_logo_hu373a6c33440a9fb65cfc39e6a6372242_135517_120x120_fill_box_smart1_3.png","permalink":"https://msdemt.github.io/p/ubuntu-root-pwd/","title":"ubuntu配置root密码"}]